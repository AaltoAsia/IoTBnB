%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.995 Copyright 2015 Radical Eye Software
%%Title: IoTBnB_Logo.dvi
%%CreationDate: Tue Aug 23 10:18:18 2016
%%BoundingBox: 63 688 184 727
%%DocumentFonts: MarVoSym DroidSansMono
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips IoTBnB_Logo -E -o IoTBnB_Logo.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.08.23:1018
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/07/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Voß <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.07, 2015/05/13
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  25 dict begin
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan /RotAngle ED
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  /mtrx CM def 
  x0 y0 translate 
  RotAngle rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  mtrx setmatrix 
  pop pop pop pop 
  end
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-3dplot.pro 0 0
%% $Id: pst-3dplot.pro 882 2014-02-01 13:12:37Z herbert $
%%
%% This is file `pst-3dplot.pro',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-3dplot.tex'
%%
%% Herbert Voss <voss _at_ PSTricks.de>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-3dplot' is a PSTricks package to draw 3d curves and graphical objects
%%
%%
%% version 0.32 / 2014-02-01  Herbert Voss <hvoss _at_ tug.org>
%% with contributions of Darrell Lamm <darrell.lamm _at_ gtri.gatech.edu<
%%            
%
/tx@3DPlotDict 200 dict def
tx@3DPlotDict begin
%
/printDot { gsave 2 copy 2 0 360 arc fill stroke grestore } def
%
/saveCoor { 
  dzUnit mul /z ED
  dyUnit mul /y ED
  dxUnit mul /x ED
} def
%
/3Dto2D { % true or false on stack
  { RotatePoint } if
  1 { %  dummy loop, will run only 1 time, allows exit 
    coorType 0 le {                                               % the default |
      /x2D x leftHanded not { neg } if Alpha cos mul y Alpha sin mul add def %  /\  co system
      /y2D x leftHanded { neg } if Alpha sin mul y Alpha cos mul add neg Beta sin mul z Beta cos mul add def
      exit } if
    coorType 1 le { 
      /x2D y x Alpha 90 sub sin mul sub def  %  |/_  co system, no shortened x axis
      /y2D z x Alpha 90 sub cos mul sub def 
      exit } if
    coorType 2 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x 0.5 mul sub def
      /y2D z x 0.5 mul sub def 
      exit } if
    coorType 3 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x -0.5 mul sub def
      /y2D z x -0.5 mul sub def 
      exit } if
    coorType 4 le { % Normalbild in Trimetrie Skalierung so, dass coorType2
       /x2D x -0.5 mul y 1 mul add def
       /y2D x -0.5 mul y -0.25 mul add z 1 mul add def
       exit } if
    coorType 5 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees 
      /x2D x z 0.5 mul Alpha cos mul add def
      /y2D y z 0.5 mul Alpha sin mul add def 
      exit } if
    coorType 6 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees and z into the front
      /x2D y x -0.559 mul Alpha cos mul add def
      /y2D z x -0.559 mul Alpha sin mul add def 
      exit } if
  } repeat
} def
/ConvertTo2D { true 3Dto2D } def
/ConvertTo2DWithoutRotating { false 3Dto2D } def
%
/Conv3D2D { /z ED /y ED /x ED ConvertTo2D x2D y2D } def
%
/ConvertToCartesian {
  /latitude exch def
  /longitude exch def
  /Radius exch def
  1 { %  dummy loop, will run only 1 time, allows exit
    SphericalCoorType 0 le {                                               % the default |
     /z { Radius latitude sin mul } def
     /x { Radius longitude cos mul latitude cos mul } def
     /y { Radius longitude sin mul latitude cos mul } def
      exit } if
    SphericalCoorType 2 le {
     /z { Radius longitude cos mul } def
     /x { Radius longitude sin mul latitude cos mul} def
     /y { Radius longitude sin mul latitude sin mul } def
      exit } if
  } repeat
} def
%
/ConvCylToCartesian { % r phi h -> x y z
  3 1 roll			% h r phi
  /Phi ED
  /Radius ED			% h->z on stack
  Radius Phi cos mul exch 	% x z
  Radius Phi sin mul exch	% x y z
} def
%
/SphericalTo2D {
  x y z ConvertToCartesian ConvertTo2D
} def
%
/CylinderTo2D { %  r phi h
  x y z ConvCylToCartesian ConvertTo2D
} def
%
/convertStackTo2D {
  counttomark
  /n ED /n3 n 3 div cvi def
  n3 {
    n -3 roll
    SphericalCoor { ConvertToCartesian } { saveCoor } ifelse
    ConvertTo2D
    x2D xUnit y2D yUnit
    /n n 1 sub def
  } repeat
} def
%
% the angle in the parameter equation for an ellipse is not proportional to the real angle!
% phi=atan(b*tan(angle)/a)+floor(angle/180+0.5)*180
%
/getPhi { % on stack: vecA vecB angle 
  3 dict begin
  /angle exch def /vecB exch def /vecA exch def
  angle cvi 90 mod 0 eq { angle } { vecA angle tan mul vecB atan 
  angle 180 div .5 add floor 180 mul add } ifelse 
  end
} def
%
/RotSet (set ) def
%
/eulerRotation false def
% Matrix multiplication procedure
/matmul {

  /M@tMulDict 20 dict def
  M@tMulDict begin
  /m2 ED
  /m1 ED
  m1 dup length 2 sub 2 getinterval aload pop
  /col1max ED
  /row1max ED
  m2 dup length 2 sub 2 getinterval aload pop
  /col2max ED
  /row2max ED
  /m3 row1max col2max mul 2 add array def
  m3 dup length 2 sub row1max col2max 2 array astore putinterval
  0 1 row1max 1 sub {
   /row ED
   0 1 col2max 1 sub {
    /col ED
    /sum 0 def
    0 1 col1max 1 sub{
    /rowcol ED
    sum
    m1 row col1max mul rowcol add get
    m2 rowcol col2max mul col add get
    mul add 
    /sum ED
    } for
    m3 row col2max mul col add sum put
   } for
  } for
  m3
  end % end of M@tMulDict

} def
%
/SetMQuaternion {

  /MnewTOold 11 array def

  /Qu@ternionDict 30 dict def
  Qu@ternionDict begin

  /normRotVec  xRotVec yRotVec zRotVec 3 array astore VecNorm  def
  normRotVec 0 gt
  {/xRotVecNorm xRotVec normRotVec div def
   /yRotVecNorm yRotVec normRotVec div def
   /zRotVecNorm zRotVec normRotVec div def
   RotAngle}
  {/xRotVecNorm 1 def
   /yRotVecNorm 0 def
   /zRotVecNorm 0 def 
   0} ifelse

  2 div dup
  /q0 exch cos def
      sin dup dup
  /q1 exch xRotVecNorm mul def
  /q2 exch yRotVecNorm mul def
  /q3 exch zRotVecNorm mul def

  /q0q0 q0 q0 mul def
  /q0q1 q0 q1 mul def
  /q0q2 q0 q2 mul def
  /q0q3 q0 q3 mul def

  /q1q1 q1 q1 mul def
  /q1q2 q1 q2 mul def
  /q1q3 q1 q3 mul def

  /q2q2 q2 q2 mul def
  /q2q3 q2 q3 mul def

  /q3q3 q3 q3 mul def

  MnewTOold 0 q0q0 q1q1 add q2q2 sub q3q3 sub put
  MnewTOold 1 q1q2 q0q3 sub 2 mul put
  MnewTOold 2 q1q3 q0q2 add 2 mul put

  MnewTOold 3 q1q2 q0q3 add 2 mul put
  MnewTOold 4 q0q0 q1q1 sub q2q2 add q3q3 sub put
  MnewTOold 5 q2q3 q0q1 sub 2 mul put

  MnewTOold 6 q1q3 q0q2 sub 2 mul put
  MnewTOold 7 q2q3 q0q1 add 2 mul put
  MnewTOold 8 q0q0 q1q1 sub q2q2 sub q3q3 add put

  MnewTOold 9 3 put
  MnewTOold 10 3 put

  end % end of Qu@ternionDict

} def
%
/SetMxyz {
  1.0 0.0 0.0  0.0 1.0 0.0  0.0 0.0 1.0  3 3  11 array astore /MnewTOold ED
  RotSequence cvx exec % Now create a new MnewTOold using xyz, etc.
} def
%
/ConcatMQuaternion {
  MnewTOold % Push onto stack
  SetMQuaternion % Uses [xyz]RotVec and RotAngle to make MnewToOld 
  MnewTOold matmul /MnewTOold ED
} def
%
/ConcatMxyz {
  MnewTOold % Push onto stack
  SetMxyz % Uses RotX, etc. to set MnewTOold 
  MnewTOold matmul /MnewTOold ED
} def
%
/RotatePoint{
  MnewTOold x y z  3 1  5 array astore matmul
  0 3 getinterval aload pop 
  /z ED 
  /y ED 
  /x ED 
} def
%
/makeMoldTOnew {
  /MoldTOnew 11 array def
  MoldTOnew 0 MnewTOold 0 get put
  MoldTOnew 1 MnewTOold 3 get put
  MoldTOnew 2 MnewTOold 6 get put
  MoldTOnew 3 MnewTOold 1 get put
  MoldTOnew 4 MnewTOold 4 get put
  MoldTOnew 5 MnewTOold 7 get put
  MoldTOnew 6 MnewTOold 2 get put
  MoldTOnew 7 MnewTOold 5 get put
  MoldTOnew 8 MnewTOold 8 get put
  MoldTOnew 9               3 put
  MoldTOnew 10              3 put
} def
%
/RotXaxis { 
  eulerRotation 
  {1 0 0}
  {makeMoldTOnew MoldTOnew  1 0 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotX def
  ConcatMQuaternion
} def
/RotYaxis { 
  eulerRotation 
  {0 1 0}
  {makeMoldTOnew MoldTOnew  0 1 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotY def
  ConcatMQuaternion
} def
/RotZaxis { 
  eulerRotation 
  {0 0 1}
  {makeMoldTOnew MoldTOnew  0 0 1  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotZ def
  ConcatMQuaternion
} def
/xyz { RotXaxis RotYaxis RotZaxis } def
/yxz { RotYaxis RotXaxis RotZaxis } def
/yzx { RotYaxis RotZaxis RotXaxis } def
/xzy { RotXaxis RotZaxis RotYaxis } def
/zxy { RotZaxis RotXaxis RotYaxis } def
/zyx { RotZaxis RotYaxis RotXaxis } def
/quaternion { } def % Null
%
/VecNorm { 0 exch { dup mul add } forall sqrt } def
%
/UnitVec {			% on stack is [a]; returns a vector with [a][a]/|a|=1 
  dup VecNorm /norm ED
  norm 0 lt {/norm 0 def} if
  { norm div } forall 3 array astore } def
%
/AxB {				% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a2 b3 mul a3 b2 mul sub
    a3 b1 mul a1 b3 mul sub
    a1 b2 mul a2 b1 mul sub
    3 array astore } def
%
/AaddB {			% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a1 b1 add a2 b2 add a3 b3 add
    3 array astore } def
%
/AmulC {			% on stack is [a] and c; returns [a] mul c
    /factor ED { factor mul } forall 3 array astore } def
%
%
/setColorLight { % expects 7 values on stack C M Y K xL yL zL
% les rayons de lumi�re
  xLight dup mul yLight dup mul zLight dup mul add add sqrt /NormeLight ED
% the color values
  /K ED
  /Yellow ED
  /Magenta ED
  /Cyan ED
} def
%
/facetteSphere {
  newpath
  /Xpoint Rsphere theta cos mul phi cos mul CX add def
  /Ypoint Rsphere theta sin mul phi cos mul CY add def
  /Zpoint Rsphere phi sin mul CZ add def
  Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end moveto
  theta 1 theta increment add {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi cos mul CY add def
    /Zpoint Rsphere phi sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end  lineto
  } for
  phi 1 phi increment add {
    /phi1 ED
    /Xpoint Rsphere theta increment add cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta increment add sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  theta increment add -1 theta {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi increment add cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi increment add cos mul CY add def
    /Zpoint Rsphere phi increment add sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  phi increment add -1 phi {
    /phi1 ED
    /Xpoint Rsphere theta cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  closepath 
} def
%
/MaillageSphere { 
% on stack must be x y z Radius increment C M Y K 
  setColorLight
  /increment ED
  /Rsphere ED
  /CZ ED
  /CY ED
  /CX ED
  /StartTheta 0 def
  /condition { PSfacetteSphere 0 ge } def
  -90 increment 90 increment sub {%
    /phi ED
    StartTheta increment 360 StartTheta add increment sub {%
      /theta ED
      % Centre de la facette
      /Xpoint Rsphere theta increment 2 div add cos mul phi increment 2 div add cos mul CX add def
      /Ypoint Rsphere theta increment 2 div add sin mul phi increment 2 div add cos mul CY add def
      /Zpoint Rsphere phi increment 2 div add sin mul CZ add def
      % normale a la facette
      /nXfacette Xpoint CX sub def
      /nYfacette Ypoint CY sub def
      /nZfacette Zpoint CZ sub def
      % test de visibilite
      /PSfacetteSphere 
        vX nXfacette mul
        vY nYfacette mul add
        vZ nZfacette mul add
      def
      condition {
        gsave
        facetteSphere
        /cosV { 1 xLight nXfacette mul
          yLight nYfacette mul
          zLight nZfacette mul
          add add
          NormeLight
          nXfacette dup mul
          nYfacette dup mul
          nZfacette dup mul
          add add sqrt mul div sub } bind def
        Cyan cosV mul Magenta cosV mul Yellow cosV mul K cosV mul setcmykcolor fill 
	grestore
%	0 setgray
        showgrid { facetteSphere stroke } if
      } if 
    } for
    % /StartTheta StartTheta increment 2 div add def
  } for
} def
%
%---------------------- Cylinder ---------------------------
%
/PlanCoupeCylinder { %
  /TableauxPoints [
    0 1 359 { 
      /phi ED 
      [ Radius phi Height ConvCyl2d ] % on décrit le cercle
    } for
  ] def
  newpath
  TableauxPoints 0 get aload pop moveto
  1 1 359 { TableauxPoints exch get aload pop lineto } for
  closepath
} def
%
/facetteCylinder { % 
    newpath
    Radius phi currentHeight ConvCyl2d moveto
    phi 1 phi dAngle add  { % loop variable on stack
      Radius exch currentHeight ConvCyl2d lineto        
    } for
    phi dAngle add -1 phi { %	fill dHeight
      Radius exch currentHeight dHeight add ConvCyl2d lineto 
    } for
    closepath
  } def % facette
%
/MaillageCylinder { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K
      /dHeight ED /dAngle ED /Height ED /Radius ED
      /CZ ED /CY ED /CX ED } if
%     
    0 dHeight Height dHeight sub {
      /currentHeight ED
      0 dAngle 360 dAngle sub {
        /phi ED
% Normal vector of the center
        /nXfacetteCylinder Radius phi dAngle 2 div add cos mul CX add def 
        /nYfacetteCylinder Radius phi dAngle 2 div add sin mul CY add def 
        /nZfacetteCylinder currentHeight dHeight 2 div add CZ add def 
        /NormeN 
          nXfacetteCylinder dup mul
          nYfacetteCylinder dup mul
          nZfacetteCylinder dup mul
          add add sqrt def
        NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilité
       /PSfacetteCylinder 
    	    vX nXfacetteCylinder mul
            vY nYfacetteCylinder mul add
            vZ nZfacetteCylinder mul add def
       condition {
         facetteCylinder
         /cosV 
	   1 xLight nXfacetteCylinder mul
           yLight nYfacetteCylinder mul
           zLight nZfacetteCylinder mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
          showgrid { 
            0 setgray
            facetteCylinder % drawing the segments
            stroke } if
       } if
     } for
    } for
} def
%
%------------------------ Cylinder type II -----------------------
%
/MoveTo { Conv3D2D moveto } def
/LineTo { Conv3D2D lineto } def

/IIIDEllipse { % x y z rA rB startAngle endAngle Wedge
  /dAngle 1 def
  /isWedge ED
  /endAngle ED
  /startAngle ED
  /radiusB ED
  /radiusA ED
  startAngle cos radiusA mul startAngle sin radiusB mul 0 
  isWedge { 0 0 moveto LineTo }{ MoveTo } ifelse
  /Angle startAngle def
  startAngle dAngle endAngle {
    /Angle ED
    Angle cos radiusA mul Angle sin radiusB mul 0 LineTo  
  } for
  isWedge { 0 0 lineto } if
} def

/IIIDCircle { % x y z r startAngle endAngle Wedge
  7 3 roll % startAngle endAngle Wedge x y z r
  dup      % startAngle endAngle Wedge x y z r r
  8 -3 roll
  IIIDEllipse 
} def

/IIIDWedge { % x y z r startAngle endAngle
  true IIIDCircle
} def

/IIIDCylinder {% x y z r h start end wedge
  /isWedge ED
  /increment ED
  /endAngle ED
  /startAngle ED
  /height ED
  /radius ED
  startAngle increment endAngle {
    /Angle ED
    radius Angle 0 ConvCylToCartesian MoveTo  
    radius Angle height ConvCylToCartesian LineTo  
  } for
  stroke
} def
%
%---------------------- Box ---------------------------
%
/PlanCoupeBox { % x y z
  /TableauxPoints [
      [ CX CY CZ Height add ConvBox2d ] % top or bottom
      [ CX CY Depth add CZ Height add ConvBox2d ]
      [ CX Width add CY Depth add CZ Height add ConvBox2d ] 
      [ CX Width add CY CZ Height add ConvBox2d ] 
      [ CX CY CZ Height add ConvBox2d ] % bottom
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 3 {
      TableauxPoints exch get aload pop
      lineto } for
    closepath
} def
%
/facetteBox { % 
    newpath
    dup
    1 eq { % back
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    2 eq { % right
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    3 eq { % left
      CX Width add CY CZ ConvBox2d moveto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
    } if
    4 eq { % front
      CX CY Depth add CZ ConvBox2d moveto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
    } if
    closepath
  } def % facette
%
/TestPlane { % on stack x y z of the plane center and # of plane
  /nZfacetteBox ED /nYfacetteBox ED /nXfacetteBox ED
  /Plane ED
  /NormeN 
    nXfacetteBox dup mul
    nYfacetteBox dup mul
    nZfacetteBox dup mul
    add add sqrt def
  NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilite
  /PSfacetteBox 
    vX nXfacetteBox mul
    vY nYfacetteBox mul add
    vZ nZfacetteBox mul add def
  condition {
    Plane facetteBox
         /cosV 
	   1 xLight nXfacetteBox mul
           yLight nYfacetteBox mul
           zLight nZfacetteBox mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         0 setgray
         Plane facetteBox % drawing the segments
         stroke
       } if
} def
%
/MaillageBox { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K 
      /Depth ED /Height ED /Width ED
      /CZ ED /CY ED /CX ED } if
%
% Normal vector of the box center
  /PlaneSet [
    [ Width 2 div CX add 
      CY 
      Height 2 div CZ add ] % normal back
    [ CX 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal right
    [ Width CX add 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal left
    [ Width 2 div CX add 
      Depth CY add 
      Height 2 div CZ add ] % normal front
  ] def
  PlaneSequence length 0 eq { % user defined?
    Alpha abs cvi 360 mod /iAlpha ED
    iAlpha 90 lt { [ 1 2 3 4 ]  
      }{ iAlpha 180 lt { [ 2 4 1 3 ]  
        }{ iAlpha 270 lt { [ 3 4 1 2 ] }{ [ 3 1 4 2] } ifelse } ifelse } ifelse 
  }{ PlaneSequence } ifelse 
  { dup 1 sub PlaneSet exch get aload pop TestPlane } forall
} def
%
%--------------------------- Paraboloid -----------------------------
/PlanCoupeParaboloid {
    /Z height store
    /V {Z sqrt} bind def
    /TableauxPoints [
      0 1 359 { 
        /U ED [ U U Z V calculate2DPoint ] % on decrit le cercle
      } for
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 359 {
      /compteur ED
      TableauxPoints compteur get aload pop
      lineto } for
    closepath
} def
%
/facetteParaboloid{
    newpath
    U U Z V calculate2DPoint moveto
    U 1 U increment add  {%
      /U1 ED
      U1 U1 Z V calculate2DPoint lineto
    } for
    Z pas10 Z pas add pas10 add{
      /Z1 ED
      /V {Z1 sqrt} bind def
      U1 U1 Z1 V calculate2DPoint lineto
    } for
    U increment add -1 U {%
      /U2 ED
      U2 U2 Z pas add V calculate2DPoint lineto
    } for
    Z pas add pas10 sub pas10 neg Z pas10 sub {
      /Z2 ED
      /V Z2 abs sqrt def
      U U Z2 V calculate2DPoint lineto
    } for
    closepath
} def % facette
%
/MaillageParaboloid {
  % on stack true or false for saving values
    { setColorLight  % expects 7 values on stack C M Y K xL yL zL 
%      /CZ ED /CY ED /CX ED 
    } if    
    0 pas height pas sub {%
      /Z ED
      /V Z sqrt def
      0 increment 360 increment sub {%
        /U ED
% Centre de la facette
        /Ucentre U increment 2 div add def
        /Vcentre Z pas 2 div add sqrt def
% normale à la facette
        /nXfacetteParaboloid 2 Vcentre dup mul mul Ucentre cos mul radius mul def
        /nYfacetteParaboloid 2 Vcentre dup mul mul Ucentre sin mul radius mul def
        /nZfacetteParaboloid Vcentre neg radius dup mul mul def
        /NormeN {
          nXfacetteParaboloid dup mul
          nYfacetteParaboloid dup mul
          nZfacetteParaboloid dup mul
          add add sqrt} bind def
        NormeN 0 eq {/NormeN 1e-10 def} if
% test de visibilit�
       /PSfacetteParaboloid vX nXfacetteParaboloid mul
                  vY nYfacetteParaboloid mul add
                  vZ nZfacetteParaboloid mul add def
       condition {
         facetteParaboloid
         /cosV 1 xLight nXfacetteParaboloid mul
           yLight nYfacetteParaboloid mul
           zLight nZfacetteParaboloid mul
           add add
           NormeLight
           NormeN mul div sub def
         Cyan Magenta Yellow K  
         cosV mul 4 1 roll cosV mul 4 1 roll cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         showgrid {
           0 setgray
           facetteParaboloid
           stroke } if
       } if
     } for
    } for
} def
%
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
% u -> e_u with |e_u|=1 
/vector-unit { 1 dict begin
  dup vector-length 1 exch div 
  vector-scale
  end 
} def
%
% u v -> u+v
/vector-add { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch { 	% i u[i]
    v 		% i u[i] v
    2 index get add 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
  end 
} def
%
% u v -> u-v
/vector-sub { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch {	% i u[i]
    v 		% i u[i] v
    2 index get sub 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
end } def
%
% [v] c -> [c.v]
/vector-scale { 1 dict begin
  /c exch def
  [ exch
  { 		% s i u[i]
    c mul	% s i u[i] v 
  } forall
  ]
  end } def
%
%
% [u] [v] -> [u x v]
/vector-prod { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  [ y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub ]
end
} def
%
% [u] [v] -> u.v
/vector-mul { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  x xp mul y yp mul add z zp mul add
end
} def
%
% [x y z ... ] -> r
% watch out for overflow
/vector-length { 1 dict begin
dup
% find maximum entry
/max 0 def
{ % max 
  abs dup max gt {
    % if abs gt max
    /max exch def
  } {
    pop
  } ifelse
} forall
max 0 ne {
  0 exch 
  {  % 0 v[i]
    max div dup mul add
  } forall
  sqrt
  max mul
} {
  pop 0
} ifelse
end } def
%
end % tx@3DPlotDict
%

%%EndProcSet
%%BeginProcSet: pst-blur.pro 0 0
%%
%% This is file `pst-blur.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% pst-blur.dtx  (with options: `prolog')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from pst-blur.pro.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file pst-blur.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%% $Id: pst-blur.dtx,v 2.0 2005/09/08 09:48:33 giese Exp $
%%
%% Copyright 1998-2007 Martin Giese, mgiese@risc.uni-linz.ac.at
%%                     Herbert Voss, voss@pstricks.de
%%
%% This file is under the LaTeX Project Public License
%% See CTAN archives in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-blur' is a PSTricks package for blurred shadows
%%
/tx@PstBlurDict 60 dict def
tx@PstBlurDict begin
/Iterate {
  /SegLines ED
  /ThisB ED /ThisG ED /ThisR ED
  /NextB ED /NextG ED /NextR ED
  /W 2.0 BlurRadius mul def
  /WDec W SegLines div def
  /RInc NextR ThisR sub SegLines div def
  /GInc NextG ThisG sub SegLines div def
  /BInc NextB ThisB sub SegLines div def
  /R ThisR def
  /G ThisG def
  /B ThisB def
  SegLines {
    R G B
    sqrt 3 1 roll sqrt 3 1 roll sqrt 3 1 roll
    setrgbcolor
    gsave W setlinewidth
    stroke grestore
    /W W WDec sub def
    /R R RInc add def
    /G G GInc add def
    /B B BInc add def
  } bind repeat
} def
/BlurShadow {
  Shadow
  /BlurSteps ED
  /BlurRadius ED
  dup mul /BEnd ED dup mul /GEnd ED dup mul /REnd ED
  dup mul /BBeg ED dup mul /GBeg ED dup mul /RBeg ED
  RBeg REnd add 0.5 mul /RMid ED
  GBeg GEnd add 0.5 mul /GMid ED
  BBeg BEnd add 0.5 mul /BMid ED
  /OuterSteps BlurSteps 2 div cvi def
  /InnerSteps BlurSteps OuterSteps sub def
  1 setlinejoin
  RMid GMid BMid REnd GEnd BEnd OuterSteps Iterate
  gsave RBeg sqrt GBeg sqrt BBeg sqrt setrgbcolor fill grestore
  clip
  0 setlinejoin
  RMid GMid BMid RBeg GBeg BBeg InnerSteps Iterate
} def
end

%%EndProcSet
%%BeginProcSet: marvosym.pfb 0 0
%!PS-AdobeFont-1.0: MarVoSym Martin Vogel's Symbols are released under the Open Font License - look for information and new versions at http://www.marvosym.com - Neue Versionen und Informationen finden Sie auf http://www.marvosym.de
%%CreationDate: Mon Aug 15 18:49:48 2011
% Converted by ttf2pt1 3.4.4/ft
% Args: -b marvosym.ttf 
%%EndComments
12 dict begin
/FontInfo 9 dict dup begin
/version (TeX version of August 2011, based on original Version 3.10 November 04, 2007) readonly def
/Notice (Martin Vogel's Symbols, including this derivative with TeX support, are released under the Open Font License - see http://ctan.org/pkg/marvosym) readonly def
/FullName (MarVoSym with TeX support) readonly def
/FamilyName (MarVoSym with TeX support) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0.000000 def
/isFixedPitch false def
/UnderlinePosition 0 def
/UnderlineThickness 0 def
end readonly def
/FontName /MarVoSym def
/PaintType 0 def
/StrokeWidth 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontBBox {-572 -214 3014 925} readonly def
/Encoding 256 array
dup 0 /.null put
dup 1 /.notdef put
dup 2 /.notdef put
dup 3 /.notdef put
dup 4 /.notdef put
dup 5 /.notdef put
dup 6 /.notdef put
dup 7 /.notdef put
dup 8 /.null put
dup 9 /nonmarkingreturn put
dup 10 /.notdef put
dup 11 /.notdef put
dup 12 /.notdef put
dup 13 /uni000D put
dup 14 /.notdef put
dup 15 /.notdef put
dup 16 /.notdef put
dup 17 /.notdef put
dup 18 /.notdef put
dup 19 /.notdef put
dup 20 /.notdef put
dup 21 /.notdef put
dup 22 /.notdef put
dup 23 /.notdef put
dup 24 /.notdef put
dup 25 /.notdef put
dup 26 /.notdef put
dup 27 /.notdef put
dup 28 /.notdef put
dup 29 /uni001D put
dup 30 /.notdef put
dup 31 /uni001F put
dup 32 /MVspace put
dup 33 /Stopsign put
dup 34 /Beam put
dup 35 /Bearing put
dup 36 /LooseBearing put
dup 37 /FixedBearing put
dup 38 /LeftTorque put
dup 39 /RightTorque put
dup 40 /MVLeftBracket put
dup 41 /MVRightBracket put
dup 42 /MVMultiplication put
dup 43 /MVPlus put
dup 44 /MVComma put
dup 45 /MVMinus put
dup 46 /MVPeriod put
dup 47 /MVDivision put
dup 48 /MVZero put
dup 49 /MVOne put
dup 50 /MVTwo put
dup 51 /MVThree put
dup 52 /MVFour put
dup 53 /MVFive put
dup 54 /MVSix put
dup 55 /MVSeven put
dup 56 /MVEight put
dup 57 /MVNine put
dup 58 /MVRightArrow put
dup 59 /Conclusion put
dup 60 /LessOrEqual put
dup 61 /Corresponds put
dup 62 /LargerOrEqual put
dup 63 /Equivalence put
dup 64 /MVAt put
dup 65 /Pickup put
dup 66 /Letter put
dup 67 /CESign put
dup 68 /EurDig put
dup 69 /Lightning put
dup 70 /BOLogo put
dup 71 /BarOver put
dup 72 /Mobilefone put
dup 73 /Industry put
dup 74 /Estatically put
dup 75 /Coffeecup put
dup 76 /Lineload put
dup 77 /BOLogoL put
dup 78 /BOLogoP put
dup 79 /HollowBox put
dup 80 /ArrowOver put
dup 81 /LeftScissors put
dup 82 /CuttingLine put
dup 83 /RightScissors put
dup 84 /Telefon put
dup 85 /ClockLogo put
dup 86 /CheckedBox put
dup 87 /AngleSign put
dup 88 /CrossedBox put
dup 89 /YinYang put
dup 90 /PointingHand put
dup 91 /Divides put
dup 92 /DividesNot put
dup 93 /Congruent put
dup 94 /NotCongruent put
dup 95 /StrikingThrough put
dup 96 /Explosionsafe put
dup 97 /Laserbeam put
dup 98 /WritingHand put
dup 99 /EurHv put
dup 100 /EurCr put
dup 101 /EurTm put
dup 102 /PeaceDove put
dup 103 /barOver put
dup 104 /Biohazard put
dup 105 /Info put
dup 106 /Radioactivity put
dup 107 /EMail put
dup 108 /MVArrowDown put
dup 109 /Mundus put
dup 110 /BSEFree put
dup 111 /Football put
dup 112 /arrowOver put
dup 113 /CutLeft put
dup 114 /CutLine put
dup 115 /CutRight put
dup 116 /fax put
dup 117 /FAX put
dup 118 /Fax put
dup 119 /Wheelchair put
dup 120 /Gentsroom put
dup 121 /Ladiesroom put
dup 122 /EmailCT put
dup 123 /Neutral put
dup 124 /Male put
dup 125 /Hermaphrodite put
dup 126 /Female put
dup 127 /.notdef put
dup 128 /HERMAPHRODITE put
dup 129 /FEMALE put
dup 130 /MALE put
dup 131 /MaleMale put
dup 132 /FemaleFemale put
dup 133 /FemaleMale put
dup 134 /Cross put
dup 135 /CeltCross put
dup 136 /Ankh put
dup 137 /WashCotton put
dup 138 /WashSynthetics put
dup 139 /WashWool put
dup 140 /Heart put
dup 141 /EstimatedSign put
dup 142 /.notdef put
dup 143 /Tumbler put
dup 144 /NoTumbler put
dup 145 /OktoSteel put
dup 146 /HexaSteel put
dup 147 /SquareSteel put
dup 148 /RectSteel put
dup 149 /CircSteel put
dup 150 /FlatSteel put
dup 151 /SquarePipe put
dup 152 /RectPipe put
dup 153 /LSteel put
dup 154 /TTSteel put
dup 155 /CircPipe put
dup 156 /TSteel put
dup 157 /RoundedLSteel put
dup 158 /RoundedTTSteel put
dup 159 /RoundedTSteel put
dup 160 /NoBreakSpace put
dup 161 /Shilling put
dup 162 /Deleatur put
dup 163 /Pfund put
dup 164 /EUR put
dup 165 /Bouquet put
dup 166 /EyesDollar put
dup 167 /Frowny put
dup 168 /NoChemicalCleaning put
dup 169 /Smiley put
dup 170 /CircledA put
dup 171 /CleaningA put
dup 172 /CleaningP put
dup 173 /SoftHyphen put
dup 174 /Bicycle put
dup 175 /ironing put
dup 176 /Ironing put
dup 177 /IRONING put
dup 178 /NoIroning put
dup 179 /MineSign put
dup 180 /RewindToIndex put
dup 181 /RewindToStart put
dup 182 /Rewind put
dup 183 /Forward put
dup 184 /ForwardToEnd put
dup 185 /ForwardToIndex put
dup 186 /MoveUp put
dup 187 /MoveDown put
dup 188 /ToTop put
dup 189 /ToBottom put
dup 190 /CleaningF put
dup 191 /CleaningFF put
dup 192 /Sun put
dup 193 /Moon put
dup 194 /Mercury put
dup 195 /Venus put
dup 196 /Mars put
dup 197 /Jupiter put
dup 198 /Saturn put
dup 199 /Uranus put
dup 200 /Neptune put
dup 201 /Pluto put
dup 202 /Earth put
dup 203 /Bleech put
dup 204 /NoBleech put
dup 205 /ComputerMouse put
dup 206 /SerialInterface put
dup 207 /Keyboard put
dup 208 /SerialPort put
dup 209 /ParallelPort put
dup 210 /Printer put
dup 211 /AtNinetyFive put
dup 212 /ShortNinetyfive put
dup 213 /AtSixty put
dup 214 /ShortSixty put
dup 215 /ShortFifty put
dup 216 /AtForty put
dup 217 /ShortForty put
dup 218 /SpecialForty put
dup 219 /ShortThirty put
dup 220 /HandWash put
dup 221 /NoWash put
dup 222 /Recycling put
dup 223 /PackingWaste put
dup 224 /Aries put
dup 225 /Taurus put
dup 226 /Gemini put
dup 227 /Cancer put
dup 228 /Leo put
dup 229 /Virgo put
dup 230 /Libra put
dup 231 /Scorpio put
dup 232 /Sagittarius put
dup 233 /Capricorn put
dup 234 /Aquarius put
dup 235 /Pisces put
dup 236 /Valve put
dup 237 /Florin put
dup 238 /CleaningPP put
dup 239 /.notdef put
dup 240 /.notdef put
dup 241 /.notdef put
dup 242 /.notdef put
dup 243 /.notdef put
dup 244 /.notdef put
dup 245 /.notdef put
dup 246 /.notdef put
dup 247 /MultiplicationDot put
dup 248 /.notdef put
dup 249 /.notdef put
dup 250 /.notdef put
dup 251 /.notdef put
dup 252 /.notdef put
dup 253 /Bat put
dup 254 /WomanFace put
dup 255 /ManFace put
readonly def
currentdict end
currentfile eexec

D9D66F633B846A989B9974B0179FC6CC445BC1325EB8F274DD24A5D21C05636413EFC0997293
65596A8A52075A624087116520034680FDBD3E86220CBF46C2E82BA32413E26C0AE960BB760B
E98B2E1348D6A21CDB5429260899F7FF77617B00E876499AFB997425D58673778E90672CE2F2
6C816F6EF6C1F6F0724D575749C55AE9D8CD0337709436E75CF2354AFBA7974814727450620B
F79E10457E31E899430F90AC9865F70FE6B6777C3B647DBF5479B987AFBD6DBAEA380CEC4295
0CA19398EFFA54835435C20242F3FB6E2D4D0F33709F3F4688F2B1ABB86C1C7D0C40CBADFF38
59361F0E294F6421F96BE4A820EEC1188E59979880AE63401B5B2BF53AA062505CAEF95F5108
2F2F2C7DBCD0265CC4A4280B9E7BA9AA4A55AA351944E9434319CA45CDF64BBCA106BF20E354
841689809C65F0CCA6D58112721C9987318B070A20DC356D4F494A78CCA77E8F9741854CA51B
991EE73E30821344793FAD6FAB5C17E613D37AB0A7C0CF510787AEB1646AD5123693726318B1
5218F38CA647F26041ABF557285D5CD361A4AF64FBF5F499FE5B2731B7A16C2004F81AE1B8EF
DFF44C5DD939F581257797B71E3758B864AE320361B778A056F6E6B718301ADEF988E22EE226
9B0C66D5F2A30DB1E6E334F4CE1176121A2C97B92C7A5268A9A0758E6319054D3AC99FD708E3
7CF0B527D14F008E9601195A9FBE09F1360A46C727C39DB3105919AD3A07F9AF326F201D889F
C09280108D9E0EF57F31E9F13B923ECEE3E0745ECDCE77D3A875AE2992E5A9205D66E40AE25C
99A02E0F53322EEE450F6DC39A4F03032CCA7A86A195EFAE0619B1DE7B3CC959A0E509B77731
1A0FB57A0FEF4F937EE4E09FCA868ABB2CE5B2C1452868E441D7EB1C04F11CB02A330A640605
88A0A996F6CAE997608D0BD8E69427FAE260AB5109DB945CB48F7485DDD111101559768F94BA
2363F685F0E3A37D5FB6DD000AE67A82A5AC4247BB903890EC88A5EA75D8203FBD0C303E2D60
10F849FEA7875A3357AA421D9A9AECDCE9993C76134B91207D25073BF52A79FEAF2052FA6264
EAD386DBDC4ED545066F685F9C0A123D10C0E083DF82428650B6B927494E7C10DE131D9BF242
96545844ACF672ABAC25B0FEA64574B9220C89DF8C7471DB4A3F51ED013B359983AEF863E73C
CA380EEA4C4CFD43498D6FF77B12E7AB54805DAE7BFD3C6B73BACF8533D1E7D438E4DA6A5BD3
1941F83B9EC65F0D6EC848B39A9449A42AA3E631B7417F21893664D7CB1D86C3E3ADA0DF700B
88E2ABC3D96BFD217C0C7A0C383EB3BBD65759ADE8DEFA9BA34785647755F085A109B4A95B67
E6B1C3E1D081D58DA932B25114B3A8B03CC96E0DDEEE9F0F77531BB982A78052AA1469B0C3DB
E7668FE904DB620B2E22056DCEDFE32EF93DC6F9121AD796BD6DA06D98EB86361E79EC9EC16D
0EA3CBD80483AC0CB08D9B02969B7434A07BBBEB0FE849E292D6FACC9C8ABAA32AAC5E856B1D
04934FA366012E92B9FD039FB6856D6BF23E7F13B08A37027116BBF55D50FEF0A022057FD5D2
3722F039CACA201AB54F407CCC78DF3D0891C2EE4704E54A346B602A97D3DED89695A22AD4E8
2FADAC6C3829D750699B7111B29A7495D35CF2BFE65F758F0FC4FD7907C583B96A002B02D9B0
25971AFD1A1FB7126FFD5DACDE41498CC6B6D44360C283B8EB110F88E341751A56DEDD7DCC6A
692800D666C4FDBDD9B918062791A98E1402F272844DF92CC223081AC112A7F47AC21C3074E0
4673F0EF8B894114258155870C6B9819E5784D1D28C003CAC6E1A8ABE634D07B0846A34AFF6D
B1DBC01B15FE8F820F4B95D398A19EB059B63E14BB90C42718F3A21914CA1B8CED57EF2E021A
33AE937BF29EE41E72FEC6C8DAD27F470EAD9A7C3C73E39B09A2CEC86FBE4964497D00E10107
69DEA626CAD55FA2323B5EC569416F518B0DC2500B65FD2DF26E116198F86DEFB38617AD9055
FA93DCC555683FC32CC6C5A27B18E547B77AB02132B013807D128A5D589E59FD355EA0AEC5C6
81CC2A5A99A72019D29CB8B90DFFA9A75F9DB1BE5FC19F99BC8262CFD1743AFBEE52B1DF86A3
2A0946511956967A70F95F8E6A3D0BF9ED9109DF9670E52D7342ADCE9AE52E2319C67A9EB8EB
3D1F83A57BDA589D6B145B59F1021509A8EEF53ADE388956B987062BB572376351F6B1DA33CE
343060B9CB06F8F917B40598899FC4A5EC21778AC2EDC76E3704D61D0087C364F6A55E29C257
A6D4EBF7A9FDE0E88B8BEDD7198F13F6752484F5C0F7EE7CAACE6C3E98644BEC83CD550F4B8F
B113F2B977937E82330E2B6BF59C5E8809C290ABCA4DF28C2D3457FD047084FB82BD285C7AC9
13CEC83C0AD100077E1A86D1611FD368A80B8890B330388D7AC4D14D30BD7F7634939B3095CD
90E2E2BECA5D5ADBA455ED5BD827608A474321F3E06EAC2C8E770828818A5DA8A1ABC96302B0
4163FC10F78117A329B412F3506D76C9184F8DAEC4D6D7C94519BF60909B6A9717F1F382A4A7
FE015247131332ABDE7A3C89496634420F2C9EEE3E34DE35A5260384AD2E82CB19BBD2D8D3DA
AED2DEE10380BD00115BD0C91229D9BA0A6773C810C5E28B468496DAB3AA53D5C80F7AD7C26B
746AA4752B076F4D900B71A801A757F2BEBBB90424191F62BFB059EE657519EEB66B6944F60A
E921E484AEA8DEFA2A777CCA48DBD7A545A4496B5648EFC9B83208ED1944DEB2BFECD6B74C35
310130182B67ECEB61CF2BF6035B6B1BA4DABFEBA40A81F6CF3DCCDCB3A72541318048B5D922
1003750163EC92DAB727E30AE5C294A013F5E55C15B081B4882D36D3C1FE648ADA07E2E0FF26
6F35E74C00A12AE0169D907B222B56F46E7C027EE8383DFC19464A28E32FB3BFF145BD3C5BCF
37F3BB71B9B9C4573DE9A207101BD4D886E9B501F24B339883232D4E94723566F6B2323849E5
A87386680A1639AA1DF43C36E9E47A0E0292B9121F40E1B1D429F5D06F3DD650AAC0BAD023C7
3A0EED657D7F918A2C4F3E9372D0DA4A90AF1BC975E26F8057F245D8D6A0F5EAF3867D0BA210
FBA1795EE27691642D3CFF8F495DD22F831CD888AF752C2A0DAB509B77E4D40183A77BDC82AD
A7B1A1080D5457A5A01484E70CCA42F8428E27DB4AC8B19F7D80F9AA8145A182554C2D2C5899
5E846DD8CBCB2377EE02BD6E90A9BFF73D99DCF07B2466A7F758FCABEA3D53FC828945B3B081
41DD5CDE73EA18CA486FB79AA12ADD3A675E31F93E95BDB4E1FB57E25F990D5DFF05529F3126
913AEFAAABED377DC4C94194390838D8F47B85D3D37535EB04FD343251EE45A02F97172741DB
7B455E4A937B048E68BD9574385118652EB37C4BE6EB9C86BE7572A32B663AA47E2BDC5A51A6
DA345740A164E01F163796FF39B45C9A287539CF21EAF453A6D82701E2F741645446B182380E
87F7E8D7CA1D0502617D34B4F2297F064E2A7A5111ED7DCD009BB3E3B27A9783B34A9A5F2287
9FB02A02163377D4BEC4E4EB2BEC6BBAC4DF057EB8DD6F84DAB963F521364F46BC12AD061A8C
29E5E5B6E11A492D5C8C157AFC81003076A7F21B8EDFB239B12174D511910769678FC5D92918
B0ABF925EFCD1F8B7C96E51FB2D38426433AAA6D12256F204E4FD877E966E9DFD5B99028D06E
9FC5618E07CFF132FFF20A0B79475F19A7749C1D8D93659EC8BF539500EEBE08519979ED2327
1BC6D0AB99B025944BF6B17546BACAB47B3F9559D1C5B8CDC769D96EEA8A23D62D448455A64E
6CD12944F86D178C9E4081BEFBAE1E8134BC45C5DF200BA1A689EF26C1B6EC925AC28831C657
73065346FD252E9A1165B4AB1076D551F245A26E351FF9035B202D9A03CA4C49221E676C8460
D91C10C38DD6A189304A5B5B03AB5B292D20657A264DF6A2C158E1E27E801178FB42A0061722
4692BDA44E136B80C0FC871955963F6A276B57DC84CB8BD753C51901B28CFB0869D655CC9E8B
51ED82F203B22500DBD21ACEAE6F4E4B0F70D1F24C797592DB1B5DEA54A9D5C1ABFDA080F6D0
DAC72773ABC9DD5B1A5F801F4F68F98E6C388E38A3643744DBFBAADA6F8EF8004BE3DB3F3630
D32BAD8BD807245E06C7BBA772B6EE17CE40D0B29B213BD3BBE527620BFE01B31EE06EDE9D30
AC4108E9FBEA77CF5B1679961C8A158426642FC19CA93C4BC7611C6EE919C344A38BBD9B5A1E
ECE62DA21DD4365D4DCBA931F8199A7D09CDD357275848E492FC69C0A7367B65785174069548
D4BCE4CCABD0F376F4CD57DB1A76166959342604533771E584EEA50F61F4C70215BC1AEEC3BF
45F83594C841CCB144013D992B015F683DBF9857F531FB1DE31442656FB3A07B2D49340879A1
14B70CB407CFD9989435E743447E55573547292891B477B2ED5CD4BBE0C4C5CD7EEF46163146
4ECB612BE116360C50992E77DB14846E07843E4FC7A8FB2D51A0F02E64A11900664ED4E6271B
063EF273ABB9E8BDE81B07A92AD544D20F003966A11E6D882BDA8C26697239C9B13A610E9585
39A4469FAA1F84084C11399D3249877CB6741E06D4CE5E2B8A9D5B58F506812770372AEAA02D
84EEEF54E3D03D542B9E6B2763E75FACDBB249EF27F915FE1CAD98D0EA325F13600996B4FC67
241B96E1709EAB29855FB3D8891C12D7F85FD6ADBB8BC7106DC4C32023C9C4FF6BBD5BA45324
35E97BAC3B8BB13E56252A6D07A1CD6663718F996C6D2DCFD1460581872A38581F9DF1756D39
C28D5D074B935F17E15D1DFB6E3E5386A1250E2BB30BD97C0AFEF95CE0D8617EDB931969D841
4138BA905766ADB2EF24EAB21A4DC9BD08532A0B4097CA7DE4DABDBB839179E52FD2DAFD140B
5D3C78CD7099BA046EE76BCC6BCC3699C6F09A53E0AFFD265AA89C66DE4392DA442669E85242
0A0E4FFF7032B4A0537D0FF9642831755CEA8202C139F3A85D04A2169AB6A7B679DBABC860AE
2FB53410E59E6C7C4ACB20E4BE74C17C1F70B960E35EE076AA53B1FA1539AA48FB347E8A5BED
0AD52A7190D039DCED2E7CC662D8D46B342E531FA9A7BCBB9B829BEDB5E3DD602005302E6F35
49D965C70C6E24DACDFE0D8DCF2F112AAF1F39A4EAB4D57D768391BA8816781E6CF062A5119E
65478BF25B9FC696E17035899FDB03E6F458E3CF418DF3783F0BE8050C1567504AE284314F17
01452A0D966BB56A6BF5BD3FC749F75BA9126182A565BBE7AD895425E4FB33155A1A954A2816
50A7E7A1338FF932F7F89B5EEAE9A7A7D46C067DEFC27FDCB9FF17C611636516C6190C968113
FE3A1E3CBE9FC751F100D53EEF3A30AAD98630A3B2233A129E36F992984FCC31AD035DF36428
819C049F7438C8875A7616E9E6BE43BB667719D9F90D451CBF9A377BE5FCB0B209B0900064C7
8B47D3EBC6896FE4DFBD0B04AD3DAE54AE84E7506CE5AEA452AAB51A8187BE3CE8696DFDD4D7
09D60EC0FD14BA102CFFC84FAC4AF5B21906B6E84803BA6440D124917AF07AC9EE894445B026
98C39F12F68473927F2CC982DF1C20E3F3C55A7DA1826590288397894975F214FE56FEBA3654
759B184B30DA0E9B68D9F905F378D5C3354C175115B046173255D7647E095557E50D15A52A59
F533021E751238BDC88BF5E6DE01C922A1288917CD36CFB0020B11D14D159CF891027C085CB9
9911A1EDDF3CDE3882F1FCDAE565AA6B7D1B13F7189311BBFC820425AE0E1626B9FB2A4967D4
EBBB09D5B5A68959F2515C0D4B2AF2D9428A2F1B3C78BA9C7CE74109B47B0F8F4DF03E92636C
E57F10FD04479236E69BD1E66566EF8DBA0083D059ED0635D5874A310D05A8E2C0A29284FD2C
9A87C13FDD9A90AB0BEFBC8C94F67BFD060EE619151E241E9712E863064B58618ED96693BFBB
8BC3DDFDF791D4CFE20ACEF6C80D3CFAF3A3B26084206BF0D28259D561A5618E5F821A4BFC40
F2CBE964560A508E8551F2BBD1C822B75C8DBB2F8F823913C35EDED08DB8941E040E49D1113B
B72BE24421CDF6F1ABDDBCFC31CB543FF9E4BC8B61D90C52DA56A193303E28A5BE780723DCB5
F254F8844C8E27331C60CA7656E02E33B2765DF15FC2A857CF5B17FAEFCF250DF79F6B10E9C9
D9BB86CA6D47F28C20CEB301864C7B7EA791A503CDE2663C21DD293465366DFA5A63D8B717ED
1A955C45A5A38F6C4481988ADFE2192EDAE99C76052FF4259FCEB7018C183447B9A908E48303
B890AC70E1BB18BF18C3723024E238CFC7901F84534C1F36D962AB72A79F8A9A333A1F83E14D
FB045318A06422E9FAAE87F5A611B12F4F6D3F2030AD85CA8D7674B608C17AB9B7DB8AF11CCF
314E0EDA21AFD261C434D1D4CFB3342148577705C5A4C1957983502722E5ED7A8ED2A9A049F8
D53DE8BBC28B76F522C889AA3F487E69B10B216B0E3277784C70B005F5C3579801427AEF47DD
463DFECD16E95C9143AF926914A47208D46447BE9C27F7DFFCD9CF230F4B05040A5CD62E43EA
089525CECD505DC3A0339E8084EBD882397320A97C72A5BF9D2ED8069FB56456561690DC31D5
F15BBEBFCD0C34A68C983DFF45AEAA6F2F1F278910A7453E18551A1A85DDEFDE5652E3177256
E13555C13167130876C67BAD34ED05CFD8C05DDC3040E38EA59952E17C47C9849D74C89F5DCA
7E09C02280E7BADF3D30C4F550DF4CD8C17FB63356345AE60787DB3E82A3EC16040E2FEF569F
0772BE58D51D69919508B27B8D7541EAD245AFC2DCBA40925D29B393CDF8F544E74AED4F06B3
F1FB4A36D696C96E260E5B9CD86C5661CDBEBB354878990226388B5B6A6A2EE27DFAE3955969
672CB20E5A47B06A63719C44432BD9E9D5E44239A9DCB0FB0BDF53F27C9C6F8057CD28D4A6FB
A2BBDA9562C70BDBA0F91050AD49BEC1A5CCE5CA3AD547C57D93F13BBF6A985AE457D68FADAE
ABFD6606D36EE2A68391A3018A2E8F6AA87BB43284840538344AF2DBB26F0983959098B893C5
B7CB0B28C1F60FDAD193A1B95D699EF96F00595123263BA68D266FC2FEB82AD03AF067006859
50C6D5B2616F121C17A5F7B3DC7C297463807FC36AB88C6566D2A533B249A1B609F6A9259F92
BBE6CD7590A04703A578BB233CBBEFB9D45FE8B6A1A1DB86B1EA300650BD9DA5BA226E00766F
F8297A0D77D48E0FB5E52DB92EAB1055115EAF96E0F926AA6C6A86FAAB794EB825F4A589946B
857291BCDA9B67F78ED3EEC52ACD623215B4AEA886AA235BD2EE046E640BF62620A76D2AEF5B
77C8D2A9292428B9368284113E7C601E30D9C7176FF8786CB1A47577056173E95ED01005A99C
B29E1C24B89E3D4D08CBC96D1621428E11A2DB1EF98102251C04ED1901A4B4F3E62A91C58722
E8EB65F147D6F231B461532F97F182C86D18C6F3B34B25B3DFDD43459EA363D2E0F7DF3CCAF8
520F43E28E50AA8B62B3ECEFB6EF704296C6880D384BD1FD69E18FC6B682CA64DD4BCEAE20A3
B1458EA90D68329D3DF9FC47FD3DC952FE14918EBF2CEF72FB8C82885D9D7F746C19EA7CE084
BCA80055E57D34F8F05A915C6CF2056A346F656EFA4BE98D729A8952BBECF60FAE20E586AAE9
112014850D15B9430AC510F06F904A61C147BE89479342B52F9B04F87CF8EB48C7B43D359898
506F046D4EFABD27F15104C8CF1E8F36D3DF60D6F2439E2D50DCBFF54B2C2EC73F84FD75CB36
F23CBFFB9D6D760F23ABA0D748C87D63BF16402D7B35FC32C14EF6350B2B750591FF42EF52D0
58EC4F285E6642BFDC85D0D45A08D1B6D0A6D3206F8293785364A5FF366351C6D6418504BD59
04959964429C114D1D99ACF4670232F3460ECE20D4504370C33FE3DB1C186C1DEE5D70B8DC26
9808D56A9947DC9406DE88E61C6C7C00426FC00F03BD6BE8FE2C0B3F51EBBCDE009062A007D7
7BFB4DE9BB5FE900921108671AFAE7F42A98B0B8F9B2E5180E4A1DE90BE4203C3F857F777C09
489FE7604FABA742C9E773A808E0F8E3A3D0DAF1685F69A512D05CF9D7D5626874646498BE61
4D4BFA8B7DAA834B7C6DF03B19AC8C2811CF61B3714077BDC967685A5C631D4636B2687B40C5
34EC9FC8E3406BD3E3AB241E4E95C8D8307258A6501B7AB2695ECF4ACCAF71E0FD334A125967
577B5BA02FD3A12856CB4EEF951AD9C98D7AF768B0F4281E8AB9A61F8C3B7F5F2F288CE75AA3
C92351387D984B3A18E67565E94171EB28974A040E1DB06599028BB693F667FDCC3537F882C0
19B8B8539908A53DB215A2D5ADF6881FBD661E9F58610ACA70E8A5E9E4A15ED3A7B0D2CEDD6E
BB45A344A737A9E2FC9A74A40B2812488FC66B1FD9E1F8417201F0D2CDFC196AA5A7F3D4D9C6
E76058C34342A49172F5F6B01E30B2D9F888E236BFFE57E25F990D5DFF05177FDED92F163A1E
75EB80DAE3AF8E18EC31EF128B1F016165577C7459D83199040A45A5AE28FBA7ADD08F53AE4E
74C4627D99EC8949DB62C207FBA7E7D0E5C2967FEF1C45E286DF1904064062052E06A2A7BC2B
C524B03D2859F64AE8D90FA790E604FBA207C56F3D57F8DF7A56CBD85FCDFAFE0A12E4E8DFE8
178A48BBC5F7D228DE1350D0EB529F7C475AAFDA94D684EAC25B95953E493CD5E3519ECB99E2
FEC337E382B5499035343E7B85C9A74D27AF83BD6EC50BFA7ED45DC18252B1FFFF39D78BE6FF
C046E54D440E1A069B00101D63A775DABF73D57FA0A0EDBA5242B11DAA61806F45D473B464A6
9F6C18D083A389BF54C4CD6AED2247D8C7EBBE4E95D93DC4CD67CD16F757A09AE41A11A94FC1
0E3FA15BA5F02BA4C1F8B3B06D23D0541EB077C2F4C648D2916424DBD4BB9B3A6129D5C41BAC
97DE15DE36B9FDAB2AB6C4C1A220C3F16E8C07CC430D70EB7360145EBE67CE45058255E7E7EE
8A8B33F066909F562BD4C26A24DD9E9D6DB63CEECA12BD18993CD0CD54305F9B97870A641087
73BF58BB378428AF52D38F3712183D7A79B103E808A4390150645BBA4978C74C4478983253CC
E19B334BDD7EA54C5BD96E455E9604A3020749339681BEA48FC25DE870C8628E12F73BC1B4BA
5328595B378E6FA5DD4D8B87CFB4AA3EC0A7854CF42CE903A7C4D6C1C00BB29F049A1F0A472A
C0DF4A93524180EB35D7559614B09E521FC8B9CD9158D755DE945A76F345B1EB3B7E87803551
A81E89D3382967877BFA0B901DA6358881730543071E483CB94D285AA81979609BC839A189D2
D28F397A76C5D84907E0F078979843294C55F890EC1805C8B8F9F31D555FC626F571A114B44C
8E88B707256FB5CF70838189B87D7E0FF6D8B4CBFBCB81DE02421E1CE1CD9CD93330952A58CE
5D65D942ED54E36A6FBEA74CBD3F6923766B1A50FDEBB25AC09B1BFC34441F0208BC445CFF2A
4FA545841C4AD1C8B7AC3D810E6A3000E8960EC65DE186A956A1F3AA4F13BB9A921A615C4F12
56B77F4812114470698FF688E55246122723704BED0CC5D76A16E36ECB2D58E88CE48EBB5394
7ABE2229C5C9BB060ECAB6900467619284A5D466865CEE2D7586BEC3AC82A9EB1E201AD6F520
364A51CB8F9D387798ADEEAA193407FA1A15341D0C5C73EE6BE2C63AF4F9322995ECEB67E2B4
10F5C5A738B3CA011F0FDB4F6009F314570BD06F3EF2EDAAE1ACC64E2CB70402AF55133F8E7F
06D46E16796611B51814378539C64A60A9D1E6B72F87E26018CCA0A8FF519EF65C3217180D4B
BDA87156EBC5886D307965D35D6835C252D7973430A250D577CF5DB3D0CBD9D624027C759275
8D2EB863213AC848DEE7EA0A91866201E0876E31330E1D4E23281EA42D7611F477B8A4DB352A
C8E3F00FF0E52147D4B652A8F1A7E2192D6C5A559611DC0A844750892E20B11100E6F5C73284
FFF71FEB834742C36C3B58E74E4B5D28385C4AA0E355673A6A7AB9E8617FC628B9DDB828F6C9
528B9FF55B57B483FFD491AA470D93AC31E7FC99D4848667CE104ACDDC288E9D7FCC7FE4A040
254F3F1E3A6CDFC9E6BBF635DFD836D421B8453B0CA8CC0AD9390B592058557EAFC95CDA6BD7
21F201166F975AC59B9091C7AA4F1C99EEB8731408AD87B7FF86463FE0E0483A873071AEF461
337BC844132057A19D737F9FDD69B4EDAE778965DD3283B0D58BCFB661C39A4ADE272D2101FB
A6430F59E1E153939897702799F7B237DF6FFE385A29283A514800C621FAF5B229590FE0A055
C8AF1CC34898887F02E4EBE1200DFDFCD73F9997ED1E2F0C4F6F35EEFAD3A69CE0AE0177D2B9
9FDBA86E4BF228992270E1039CAE143481310DD420EE0BCDB0BA121D3B83F8F83EA8213B1473
77CA22D9D499FF344D5ACCFEEAC6F575CBB58EE2E9E2B586FE7E5634D99DB727A758A9D84BF6
4A37AABB143E60CF3AF1721FD3653DF4815C7D225023470E66175711C120C60C0675880DF1D8
545651EA776ACE06A333E4C84BFA04443334F2148C1B01879AA669D5662630DE81B12C803BB2
79C686B8AC9BFDDC451C50C76BBEABCCC8B9FFC3056DBBEEA1A5B482EDC690DB077C704779E8
768873D2E9C085BBB0CBF6330E1DD62749B7A4FCF7B73B97647B8A27324A51DC045EA57242A2
F33077E631A05A4E9264267A14BD1C65E87BAD47B8515251D7EBE987B2B8D80273CA0395EBB5
2613433FC8332CB1E5505E7640BB28401CB6FDD27F19E6357811B2E77704E2C3580732B1D8D1
43ED27443265B374C48561F8D7239ABC626AE3FEB4F127D04A56657C8AABD1D7DDBB0193E0C9
EA1448F206113B3C307DDB5482C6926C94E1E54D62049C3E64770BF647400F6F63C2BFA07E35
425AC5056E7AD9D10E45D1B967EBC9D7E87A7685169B1423C497AFDE7FC808FA3E78DB108EF9
3C796E4644E66661673A22927D78FC37793E289C5B8F458D7C17AEA848D531A324F74B89E585
14FE8D57371427E8A4A8617B8C8D0965FE9E558096D1A0A97C99EDB3FADC61C1D16F227A8B47
246B7C4D035E8C248275590AFED0C5C5C2067D22AC910AC15AC8774FEA078CE579801B110C76
FD8095DE5829AA3E47A6A6306C89D289A05C07987DCFAD03F79EEE03CF3D9FA9F3555412D86C
DAC69AC5998A293031B90D1B3ABB12986905718DDD07C6D4A1CF44A4E724A822C7E4B034607A
0CD5C7268685F7C14610247CE9FEDCC2A4597883AD701417EB9BE565358E5A6BB4709533196A
BFC771853ADF4DAB2B6E4B8CD30AC93E8D81487670CDA5AEC17BAAB7BFDEE0CBB19666CD1152
AFE1C9317528BDAAA4F008E900074A5A43DA3D3D83CB2543A191750D5DFD61BA0951BC2300C5
6A6A6F5BBF63C102B5BE69FD0797BE2BC7CA32B455CC69225A63D47759D92D9231A7838B0D35
F5638EFB5EA71CC70890FDD676A2215FF118AC0B70BC2B3794AF5BC45F5818A78D3507ACE3E9
51DCBC6D9D9A5502D0450D1AC2C81C876EDFDAEFF9ECD04952A6D39CFFDBA36AAE6A78CF8B58
7378E85D3F17430C320B080277197F6CC7D6E78D608A912797BE53DD440CA54FCC942D711D98
8762E6585B31D75E1E49EF2033AA18015EF8E9F24CDB3C52B3F3C3ED63F3AD354770491F2539
DECEFDA0BEB8A172EFCB35B69369C888AA8AAED6E5F3D4AF6CA11F63A11974BA206C6ECBC066
4BA1C5D6C0D79F9DB3B4690BDD80D96EDD1689FD3081EF4AC1B0AF8F5D6875A03AAF347F7EF0
5FF3B45C8FD6519A012D18FD7A725BF1B58BC7BC02EFA13B35886E28292A422264BFD47D54B0
2F4E871755911D8F1D26237332ACCE73EED235E98739A00DCE547EA714CCA88E45D065857D8D
A321738EE1BB3ECCAF185B4E3B4EB365C323A47A249436DBFCC9B94708A556AF6E5707B5BACA
634A106EBA69C4F13322078DE4CF1E910BFF3CE416C0E4E045C797568D0252D88E7C3AC9A692
AC185CC61BA6BDFE4D2063FC20CEB298993F4ADB59ADB5A955FFBE9EBF4BDA7649C75A7C8B7A
CFF274C65C259653C198D6159BD3EA35265413B1CB62F5F7AE889347DD8DEA48E055AE8E932F
FA84CABD60AA55CF4475D4369F6D54A98BF08C5D42946DCBCB963C25BEFC016237548AFF7FA2
ABD083F8A63723F7E50B277B3357B1394523A9EC83AD76052FF4259FCEB702B8724DEC869DEE
2E0336DF3CE8134B7893F4235DB7D6E0ABEE493D064B63FD51A746F2DB188607824EB03A8DF6
F8DF0C3F7F289A4F93CC338ECCF3C298D34F3811D5DD72F7C05C79D84B8D4C2CC9457BD6C6CA
A328BF57F4FD48FB20307782D1A0AE125DF60C0CD25675229E42F3A26FB50569D9728470C76C
CE7832CE28E334610A08697705D746ECCDB62A9BA5A84174E7E8B2B3B84C5D1250CD7EEE8556
B8E334E69C67DD237B590C4E1E420FFBA8440C21CA7E5C5D19BCC55C3F1293428958C7D0CB63
55470605C4CD969C006F8EDBEB4D0BAFBBA926AE790A4DD2345E44DF8F5E397156668E495242
4B2EF0633D73C071CE5916DCF5FFF2E6740EA26699112A5D8B881D6854DA34AFCCEB48045113
753D000B13A970722A690F3C5BBD04B89F68C0D37B466C88F6B99071F571D73B4AFD4ADB5445
10EEA4DE3E0C0A69A3310B2E538CFC17AF02B79BADC1CCBE1B179B691DFCBD814E1A2FBBB9E6
12E9552C0EA35E241DAEBDBEA79317E5840172D75B102B6EE7B37D178BD46D18C8EE8433538A
4EDEC7BFA7BB190501E6045018B639B73512A7528A9511DD652656AAE9BFCE6BB612A0E05162
636BC1837C4EBC8FB9FE50103F010702B598B344AC1D2C3E28B6F4DA0D7ABEC3DFFF48AB2ED0
1C6E60F4B88FD73A25CD976143BB165BB2A6CFC10448F9D51EB743792BBE532B8F3933A639C2
D4EDDC0B3B0E942CE3ED72F327E03E0A941B1F5B75DBD7371F86AF807BAE2E7255EFAF6429ED
66B6953E4024BA8342675F1B2AC98EAF239EC8C4C1F3C478B8B4264912189A6A0814093370F8
6B301E78D7FF1F0A3F7FAD7C7778C53B268679E42DF2DC61363543F04DE5B6F6AFA93D107F8F
1FFA825D9B832D1504F4BAE7BC515C90F180E19DB90C3AC9AD11247CC65FB51B7991F85F6DF8
5C7EE72696775B078AED915833E14332239978721D1D6CF8E85B9EC1DA6680EC7324DB7834E3
31612EBA6EC96AAA74B29D798C9934744B08D95FA66FC8D4E31B19BA0AFF641B8C247B775FE7
ECAB5AF5F99509692FC2F59B8EBE03E1147E98CB744ECB89EE5CC4220F3EAC70277B37AD93A1
F0F817CE70F889F2D24C4EF8B38566D6FD1DED9D5E413E95C555EB6D98F0401D2545E906EE7A
AF68C31656BE2F14C2699CCE1CB06363EB36E2893792857DDA589C83C037A882D0A63C5FBF31
4558952B44731D1D6577B7DB66C9F8E68CB3B73B8B5CE6EE63CED9F9461E6F557072EDF02102
8D824095B4D747BC2DBBA4B91FF9242FEBA76B2F81F971857D2C0AB48117E6DFC9B9BD53CDC9
9BA9CE2DA27A36FB840DB0FAD0C346FCB6CB446CB01B406FE7F23A1DFF6AA00DCD8C22EE82BA
D762873DA182659924EFAC2DB1ACFA385D9CAC5756926E49546A5F331F524BBD0D6A8FA4EA7F
87BCEBAAB616249B0358EEE0AC8F06E71C6BC51841B39F02662A04A7A561AAB7A262096F4F4A
BD625E32FDAAE20238084AED79ADDF7FC21D76431E56B1A98CE567A2E6997878FAD2A144F20F
58EB4D66242F798ED249530F3734C2B9D6D662C8E0FFC5DE6294CA411A55F919F116ACED88FE
23E05C921096AB4603FD3CF65430E5E1A7B589FD5F4EECB0A549D66B12533AA895D9E88E5FE0
464CBD79462D69F8EBA108FE694A8C7A1F569D388296B1A11E4AC02ED1F160EEA3A752FBF80C
009DAF11333333630465DF3E58C716D433BF1D6649CA263060FAD46C487C6050DCCE777B796F
AE2A7AE4A18D4463B995CF637997299754328ED1DF343AECC99FEC69C3B0443369DD545C7B58
BFF4AABBE7F7C61D16B1E78D00C640B29C67733784DF1D77158283427E3E3B75618600BFFAE3
E467BEA9472DE1F50256AD6C066FBB8DAB0CFCCBF2D4A8AB99B21C2E9BA2D96F527DFC314D10
675ADBE9C5032A6D6E47EE89AF034A878B89AF97ED02701D576F4B3CDADBCD4F4BF670E3642C
37A8A7BBE0244B800EA15AF8C197BAEFAC52CC9D662D81CEB175A5E341E6E376A63E8A5E787B
6436FDAE1C496B5D0E7CEEBA601F59B76C7E01207F7A9F8D457EE107CD72101559768F94BA23
66748969CA140744DB916CA7E353C01EA15F02B5C2ED9911E90BE4203C3F857F74EA24F0356C
423C3F372669CC58FA7CDA80F08198A333CC1F8CA6DA984031C7D7871042DF8F033EA442CE7C
35FCE0A393D81AAA1A36570539BF9B5C304C417DB613C5A99ED816645017D39C5AF9BADCD32C
16E9F72E32D8F88BAFFC73334EC7AD0F22F667BD4ABBA2ED0D658D24B75F6392A3A215D054AA
F95DC58EE4F87E979B1448804368E12CED705AA4ED29E13929A7470AED91875D7B3CCC40405E
251FCF696156E09412A4F3FE16A68466F9DB07054965BD2204234388B700DF6A79C301E00600
57C2AFAFC5A72F162492D7A528AD3ABBFD79BBC6FBA6C6190AFE9B31BC892A2D0F5D13FD7E28
A71990C9D9D9FAC8B6D13AB7CDB0DF6F0C8741CCA2EF250B929BABA88F67E4E0C5AC68BA8C72
6C4D377CA89ABDEA09F93F32962C2ED05A68DC8F59FC5F48ABD17342BAD862CC3FF0A4FCB3B2
F24AD6B198FCCCFB491ACDD3A0CE0923F74AF76A9BE371DD4E2B05FC03E1EB2D97676ECD014B
AB525B23ECD3251BCB1F9514FF307F5ED154EE1930F911604E7DC4AB924F985E053DAB405116
4BCE931366A231F15F302F3C237B8EBACBB27797C87E1E74DDA3963D32CC05963C2DB30C931C
8D48A35751764A59C345EA07161C85B0A1AD1C557ECF5DE837483702C7F76FF295BFAA794784
EFCEE9C5B0452124182E6029F828A3519A6EA54BAC14429AB8FA9A5FA2251791605ABFC0A841
256CB0CF9F095DE0E25EC07DFF9DB3DE572535D55B1F77C8AA90B5C1C41457BD80F5D49FF29B
A4BA211BC7B1BFE068239B42D9184828CACC6B3344B7BDB637868345AD88ACDA029DFB52E8D6
0EB8F10020DA709A7F6EF0FA583173F1A5FD0D7436B571CADC60696F39D3D8AA70064BAFB367
CE721AA7EE67488DE8EB7C0193F91D9D898C2B0CC38161A01E13666A84DFEBC55976874ABC21
B3CF75DB4154BD53619CA37601FC4FDA8C5FF89A73B433B74131B53AF5533081EA49450EE611
2DECBE6B7565B7E2B7B385E3A56A9143C3BB3C7475E2E6C925C0A2EF6B18B5205B0A4F159FEE
55FF7413164D50A2864C72187FB7CA39EE5A9FA25DB6D86E691B2CA744282B449ADAD23F16B6
5FA01750E469C0750026663246BAFCD57F6E8CFCF833F5D1B00F3C41E627062355DEA21296C0
03E00B24BE094361E45F4DE72FF691A0C4C362C1B358E0D52FFB82E0ECBB685C3E8A27D373A7
7434B4082C301592E82997B71924BC9E7E152BDA1C4D0FC8B4059B7C127FBC67E214582CC75D
9D2B65F3EE7DD6719F42A35539707FA4F66CA2DCADAA19EDD9F2FD6C49F144628D0FDD908984
DA5C10FB83D7B0EB9D3D166C6F7DFF27233420B4015169806BA7F408F14F24D8C0305CCACB07
31E2045B788212D49F1502C4779A99E6CFC7D20E580E88C50D20C11C6929C939F5D441BB12FC
C770E127C526F140E07B2152A31A460BD0CB15DECFBE950D0C420E2AAA2334F1F86AAC14916C
11B1FCA13D1255FA171DC5DA251AC3395F6D9B8AE4FE3EAED0E38C83959389D3BC354052457D
5CEADF5BE5852C9297ECBF2840EC60FA8AF83E7925AD67D929CE8BE7EDD4876C1CE6592D63E3
F8BE1DDE1B223B55DBD514F840BAFC74BB84B4DCF90C5D2D871CB51A2FD28AE7F2FDA0209CD3
44110C60D4261E3AC31D77C40BCE97ECD00EE18896CA20DF47D2DB5FE775A2D9389E20EACCD3
FC8411CA38ECAD31032E960743567DB5D93C74332E50B518D88C8DEA52B51C319F277F0F6B29
A66DAB8E75B5EAB30486971398C4860B8DD56C3F99210CD4D7694F73011CA65CDBB0BC21179E
607297892E09B97FA68501656C3646BE383B662A1199A9A105F5593330C6C3E9DCC4B2D2E9EC
6C05A5950D6035DD2D098FAE930DEF52AE79405374E0CD5F5E6656515C733720B1EBAE20A38D
C804C230E7147BAF66F462F417FC15EE7925A94F0B3F6AEA904F8321B2642830EF891F67385F
BCCA043ECCC630DA0C8D6E8F63E6F6233B0240AFFAD67978846EDFB5B7945CF37E4F6BB7D735
51EE33D21D0D4BCC944CB1A96482C5BADBB8167984E7180277F67A7F1575924B61D95A60D13D
CBB18E462B56FB33B0A7B2C7D22EC26F9B27614667C0EC1E1C4401AD1C2F77D0244DFA9D6E3A
5529F0ED7FBE0218CE148767B0EBFF4AD9F19B4C11078C68529D50E85E570419208EF198CD09
E67E8A5E99AD1BDFBDD171A3100D4D69244E3DBB20CE698DE58F494CA4A0C65C626C8F63E1B2
526AA9F1280CA84AA8CFA58D6D3DB672C3D648BD8B455B33BF56AE6BA11698ABC0E845C74C51
CDAB9DF7BE61B268DC92655C764FC69ED861AA0478A60C9ED91799B6C6494E5E3B14FA0913C5
8A8FEC069C94E05C79B2ED4725EE7312BEB40A63C9B9132CB98A10F43F95EBD8DE19534632AE
FDEC98EAF54EEF0B685A1A37BC801CF106E322CA3BED9120062863081FECFBE294452E62F027
5AEA4719416DC70A63071CC6781A016A285C322FD5B65325496738EA0E3A81267A528D83E88B
A573A3EEA5967FA87130CFB616BD034B5D54DE71A9EA8D54B49C25B53F8B2B7FF822BA1ECC93
39EF823E258A3CA9377CBB0E4A6AD33548F4F4AC1885FF4991FB68F6308772F76681766B6ABB
FC463E66DEE7ED74748A2C6A3A0EB4BB0DB48920C498D274ADC1D97AEC592064A24737E8B343
69B00E31FB47B4F77D7D2415EDF45A328D4D4CEA175C216D9194D985B9E75A108B7931E09D23
A38E7E4BAAB9DE55C8C558396359EF243C4B389CCF9385C473ACDE0D22E618B71F2FD5854ACB
7FE6A677F6927326DB15A5C84087B182ABF207C39015F515AB2AA9B045716DCEC01F7A8030B5
CE3E09203BDC7898180512032B0142A1B0CAFD4ECE7F0AA32BDCE585561EBCF74DD0AA7901FB
1BB6BD5958FD3632E67031147701BD0E40B300B10370B58EEDE5E0EF95870F7797430DC92FFF
E690A0DB97DEFCEBEEED0BAB636582D1037ED7087054D0AF78713A5D180673DF7CB2047563AF
BB8A5E7E066892FF5D332AA7946E74F0CBA0FB490658909F89D820F684EF7D9184EB34EA6183
8AAA3CF07746E38F0F7101AFA03B99677EC701AA0836863119C101FA20327194FAA48BE555CB
0D3B948187FA6D9F5161DC0F6EC1F6EC1C55123380AC9B950A22EE900DAF6BC8B1C86564E63E
4448BD86AA0A74856557E1DC953AD0B43500D187770A7AE88A18479AA7E0A5C8B360F279BADF
79726E56A1A20CB8F3D8D8F8787EA50D3B6AAD11A71A40C3F59BCF1A81DC6CA8F818B1F1A690
DFC241ED1A4649A5E225278BDC2BF003721918C1306BEEC90565CC19538B7EB14228DDDDCFF1
319726BE0D2D4E80FFD5F88B437C5B116A88C9F76AED61D2061595FB27C9B173307F5ED7B7D2
ACEA0EB86C80F99B725DB6500D70B03118BA8013362FCAED3A83D626883D5D0AD260F0960F5F
80E1D346582C2E71C519F1D5EED000DC45CD6405E4C4C27FAA59EF95A43EF0C9C392056FF9D9
97A304ED236E883F186043BFFB58FEADFCD01B16CCCD94411FF757B6CA66656020797B1F8272
EB1EFA0D8B6F671DD13E01433F2F6E8553C3F28A8BA0578E48711390068F3894F98F477CF6F0
C0B28D6A6235824DDCA0EA1A1140B88FBE932F21EE27EFD748D32AAEB6959FE70F199116B6FF
B4B9505BF436D4C4E3FD1923C32789B4A82C3EC54526625C0D467490DF45CA920FAB9B445F3D
228DF0E061AFF8559569A120F9BA4DE67F06D86D18A06B328E7D34D50A5444881CD321E18BF3
DB6EB088B8E6123958E07982CE1016FEA662832F3B270654618B4809472BDCB4B926753A4086
666BE1648717934572F973297DA3667CD5C3C5D5B1BAABA3E7D35B014CB88A09570DE1CA0418
BA701219EF4BFEA144A3E91301863DA4F879FC203D22455AD5C9BF736BD52BF7181F5170D733
522B8F420B3E8832BAA635ED3FD16F73F909FC423F8842045E4CB16FC9F2F9F502FA2A535EBD
682B2A587F38B9FE1091934C9A432181B6DDFEA56902F01F1F338B6E727B0102669CB93FADDD
A277AAC1ADC1FBBD9B432782FCA82EC5A480CB24681C6A11FBDD6DC3242AA3AB00BAB6D6C7EC
714ACD5EC49C15C7D2604BA7F1A81BDE6D8B7D4E3707B0C50DBBB4EC828463E82C5A97FE8C14
61628A47CDC2BB7C916FAA551A9D14FBD23B0F91B297578C0D126005BE94F3D2451706817892
5302712F50B17C1B6BFA790AE66A6A6A8862CB15319F5CB200EBB5886888D4A6C53BA99F7C3B
C78D49B0BA65112121E1DEDF8332019DD303FCBDD935769AE28FE71E70FF869F32BA7A9DB79A
8F145B2E28BF934C55AEE590CFDE3C61BAA41FE74AF024B5924F5370E9C13FF90FF316C8FD16
5A08D321396F2D15F5D60F26FA4BA1D1F4D710AC71210359989D07DDE4824DDF208CACF307FB
3E64718794004DA5B914E04451D7AF50752C6ECD6224F253AE761112BB7D70570F68A171A9A4
FA400DB657814B5A59F951CA8349B2329C5A79F8E4AF748C13ACECAF90F901CEAD1600AE4043
8A816D8742139317F55CA58FAC88DEBB8DA613DE467CD927FFE3A4CE8DF04768CC0D79B0C861
AA14C3AAC6F89947D1A6BC08199D3A049CE03154029AFFF3599EDF0FF20C7EC5A058F8FEDD69
8B3CBE8F262043BEF27BAA5629B83D1377E1D5BCA5FB3BDA4FD01264F8521EDA9C7B34C2DC4F
35968EC4D1F2F52B78117A6F028D2F2BB9AC9A19F16F8540BF37EDB5FD132ED76242A0944C1F
E26C0F59E608B22F89FB374260E9C0D051ECB70648C7683B7056EE108FA15BF3CCDBF199A6D0
C8F1736BA41D0AF9AEBC1568C6597CA0E5D929236579DA5027E391F4172763626364D279792C
59C002037F1270DF4EE0FBE2D6B4C7A6EB8752AE13925BA3CE3C9B31A7E25DDAF8E628904B2D
7A6C057D99203AE0D7870DE54D18F8E1B35243E0D91133955444E4D85F3A4BD566081B934B96
2ABB8A4B29DA65043DB7823F2C72C23DDA35E34A5F25017973B3B0C457341F87363D061F7752
935B0020C4D8A3A8AF8756B3CE61FFA44D53734DB5A265D9F80305E6C1C2C6C69272ADD15D0D
246AB691951ECB2D4493F50CF3D97EC8E5064F323DDB7D4739935BF6BC6F6530665A1FB8BEE8
91E0AD4605D0804BE857E4C2AC635DFFA6A1F30AC69D496D6A2BFCF62D944D69530BD05CF8AA
BB3C25CFC3E853E2FEAA653BBE945886A45A6FAA91966BB1D7123A57DCFA49C7D4D012CB7522
D754A63D9D962E22590E1A2B0D58E24087AACE885BE601576D0BAF830EDFBB2686C9F3521BFD
0A35816A31989BE946E285C4137E63A0BB8C02CDDDFBF07F69AD3EA8991C881EEBFB950ED310
AFC2F285F9BD614A00DE94A651C88887575813F6BA5601CEB6D079BC230FA148FF03C7D9738E
03D9B522C8A9E115001888A628767F68BA44B66A84645FDB3E3E57FC50EDE8D18A56D85B0A9F
1ADA2AADDAD90953700663A8522939021DD6A9C183D8B7162B0D094C001486FDD65F582A032D
11CCC1BC769ADAA5F9BE0832ECB414C741759F68C27CEC7D415054284CCB1F93F83A7F1C70DE
F6A1912E8B162C7FA895DCCBD892930D287613C6DC8A537E8542C599D4E6BF5D1923F4C88C98
9CC922052C9120F1650A7DCC2694BFC83BBC77655DC7D7D558F7AB9A7BA2BD6EDA120F1EAB19
04C5919682F9F0F700D4D23CA5874C98CDA346ABC530566E255934EAE6CE9E3EE742F229D75E
80DC62D5D09F9D65C8EBEAC5155D7C80281E3B8177E3B26361E21F335462BBF534598AEA367A
7DFE0E56F87673BC7F5A2F5C6763A99C67036A34054A48EC8A980FF85A6100CA4FF99A767DEF
5E988114B4AC5E6D7C0296C5A8A11983FBB84B3C2BA8A11EE7DB354DD262531D372AD585BB41
89CF7327D13258747BFF8763B905C9D52884F61F971F8090C682B067F1525DC488C97FA1652B
CCC742F9F64974B71872B02750D7532839A5B51673BB078799F05B4622702D38B2FEE34A0CC2
4B47ED67F6B116ECD19D0A6AC53D66FCA89D54EA09C0E2FCE8E0F8177C1F3D2744834D378E7B
D93C1937541891B78E0C59397E064454C959537D1AC094A756F44EBF3888F1D360284ED768B1
555C02AE1539179C30C6F19B4DAE1DDF8E3AA87DC2DBFE775AC232891444E64D05D8E9A9F4E7
56059222CFD2557B0B365961300BCF710B0CFBD0631AB4466B995F9D4EAA135FC788C24621AE
50E8C4588AA1B9BECEB13B910A70E05A0FF0D0EB3B07946AF750F7C23DB54599D02349ED4F53
70E9C13FF6FFC6847189ABB06EBF7503893B6A8A5234A8AC19BFD79935E1170A82D4C0E326AF
17774B407BC51753BC13308744C19959DF9D1404A07B3861C53395088CEABFB13763F8F21BB2
3D94A669437A95AB5E44EB877C6B7923FA5503B89BD943B49ABF543B80275C16037353E17294
BC39F53DD1E5E7131FED05EA2E6627C292001D9DC3CDC89C2B78B15F5298B12F09026099CC48
872D3BFE41A030BAED3FD782F3830AC1C1678E36286FC74158421FBD8FC4877240EDD935018D
616E4BD936051C204CFC119576153D44ED68415B09CED663F81032CE15CAD67EA78A04C0AAE1
2B7FE5097D2B29AC4BBAC5FA2796D7E0D47D5BF63D569BB7854505E0C3D5BD8197C8D3412328
0D085788D59758523EFB75E80B2B9AC4A9200AC342D2CDD8375C5A2C495AA54827B7980C2FE0
ACB1C1EC7A0E066C40C4A95AA66BE989C603E88DEEDE5648FDD999C0C98E953BFCCE0FA011C3
17A006458A52B68E70DD74F755267C1A511BE72008B91D17C5793A8F9EDA9EEF3DAA6857B6E4
5D2F3754990A158734C9B42B85F9F30813630C7EE7DC33FCED708D5743B7F51A9CE3A62955EB
16FB2CCCAE99060AEFFF5EBFBDB92401BAAED10915DA6C85DF863D18990FF4A7E08165E0ABF2
68CC072F36EF1233EB7091393D83C3FE759DC1E640FCCDF04802832DC1B3F19807196DE87170
ED25CEE324888E649ABA29176BED8343BFD1A0315DA2F56D9E7F408EAF6D4D06CAA2CB08BE10
CF98FB3B9B1E5038238A03A2C9EE8C22C33A15E19E12114C8E8FE8431323A06E499F719764BA
6B0B7115D7881BBA091065FBC2E0A82855FADD44E6AE702FDC9D38069E50AF25908C20527C35
F23BDD8B08C6C303BB305BC1CC69981F59B1EC366F8B78DFE6874F82FFA0929C53DC297AF921
22B8BBB73BDC311023C7FABEEDD30CDA02B312FE3023C924761C3BAF25E1D9A12D92F01DB7AC
7E65D5A5D8C50EA5E5479D074D739CB79C02AB2F3D0394840A2977DBC9C2E8E97934D001A98B
961862493D4B2016968BA0180DDCE3DCAEACAF019F736B0BE1F9B2219E4CA094FE3697A275D6
774305F65C8279C99E1E3BFF38DD8EF9243703293B119400132ED94495BC186E191884A672FB
B9EA2B22A9259D66DF5B720D9378842275701D9CB7C60A2F604A1D4C655A690689B746403316
2E8D6C90DEBCC5B526D259862F4A3B4127C06741F0F4FC65915226B0CAF9C20C967E0E1B4891
C5E110B835849E200925D85FA2343F604CE16307683AFED2AF2CA96F979EBA8A045AA08C3163
707A9CB5899F8E9574FD3185D22CF2EC2C59A3B353A0355AA673AA61555E2FEB9505D1A165AD
90BA1FA4C3229B20D0E829DFB1B4737AD52783C57397B0B684685C56C25FA45DCF79F5DEBE28
11B7B434CDE7436FBE5D67DFAEA2326200992BC331A4199A6B3F2B79F7CE0DD17C418152E3EF
415F3BEE859E8F96380E4B63696553E3B277636C692A13C7F04291A36E254005CAF50EC2701E
F7006D89EE6E8F2B7CDE6D478DB6348134BF9806C157C95BB7879F449AF4DCB9A31EDC40CB04
D6598AC2B59B75C3064E8F923C709485C222D5D0CBB0D260A1CF4E8FE57FF55906A91D4D8BEF
A3A045199BE22D89940BD35AEDF2E6C0AA8CFA76772D207D867FB0ADAF57F8F0EBC94C3EA000
1045D2AE2CE2C040976600A90CEEC67193184B9BFB8EC2F4F9C85E1D9CF390D8ABDE4AB15351
A52529879813080D0D13DF2DE23F57D100A396701AFAB0BEDE0EFC1DE2085C84C59389A92E5A
F8D35C10357563DFE608A32A5A6E74A36F7B82AE7FA98BF36549E7472DE6D0C3953C9493D87F
B4B86971B3C9AA4CC67CE16EC0DAE75E2CBA57AFAEB8C5281EFD4DAAC81D82ACD509EC9D9B0C
972401523CAD42B4456A8AD5F195003FC0D825688E582EEA0839C3B34E196D0DF9C6C4BD03E7
D068B0129E936F6E652E08CAD9DDA97ED89D34D600587548DB7F4AFE5EF8421DADCFCB027E33
DDB73DE66D1B63D9A188961A3A874E91D80F638C0B362405023D64ADE41D9E8C6A1A07713028
DEADC40A08553B2815131D07F15978EBE0EAEA9C7E072DE8670512AE5AA129847D68F124C12A
F90CDCD2C0A726E1A0DF391A275F239201A73B3E223291B5D66138D50D9BCA2508355C508494
4DCAE7D295E4580B8086E61E889DF6E3F8BF8234F87F3EE4357A421575227373F2601DDDF4CC
88CFB52D07AD0EEDCA04283283367F04A12599C052CD7679FFFF591DD63ACCA69F0EA8256B79
6DF56E199E37DA74A6C50A91F3675CE52B33EBF027E12083C53B6ADADC85CA1FCFFEAE493766
95207ED552C2CAF15D3A7485B5CC9A41354E3E67C50BECA070F7B5C328A2B0FAE27B20E1DF3B
871B5EA8D279CDEFD3E5D7C8FE54353CB99A3E1231299B83C7AF7E5980897D9C8EF5A14FADC6
9E260C0FECE2D624A0A5EEF77CA666749428A9B53B3A5D55CA2034552666D3138274F08954E7
B0AD52BB9A048C6B0D2B04AA25A6EF88167AFBB4B4C50FECCDD485E06F8741AE6FBBEDFB49E8
33D073AD34819B1079A785891F37A7CE759189DC1D8EDFBDB7117EBD32D2B3818E7F57E4E6C8
7469A73E5738422C5E45E5D0CD32FD2EC98162A992BB7183E58236D48546FF143AE08B0BE065
C4407665828BF6ECD3D0C45AC7D42782421DF0F56542C4DC59ABD9362DEA776772C8DD9A770A
D2A21749E38FDF735565B9C11CB98612D45CB87E5B0B961DD31146CD675ED32CBAE0717B8189
74CE81701DB657C6F0E8957945A8BE6A436B2205BA174AD92AE1E2215DB07F7726C499CAE6E6
2D9CC3B6717E8B794AB2DB7D033151825CE47BD8C17C2DD82B579429D3A9A54D2224EE09F65D
19371C6BF932A853CFD6842840C0E0EF8F8194122C87D91D4F2ED4B9C1D03E139CCD692C12AF
F1565F066C42233AE426DC5634ECBDF64DD76ECE285B6A3E33925C6182FC4CD1BAB40F772660
BB128893C418531769CBC13C535DC021D04F2FF60F26C00038711418051744E40FB9CFC520AA
943AB67F34B3BC115C63AB37C508D28C0619F5902B6EB87D3A7155DF5DB659FF3AB4FA6EB237
F8ED9453CAEA5AFCFB82FF915C993C27A02B8831DF4BE8804458E1B9EA2FB55C6D17259B2C2F
01F3FE193746993CBFEC4BE9532E4B81BD887AFB83E1F91C07B1944DBCAAE4DAE6BC4962034B
D09F8AE5C4472A154A1337DF0FF5EFAD36B1BC1047C0FB3A68121F42423E41D74F80353E220C
1970E98D0795ED0C7F0B212B8FFF8DB0E5B110DAAA4802F999D739FA1A417DDD28C44B4AE7D5
814555DC6524025F26469B0829268B87420EB20A8A3263C17D6C38CD702EA237BD182780389C
A063416784F5291FAFB50DDA1077DE75F932A39E0CA71EBECB02DFB0FC278B529CE8420E99AF
9652B29DA439460EAE7EC87A86F845522761FF152DADAD834A432112D5497C5AC657A6B5B1BB
55E4436C6564C218E7475F502E1FB2D410C3641AAF700EA1BF56A8FB294F1FB73476024F8769
BD694CF8B5C938D07FC7C59642224CFD31979376A2CB6BB9B7C0B18565C06E5F00652585A2EA
B53160E97AA6CEC2101FC52908537BE9E62E1EA26B8C53ADF57D33E989C7A9F9F3A04DF4431D
B3E8171FA3B36A8F5F4613D3DB39E41F0F171BBEC63B9BF84A4217FAAA6E8E69A5E44A9A2CC8
5FBA31786CEDCB4A97E8227A0BD7526BC9DD6244C586B63AC736D73305BECFF1193844112BFC
E92FC5598792E6234F8AAEB80B90455B0A4947CE3C4A3E1AE64450F82D4582618C683EBF00DA
4601EAD8A92F20F315D8DEAC6E87A56CBA08E365D92A33CFB88ECAA22ED703612FF82FE7C1B9
3BF1A2C1CFF4B2B7A29D6340B8DA142FD05AA4BAAC2CF8894382C7F0BCE8C3014A0B14D9A6F4
4932C7C6B07E517FF86CD53E8CC9DE6B886C80A723D0DC2DA89850D4CCBB9A66DD7E79A78FAB
6832087FF4370D1C25D6362E1367C8954BEDEB5879638250E227FB0865A185AA1B374CFFD453
817EFAC4DD0ED4A128AC3F2F74477AEF90C0AAF406F9599B7FD1E89E6B7DC7DF1BA501BE705D
FA6F9557C3AC09B72D0A48EC241A2E47E2EFD24134B5A2C6FEA57D505BB3E4D84DBBF2B82A25
F5CA0145E5FD6C97073523540498F79D701A95EC05C7FC58D5C57E07C013128737343A568EFF
D43F2984FD681880B3CE799AEAE5DEBF88092622E85536990306E66F595D398A6764E1631E0C
7B6FABA8A748F021AEE4BC9384EC17E2ABF5B2EC4E5F99AB30A9D6AB29A3DEBAE62F17586898
51A9537B144165B5184EA386994A41063DD22C8E7C4E697C9EB6266410101576B49CE7F7FAD1
C4886C497EB09A9630A0060D5C68A3B85239EE1BB8351DC4B9985F1D7F03B112E005DD60B59E
90FD6AD32DFBD45714C8E917678F5E14187B99D5F33DADC3DA2CAA10B25E5ECE5B893BB3031F
5085927EF729138A81C5A1110DF85D2CE6329165A37D833A02D7541ED33D19A1FBA97903329F
E21FDB6F10901854198D7BC2C6F10580BCAA331ECF4E8D26405777B063D89BB95FB7406D1CA9
CE8F8437D0FAD3B909E375B6B3522404493CDFB3565939DADCB84BAB837D5942ED4392DA4426
69E8524ED8BEA29883FD665C1D5A0C5161A856FA413FE1FE755A5BC66CB8F0C26FAAD50681C3
BC280009803847AECCF6EEAC4CAD991C4DA4759C671685B27B986F5426699BF3902A430D06DE
E2F6E49FC5E8E9BFBE93365ECD78CAA269EB216C9790A583BF47431108241413F6AF1471C2B6
87408F072FA391EA14BB378D6A6520CBBD616C55A90B9B3B2437BF1AC05D673A3E044F73C945
8752ED03F10DC3ED3B98F1AC14429AB8FA9A5FA4831384858BB7806DFAD1307E218BD84F6EE8
DA3D2DCA46072ADA1281E4E156FC8A6CB889D9F5D89EBD9C6DB033B5C6294A5A7A85CD6DE238
AEA990B9E080DEF33FA57D400530CA6FAE6E2FD6DD0CA17A05A01B74BF8DF00B2B2C83651122
8BC8D4E9792F2984F03A07428A340F6AD8E6CFB0D2669AB03219CC833B62514D637B75DD67F8
D29B53A4C86B6A0A76858D65B37ACD9BDFC4F08CE28FB4D2EED75A9B198297A28F04702AFC42
1B2977AF4C08DEBA4BEB66B2A2FFB0FFC63B7D9FAF8618E581788F89348C40FA15D92D057536
C812010BC15B234B7F3406401CF6BC41F06633E636578062D7FF567AE1014C14B9FF272B2995
636B1F993002C0BF6E528D29AC8B5786F0FC1A211DA52E3DE9BC44BA15D7DF43605CB4EF2DDB
75D32BE5CD655AB02646E5BA328174017270C087D2FD664E12EF4707F6B104F7201FE02CC9C9
DCBFE53223D065A606586BCF4A0321D2668A389FDAF8C3F8BC572DD635CA720FB9E27446B776
6A44A7EAE4D5968DCD539002B38BBB6BFCD31C9412C0CDF25A65582B08814148286C7B08108C
9C9AB484BE455DD3AE9C2D8ED276BF1DAAEDE320A0520947FED589D8E2B0B0F2D0749B8A7B09
7C7ED6B40D0A37EA01D0370F66DEDE8735D67B5981772524E5BC689F7AD6B6E5A45A1ADB87EA
4E6258D7515D76F88B3EC71D253D6BC650B44FF1625F8400B9F8BBAEDE5727D6936D3584D7AB
06A2D217BA207267952C9F922A4995E08362D7BEEC25BBA53778FEC1E5D796C0E5A79C66BD30
0C0699BD9A3A98C5081C211C5A84D356E626043862AA801A46BCA9E0AE08B888C7C51590BA5F
59BE94B1180A7D046BC603D903A9A9005A710B6626A4A8053EB3F4AF056F01C49A7C7C46900C
1CFD1FC971D5354E0E234FC559DD1F7D856C518B8A51308ADE06F0AE3DDCA1D950E0F674508A
80115348362C617D60BACA5D7D78982BFB50DB38D229A3A43A98760A54723E686217AA5345C3
B278190233A56F28678C0389982174638FACDEA968C0C5DC1CFE5C8CCA320F1449D3E0104C6A
1F7D85EFB01778305A3BA4B31B29DCAC96DFFE3D1D33E62D7A8D23C21F9F2A1DC2A3F15C04A3
AC3456E87DBDFFD00F5310E8F2529AE564B4024A50B6EBCFD32D559BAD27D3C565DBE4EFE721
07B8B4F51EA279EDB6E4BDC356F48941DB7B455E4A937B04884A9D7E54B0FC7626D42E7B655F
A48E92410465C8CFD90388F8F40B30A241B262FD62E6F2390C638DF7E3599F62B0DBFF796A38
A7201CA4B7538AA37748C7B0D1DFA4531606AE86CEF055658FF1D049881EC38D8D1151137A4B
ED2C8552E4AE8DB5AEB55BC09B125387A2A088CEA27EB683B697CA66BAFC85D66870B83344BF
52CC6047885F4105D92502456EEE50FC3859C0CCD704430CEE2B6A2F04DFD365E88B597EC968
0B4E184B4D63283D7AFCA6D3D421FBC3A4CECF893B0D3DA4B73D95730FCC38331F4024DB02F0
BAE607AF61A2B81AE9393CD417FCBD835FBCFCCA999915D0F0999C00BD4D219AD9426E41099B
4FD8BBA2D0DACF9FCE7552546BC4F08E9B7D6BED84CE95E719106E5938C373550CECD7DC3222
2386250C34E7F02DA80BC20660635DC9195EA582B58E3174C930D3ADC75BDBD096BED09D7094
3834FDE138F35203C764F37FC0E0823871776F840A3DEE1524017B7DAC52EDDEC49D048BDE53
86B96D2DE124929876488AFA9B2663C7E3F54B2D213C133F544B9B19FD384E99DA9D0F0E3AC6
2A57532AD89386E1431C515234CB033A2F8CF549F4FF7DCDA5DD9351AE1E9554363E936D9951
B986CABCE9A22203FAF11FD52AC90147BA59B4AF1919C4F3EE314DF3AA56F7A722E180765181
7A2DB79535576E7994B2B411DF837B551650E88928A8CEB44A5D7599570295881043A313A28A
9AB79A8611C66AF48F724023F029A79BD8C3BE83D2AF52E804AE3BA2D3227FF0ADAE13A4C399
DF3849EAADC717918F45BE1AC827F2AC3C30B11F1580B25CB880832D6B01C6C70A9A765A38A9
7757DD38E594993A74BE4EB0759ADDDCDA74B45B1462384D0B6BCA5C770F26B7A25F6D425ADA
C09BF88442BBE185A0827EAC2399494E524F0D07190CA61FA12A5C83C65E538F3BD07E4B294C
55F890EC1805C7600F913F0D679E88B903C39CF6EBC465D8997EB80E9A6AB246096E6317C9BD
700703DA4E0C5427C17AF61001BB45B06AE9DC53FB0C772E23BB365F6A749D3E72C0344B2848
76E8634FA96FB94E96DCCBBD2FC7411B1564CEC8857E0EB5E8A4C5FD5C6820E0001C0A79827D
1322DADA1349ECC4A8D452FA1E31FCDD9145F8BE5CFCCBF7F4DD3F8A94C814BA4F291634FF23
51DB50BD5237C768E5C9CB4067A28D41E87DE334208E67861E4EAFC12788E0E8D8DDA84BFB18
A5133B28BEAF58B3EDA5616A1F688BB226882927FADEFEBD93013666B4D24FEFDA6FA9A62D33
7FCD128A1E550E7638F6F3C221A21FA278F2F90766C641DA3C40E9A84C800C3E3FA705478000
7E7086CD9DE2394EEFAC138D6B8726184CC8215BE14FDB0669B1CDA095D0AD2C18AFC570D4F3
1ADD55FBB5863341D127CEA81A0B48A656001D53AE3CC92C910C69D1FED400C4AB872867CC57
339D70F5C32768E1663315B430D10DFB4C6A07C2C41C8CC9D0EE67B120FE60E25C12E4D40C91
1D3171278F52867F508DD2D9B46E1F8C575EDFCB35856C9BA1A3EA67610579BF3B11B43EA290
DCB4D05EF7E2AC7E520FD74147CE7E1BDC7457501B46C27661897DB89C7E140F2E8F262137D0
14001EDE5EE5AA5BE172DE470E2D0DDD42B08286386D29A7CCEFBA5480281753F44AEF8261BB
77AFE7E3B1612C65D7471AD16F9AEA0731BDFC6BFDBB790AFF547E204FC9EDB69B5B425DB751
096187D91403099A84E7149F8FC3526705D1D9CE9238E8CA1E3718899444E8EC108D66D3D1CC
A735EDA1BC11DFDF4B3D3FDA39E3A26076BCCAAF9CDB4CF93087450FCFE3C9F825B5BD086A6D
B6369F34771B886A186DB61E3F7C12C83035F3BBE3B2E567F630F989B8F24128BD1FCF5715CC
47672C9708443E74DAC687A8F777ED9876B0638AFAE36A4F34A0C80D3E6B8FAE2765FF21395C
95FDDFE5809F5CAF0198D29E2D3106D14EF0367667639BD4CAD05F3C803146A987941A55E79D
768F7838C93E0ABC5414209D36F8110E63DEC9250C603439BB97BDA07BAF5C325FBBD0440F47
51A7913AE324917C5A99F4A3205A1B2342CB183E89A7FA85A0C1AFDEE5FD8490B16CACEBF0D3
676599386A9FDE5675AC245FC1B27E332C596821BA10FC5D51E7E38CD6E53B3C56AAF2060128
084DBED79339A4B72FBB49E256382EAE0A4588234F1FB73476024F876889E0E78AC7C28FD713
683DEC1D522E36804C737A55DD6774C528016706C27D0F1D01566C5DA9D6EB6A1411D70F899C
78384D7235723125FDA65793E41018CC31F3DF56328349E5D72457C2FF639A13E6F3845521A5
542D173D8FE96BDC5D82872E3039A2BB1AEF6105B626EE4FD283018A29DC524D9781A603296B
97945D9285436E5868E7561386776519940ADE6BBE0E4C666D8156FAA3F1F8FB8D1045A65D70
1A73878E10012E33AE07A36150A29954FBEB183B5106346EC0D1CDD71C9463124BF0DEF1E84F
C08D1ECC1603777DCE26D9B11214CE593C8E6A44DDBFD710D940D1DAFA83D894B6576353D601
80C363707230DB1C61ABF43D205C1F16A8AC67B7D0A034352C6BA336ECDB435247CC08127C60
B9B94B028BD6985F1F7E924433BBFCEF8720111B72148F181D95115CBA8F62BA2457E74180D0
99B30191D50286647C426CEFFD8697CF929C6B47AB7BF4AEA9CCF5370C0ECD7D4E1337892D84
3F8D766BFDEEFE751F19938EF201CA563AB21984E03D692B02A2B081EB15042E79C586C60FD8
1D76F901B894CC025B92C319E84AD9437A83DA47193A242EA4B8119A315913F75D48ACC2F5FF
17F77F83D09A97DBBFD885DC2D0895028DE54A8DB2FBD751726395EE3CD4A27F3339AA21EF9F
88A7E5D8476DE8E21381BFCD1765ADE1CF852DD818F081612A47841BE4F565B446E4FE6548D8
7316170A9098CF97B1D35BCD4F6DD29CFE584CA03B94FC2C8CB70E92CEECA4AE5A0759523FDE
143158BACCFB98AD6151A16BCA26C67A5DA5C29A4041749802AE33581C3E03AB9EB217262D54
6FE0D3DA44AFAF9DA7C9F471B5BD3B13A70C47A4A8A8E8ED005858DF876E9100EE3EBCD2B351
F85A6C2FD5FAB52B018842C9900682163EE0EE5E69DA51D0ACA3A16DE648A70C329AF8C12DCF
B0AEF330D9ACB450EBBB41A8A04C104089B9A683BEC46237106F36BB4C09B607DCE819A80994
93FD0DEEF8E09DBE901FF7D9BBE52A5E5F3561FC58B2580B71063A2A27477C20EDF09E069D60
09D24C95184589311303A602C822DACBBB299ED351CDCCFEE79ECB64DEDC9C1F8AA659C6E0E8
049F378F3C254E78313301741E2895CB2CF6F643A8347982CCAD6C3C935E56C071099B46D321
8D187BF26370BDC0FABBC6BC571B41598AEEB4E9769B351319EAB6646345C5A43825AB1881D0
A795E1E1919743A27D8C116513A34511F7F53A49C3CAA8726F87BD427B0CCC77178553099B99
BA29741201F3B326C4F6519E44D48FA6E15B2C40F654FD1BC2080A5A230113328B822EEC5E87
F22F8DBBC12087570F4C43F1F6EF9FF1BB5E3C3D73FFBFB5349067C81CDEF2FDE397B197CD35
DCB34755F069B73264629072F8A0BB728A7EB38EC991B38287D3C313C00950197FCE2CC2C78F
2EB8D61035068905E4D85A98CD8D71BA014F4A3F247B2B9F3BF2E81084EF91EEB3C51C3B43EB
D00AEA4F4084491532ECA79ABCCDE4807040A4BF8087CE19071E22052D3CFB007562FA19D5DE
6AF288178A13A1C701B2B756FADF5D4F908165B18118751FA70A1A40B44AD657AFF9986159FC
48DC9AAEA4F516283279963E5BB537788B0FB120D0FE679EE2E4F1055A0440944A80BB72A570
030B0854D6E51FE8725D36A3BFF6C2FE297E197A9BF5384D5F46F5190B62D35521EC38382AE2
F0727E967738164BB32C4D962E986A6F5FD2746283F41DE04F669B72134B28108931E3CB077A
9C57163565342A55A12A0B8BBADA91542A34D1A9AAC1238FB9A0A8C6E37317517600E68F0738
9718877DA7DC307F048AA0BA116318A2C9CAAAED470B4E2C6096CB66F264FE98BFA9D08818AF
6D9877BA99A9D071DE2C14BC74212F50993676688BB64AC5FB0D88149365CC7FBBDAD907074B
E3AB545CEB92CF226B55FC6872A733E86111253B30F9BEB3FC94D6F15AD12E54530EE269BCAA
2A1C3AB40F805069171856279D43F1DCC86A4F59FD39FDF9ED71D4E4159826AEE4A5C16946FB
92BD749C0713956C10DFB4AC7ED4A60011B8E469E92426B24CA1AA56B0847072709BE2339D6A
FEE843A0E10F842B11A789F605A3EFF61798FDF6B55E5B1B1136492BCC61B86C81431038886D
B3187F017A7E37B526E6324391267AFF41592372A81AD1D3D903CAB30A8B0E34ADA1597B2B23
416192FCC07071276AAE0A4B270E837610E837D8190C1976602E37E796E68D879069CBFF7B24
1EF2276674B6357774CE9FCF90586E279248921E89BA1086696A7A3DC4DBE0E091D35C627A60
8DC348187EF8A36220B1C0189D4B5549908E433264B5C1CF4A6165B8EEBC64A705FA5FA35975
79F551F0450FEB5586C1E23B9C36741A967A96745B3C914F1BB33955864E47099C84B7B50B0F
A54A7F5E9B7AB66EF33570D2DBD0F1A615B010086114F4032A0F1B1A6B9EAC63E04E8EBAC26C
E30D2EA1BA7E3099E77803071B999C18D63A2584192F22618C353FC68A77014365B32A428DB7
27783F825453096C7C0CC05409CB10DCF3C75D3469EACB167C30F75277B66B198D50A571FDE9
707A7F6557EEE167D204062178C1DEFB220D402F3CAFC72EC736B1F738A2E19A6A8D8A8F45D8
1B2C98D6EF4F24BDE0F597D042B0BCF4EA152CFDA8CCC94C03258B8D497FB6630A0A9A58E882
93DD6F2C9E4363FCE0C0FFDAFA872E4B8D1553082AA5EBA3A63AA4A0BA17103663FE29397D8A
DBE7F9506188068ED009D8BE872CBDDE725A0A55CCC89AAEFB5375936B3C2C17A44A31E61DB8
81C640E6245BB3093E36A61F89CC3B9F8084BA3D5CE6BB4F03FB0AF64B7ED5551A31DB9ACDB8
054D62D6FD6E0F9704D08D498AD4B472BF9C0090DFEE19F4CE49B94D9F7543E047ADC295EC4D
1154426B3B041E5F366B15C104868DB82AADD859C163A765AA9CE8154DC2DCCDFC038A7C57F8
847095F17694097660500901B2ABEE4A2AD8BA2F371834BC78F994129C4B8A5F2CEE0A4E74A2
A37A577002E25E625DC47723F76294810A845F7845A9A2364B2A60BE9A34664548F5740EA44C
07ED3ECC2A962FA116DD3011F1C2838DE14670B74414EF69E346208E073825D2B2D0E3D43148
12D7D4666CB5C2F237A08E54F827528B7E3AC0FBE416F87162FEF79DBF84C0F77B08D4232C67
87C733BB67E18C4702F89F660AD379BE346409EF03079F000C55C40F95CECD96CA4A2FB08721
B3C62A8DD2EFD004E118232AAFC5EBD47CCD11CC9414A94BE79E2B216210883E7CFDC94CCC44
A38CDED122DCF832251E792A8B77BBD4BE94C09E9A4DC9649FD66E4A169DA438FDA7772A0451
CFC09AA0E87FBCD800EEF2627BAF1CDEF95725DEEF374F99A6817DF2A6B4F89AFA4FF4D1F25C
A15B852D4371E90FA42E152942C87F4C407AD6AC1AC88E85F681B4F5FD512A8C173AA0FE7F5C
B3DC135B4F6C7EBA389B344B6FA642B5FDC18726321774B03926CD02B5B107A179CB30F3FDE3
7FDB9251217502747D6F4CA1BA8369A5C08991DF483C647F694320E78B30D6A2492FEE740BCF
8F66A7F49862154909D7B175E061250C1270DD055EA707AD51254A10413EB15409AB90833C95
883323AC41535142E2D8F243C7A749160015EF8C439C2C17E860A5399E2AB8808B44F2C8344B
DE76C22106CA436AC2FDBA1EAA240F2F3B866D14E342C4640FDDAD965B67ACE4BBC2FEA7045C
1A755E97F12D702637A4CDCFEAB11CAC835A14B1FA3CAA4D0FA1D49BE98A49D83DE8EEA6091B
2A02C675ECB0DE30DF9C0C338F19C12C3208B9FF934AED63BFA5E4BEFA2ADFBE7119CCFA8BCF
37ADD8ED5D74210BDB4A4C830D02D1662EB0231EA4D0E1F9248E8626F4FC4A03A58DA94773BC
1AA40A67F1A121C9F233D885BD42C0B16697601F5B3E9955BEA37779AFC8C0315E0E0611DD95
0FBB47AFB14105E20EE32AAC945073AA4D1A09421521D4F19858DDC4147495AF1A97FE884BB9
31180FD8692EF2991878E11F380C530D5A2E68723C52BA596C750AE46C5A0F74AF7B6FB67E62
0200B71CA6FD4FC609CADBA91F8B83C1399EEF380D6A462CB0AE690DF71CB5F743C497A77F96
296D1E54B2B1DA2442304FF35306F1D102080576DE783AEB186AEE29EB4E62793A81C42021A0
99AAAD749454CDC4FF74C19B9000724B137D8B969D78CEB155914D39D71C52D4CA90EA65F4E7
4227B5A3280949086F0BBF8A97D7FF0D82F2E1DF153C7BADF93D541651CD027DCA6E8FE7AC73
919061C149431CB8A75DB1D127B4AE7A03730EEB95CC9088C268D21D1C00AB1D460E0BF48BA0
752DFDCA4C0B0CA5195B790C03ADE959A33ADA7ACB572A9832838CF000730B4D290DD15931AE
893172B7D2FF26D911114474A26F7C5BFB146E5B83DB0A34D5D428F95B3CF5B6AF26E79DF063
528FE21A715EBB37367CDB40EB8F8850DC9C081323582401D92F54FF5978C80B8C1D8426FD7C
DDA80F0D105110793A83B7CDC6E6F0B686A9D308ACBE729FB21A2E5388855A4CD1C6BA94A6B4
54A757E028B762D8899CD1C8BBB6BE9969CFE93B482EC1BC35A1ED52C1433629AE2A3E91E6BA
B7470940A6DFD0667DC4F36EA4EFFA4F55C7333504A76E3B85EB9148CA7E3CCF79D867AA5466
D55515BD3C28102B9D7BAFD7D988D566417E5C380A6A1513C8A63C454B12960451CE18735C40
C3E78720D43AF683F003B2FE9462811FB9A9B182D7DB5D24199D0B7A554794AB8468BE8374F7
DB19ECDD2B67091E7B586614A7B50251D861E38FB85AA4E214AE8BD323700B08CD40E04431E5
D5B474C05B5227ECB5FDD036CDCC028EFF7D1019DEF48324D5FD6E41AC58D91823B70CF4F60F
D7588B054C10745249E635772506797E662D049F3C3F8493DB18023AC0DE5449D755C31E3FE7
541B2D4BCEEF470CE7FC72145BB06823F8DE65FFC15685F8CF6A474F40AF8CD7B5695918C2B3
C3A4066B0D763BD0FBE0CF88C4B924F9E3375778A196FE3030CC4EB17C8D7380386790CBD42B
E14200628C46B6E5904B4BB8214EB3237CCFDE7232F8353D4812C856B594654095FA260EA13D
49E65A4F362E977B2433B6BD77628D819C3D257A1338FB6B7CE09E6C48800A48F97D07884C31
535448C20ADF81083A422D5E64E2E417C6B64D77AF31F0C4B2CB886C54715EE09944BA3C1EC5
CE88EF42B148D90CA1F6530A3C9B160D2258D85B5AD42D3183FB057FAC50C2DB9B48D3E8B07F
64393E392FB6E0343A422DE8BC215369A10A6F80A7CB3CB736C8B3E3F3C9E8A41EFDDC5066CF
DE546E924CDF972AB92BC063CB94BEC7EE90420A7BBC8C1DEDC1B91AE57034D3FD6214C37671
EEFA2878E649E3D14A72A9B9B4F8D55D0028BB0FB43F50BFFCFA83638820929018D4C3503CBE
2AC9EB654064F4EC4CC74A4BF4FFA923A7C7C150C410E4EB1A940B0D30B506FB4730D697BC31
97743A5C20DA6A8178F9307498A312E459D9E6C1F207CAA1D795932A7DA89A2148A2ADBA75E7
143885F698CCCD08CFA4CD5D6B2018166F27FBFA72ED765BE31D047A8D4EE1C5DB70F4439D74
5D060E5FBCF5C417FF0E7A075A554F9ABABD4E53EA48B5EF659F1892A834566A4684846EE800
E3DF51EAB2ECF6C2B3FFA59600A2DAE61A400BDCD15EAD4D56631FDE884C10E92B4EACC0DD52
076A34EF8C82D889ABD4A790ABBA49B6BBEB3D840DC3DC3F19590DE247D0279287C63912C45C
282783F672E7876E1F0810E38BFA8A6B1127EB87178FB59AADF5B8373C97DDBFD7445AF58168
EF5F53D70756AFD54C0D40E522F08D536C74893CAFDDCA4E8B4F55AF936438B65260854DC193
28ECF8A0BAC70BF6C015492CCC926877C1FFA68F92008B6D228FEB68807EB09712C6755A1974
BAF5C7A30679179E6324D8C2F03E986A6F7D314F7866646F47A2C95950E6FC555B4D973E2404
0EF7969350EFF54D5A460DD5DE003F173841BDB613EB8D05124D31C251BE6AADC1722AC14066
A7B4D00108E59032E03EE61C774D39E1019378394B0363A39E3919C65E350CBC9D3A107876C1
FB979F2DAB0A126BF167630971BCF336C18D150F64D4A8208D2D6AA855B31480588492F26DBB
D5D40D9CD64B4D9C601240C8ECC6602F5FFA5A474ED0AB1C91184F94CE0BFCFD9180F33BD760
3DBD40F1BD6C17261F201B5741C52BE6D1CB1B2644AE0718BBDC6ABF8646418B9B032CF12BE8
9CA003733016B1857E4DB66CA9AB7408070217320EB45F45C36304659958B248E4775FB12B55
DEA6146132CD5CB78F565EE50CA962692509B9D00DA52EC3A8AB3350F0E5180FD5645BF8CD5A
ECFFF4BF7272D93249441F74E005FABE152FA42B8CB89314E8AE0EB84214EC95BD49B512DE1E
FB3D02FB809967E85BB6A813E993A6C37DD2F25AAD9DC341467C251B6E3C67C95E2D35E33B79
4FD8B0B8476C83C95C862C3C5632412B255DD542E77E5D054E7B2371072FB9419F1207772A59
9020B221A22E0A21E484AEA8DEFA2A75841CA5EB239B06FAC2DE33D3B16A87FDC29F0ED93483
EAB8F5A226B2EA5FDF15CCC34FD7904F4F120BAB746B3E6A119B0E804C6FB704C5EE276D9E9E
059BC450586C228B2C32A270159C138B24FAE94FB157784F88BE9409130861D974DC68D774B7
B50C8CF8E98A4B3C055C0171AF9F74278B24D2C089896EF0D1306DCD64BFA339E9641FBFA46F
BFEA72EDBADB2725A9452350EA6BF9691169DD4E0D4C79A9FAC7B997E60ADA11E53147B8E493
F2744C6E2D6347C851F6EDFE4195337B9AAF2C038287CAF2B8287916551AC63C78F50243D10E
860B2A7FDB9B3BA6BB7ACCA690CF8F45765BB583135736A6B04A4D2B3CFF2DA4E0CE7EBB1E04
776A715DE0C28F93B80DE4B6901ADB6080EF84589D6E94CA1E968A26EFC1A482FEB21466DEA1
115898B04756B0A8B03CC96E0DDEEE9F1BE82281125F38912339C03B46D302CC05A2511004A5
8EFD38E703B079EBC1F2F40E7A9265B6B00F3B8F47A0C3FBEFDDEC26A2B3F1BA8E35244CCC89
04BD6E2F3A0F056F6BE90EB3E92152CC8EFC832FECB305DC0ED2128A163B6C6AE0D98E037D73
E8611CCD5E63C77F43B68C1D6C793E221C99608568D941942E0742E06BDEDDD3D523FE710FF6
1D7619D6CBC86F841A85F608A6760201C1DD75AF90FA65C5A183BB8E206A845472987D0D53F1
F2F97B07E6C7C5BDB28331C56567559F25F6F6C8B0D9FBE4A61DBCCA8BD9EEA14B9312891E60
195986EB4C4BCF7B173BEAFB2B980DA6BB8A6C099D21BC2129C1F9B3E00D753AD1672C447256
F1DBE87B801C0C536C10E9B9F9759428BE1C98A1FBCD39A26EB7BE433B2C7626391171253FF9
809A0D16D399498889D5FE293599728318BA937687787E5541D74046D79210C6AAFAF085C74B
F5243C4E6488D2D3CC1C1912CB27B2BAAD5C3E2533556C61DE80CE004BCF21251629ED7D80BE
920DB85059FC3890E95E2697B66DCBBD752A7AFF46560BB4D462224F084DC24336D4E94BAF98
1B0D52235D0AE9AC83FE03F8B7C62A28EA9AE7ACEC7F6C9254EC615F0BB10FC714EE5588D7D4
AD180F1219189FF5477763D529E31E727C2D8881DDA182EF7330260EAB132BE44229304ADC0A
DBC9F05556B3CB0D87A6D749104E19DC671A6BFDA12BC262DE9C5F66D83F52600FDD9E429488
3286A64F15A02FB730BA0BF4D8B3AFD0A00233866A80538CE8E40D2CA0C3CFC22662B5ACFD96
B49E7B4319BB9553D13F0676DD7CC42BE29E1A6A3570FDDF221181888160B17328722C7C5689
D24FD0B129B0F75014680138364F5F978EE9680C6FA8A1C4B1FB3E24A8FFD267E84B6A2AB75E
CEF89083A8A2017CD7B1C56FBDCE2F3B08AC00FBC82D5A89C351A0CF15F3508F54AF529DB6F1
7A8DE90B5309A859F8807EC36639EA41267577429F81501EDFB156A76CF8D83E028A96EE96E7
D9D7955A1CB8BD32E44764D8E39A24DA3BD1828DE474ABD8738D9E06C124D867B185F4E650D9
31F71F123389F00BC3219BD64858C2A096956149180FECDA811334213D6C5E1617277EFAE758
2FCFDAB158A94E42D4F8B9A296BBDF08D6D5D1680FBD4B50DE70FD4DA5997BE84B885EC54FC9
9DCE01379D91DD8367DFA77EEDDFA6F931F7493F3B42492319B7AC3C2A5DD1A963F1DE2DE9D5
5BB52BDD22F8D3B1C416E8961C39B98317234E5B5498DF3AE34E38523AACC839C631F69F1047
0561B43A4281216915F19E9A5C778740E675AA881CB39CD554B30A78BE0FF1ABCE9F96C7503B
7E343ACD1B94158CB7D5A5C9DD423CEC8F8141940E22C6E4B72CF0F6E9579E3AB7D8E8ACF828
3940B541B098445D767877F9D749B24C73333E512D572BC4112D7661787D42AAE901BAFAD622
FD3E14D8B04BD1BF0FB01E3CADD23E22394791E55DCA8E93AFF7B5C42C1D05326C1932943A56
6CE34FD2BC6E0764F5FBE3E3039D625D5ABAF03D3F2F448BEEDD3B2FE0567E13A22AEC589CD7
CA8BEC99F0C286DAFDDD83E770CDB88DCBCAAA756FC035F28269BFA103E3ED3FE5EFDBFD88DB
CA3DE385CC8366068798EDFBD4D0E9D7C667D778076E09A1FB62F5997CC106EC5AED73472EE1
2E1C9C016AE98B85FEDFF48568C97590E977BC34749E8114270066A398EF7EE2A1F633A27052
C5B452367C8798FDA60559123B2FA6D205C8B9FF9F53C673459D5113F22C8B2C27096FD9F402
B8B9154C51004E0F0F8E404F24AA3BBCCF3E81C930EE60D7295DD369E39972DC166E2FBAB152
299535460CEEFE55E35DD29261EA6D7581008136F2BB8EA6A432261044072450C86326E391D7
D4BDA5D609943921D6A0A304F9E35525F18A0E129744EAF467F23FDBA8AFAF02E8B2CAC186EF
F8FB2CC42BD590EB42945AC8212209020B4B0772AA720C9873C47670844C18AA89A48B0593E3
1B41854E0380F771183B302FF5D6B70C57B4CE84D9977938D3F5D259572F779E3432F2AB09B5
1DD9DB95C76BC1EBD3134DE4654A59EAD52AB64B843562AAD59D35C2B0CA61AABE6665B5B6B8
06C78EC415CBCB994821E9F48540EB81433525AFE101EECF92236C5DC1FCFE41A07421E2A6F1
E5C2ECF5274E85CF3DE8589E0BE2DF633A6022A49014F59CDA17C5ACFC816DFF522864849F8A
3D8F256C3CF3A179E435A4A807DC4F5D3C664DACFF96A583F4CF9625AA2BA786744B004C005A
88BAC9A1F2F90705FDB52B89E1403066B67BB2BB30A9FDA38FBED96E8E0C14C24387747ED954
26ED77BA2C12EC08B1894F6F7433AA64AA0771713EA9E31C819EDD5E21A383C837EE253220A2
79708899CFB0B715338EE282B160C13B3DC74617C810215B541593504F46BABD97CF35B55453
67592920172D81BB98B66BCB2CD401A8F08C7A35473AF9831843CAA5969644761148E5AA76F8
56A3FA16F7A05DCEAF42EBE37FA7B22DCC348EB427355597C21AFAC1F9B683EAAD8D913FFC1C
E67055B0C5E955EFA193B79A7049E919A02E5B9592801CD3A0120CFF6769FE7A6B96409BF6E2
DFBD9E7B6CAAAD86703A94BBA78FF0303885D2D72A8A30801CBE97C756C4CB091CC81E3D7E5E
6F2A47C547611F06F6E6AF8A0703227E64BE243D1EFC6FEFB52082B9AD5157D7839AD8AEE44D
C275D5B7758A43F98F4D44EA336385585B4A1FCF90919D8D5C0D619F6B8D14078E33C18A2C31
0BE2F1628B36008F88F874B4B617882B974AA91821307A85A008EE4AB55F50A7D9A9316D288F
824E8E2A1690BA67E84E503477D2DACD0E4471DABF7B68E7C365D68A64D44F5FBCCF9422570D
19BC8C04D7E1861D98B896FB43D2EE807D9F8FF3EC21B86D5CFB585B61D4C49CEA71ED4E5A27
1FBB0DF1C9B998D02860811F5B889530C646FFADBA716301FF0F9123930839C19C50F91E592E
A279800D8D19B1221773766151F36B081F7ACEA0CE9EC7307C0F43DCEA821A6E1704A98DA2FD
9377D86A3D6F872585016AB4C6E527A59EC837FBD6C523822C880CC77DFBE453641560380AFD
0974E128889B0886748386FBB7EFC9188A782345AC9C6FCE14AEBFA8449231051C9488397B8D
2BC95E7BB5FED4273CE1E4C4F2B321D1550C15C0E42D0510833828E4F935988D2D5EF959830E
699FB764AC4DFD75937FF982A1640CF1EDACAEF995C82653C84C571F3D983B1076B9846B935B
4E8449B2EAFFC3AE71AC8216182051F79538FDEBD04D37CCFFBCB537A04773BA696100A271EA
B20D7C10A20D83A8A2989E699A87F1885D926B9E49B69FEAA1A7C6D75EDA22FED6F4EEDE8F4F
BBE706471725A59A11984816DFF2F1DDD00C5C803D99ECFC825E9053438601E8B20B42F2645A
EAA885305A8FD771BD5E7B92426F0823B7B19F7823D1F42354AD25FE82EB67A3C5A87201A926
C114420D9EBFBE2F454AFD151028D076A92EDFB33A6A36F82F5D1369688E6615F1ED09621693
BB2F53D7D8BB67903DB9A2F5FF31581A59CF3729237A494C70B6520E59FAD9149D018C09A47D
6B28385C06C0FCA6FD7DD5308E8AE42E454159935B447CEE67C8C91B821FDC54E1CA9A53C0A7
E04E498A81E598C9C34E74DDF7A6D70C470194FEC59B67CD1A4452BBE3103459052D4E6D2648
EA6106D797CA374463772BF99FA629377CA544702ED01D010F782482103BFFCA4B5D31ABD54C
07A1DE70D4619611143F1BFCD43CE0E2FD94D78E4670EF86243C7B38C0E7C50608D25BFCF176
56EC13011CDD162542F795F088D3D21A64774A67A7B907B1A25B76EEFBAA2DB358328230DF1D
40E0C0A16ECBB6CDE387C56E1C57ADB5041597A8A5773046E3C550016327E8F59AC36B341827
647C45AE069782EC410FFCD1CED80C3AEF245135018B3AC926CBC5F9D6714F668D00DF24C6BC
4ABC6A32D4EB7181E304F74F8B446B4A178455FC8D86B613F9E6BD8BC45DD34B0DEE179F5579
C5363AC35844017419F06A8F55AB985285EE40B809BF3DDD5C96765B7DC2BF14F6275E3BA918
5677DBA37EB8F3458C768666886FDC09CEE89106EB591578D8AAF93B4ABBA88612EC6A77A2BF
F31650170767013015C04C275ED0E0B43BACF652CC5EBF841921A061489CACE83BD5E999082D
5A0680AE243866CD683D9E28335D685F4E1BB3027D77476B2D1D8C66AD8F994A2B4284BFA3E4
E8207681623036D93CC3ABBE0C599C2B145749A92CF56E2E560E64A5810E2E10A9A9EF8E8675
850BAB7E862AC5977815B21A1A2E339B21A548CDAE4279DB6A7088059FD799D1CA4A8B173A7A
949359D6771CB06073A45BCD3805F88E4BEAA63FD5566D82D3B18B85F3BF3AA0BCA000BA7ED5
82C214153C2A9B9923E3367E0B4FE813711464174499F2E082D0703B547FFF70A5B6DFBFFDC4
CCE58E292AC1667D1E0B7C6F2E53E21E29D6E7B59DA647A3110760F9F9C7880D4B60224C5EAC
AB2A09CB1AF423C253095BA6B6CF6C35A885C785179A52FFED824DC9D89DEF8A89E852469C2D
EA2196AB8C600F8A2AB4759ECDD2C135C77AE6FE0B2C7C93F6C004251E4258B2A995AA848CF3
E5D33B92BD1F1C524F366C4316669AE719898B5C4AC1B1C2247779861BC6712B8A2EDAF6C874
4F6D69D8F9A94D369EFC7C2623793F044AA479EB7B0FA61A9DB30AB3D6E948C1382D400258B9
4944E9C6E4A0CBA7D2FF88D57EAC82CB00636BF6EB34FB035E83214C06C9108E1021571E22DE
B042B949A22560916D57B68A8F78841D5AE1709390E34D3FF7FDAF6571C032B24F6585403193
EDC5920F37985232587B80BC00D2E06C469BAADB38682A1B468B50D4B5E9E7148D4C288F67D3
150B3CA9136843478E804044A8F52C7E63BD66B2BA58E9A69E0CF0A4FFA1AE1495008E9F1BE9
33FC84DE5555FF20993999ECA6C668AFD838B33C7FC2E4C5266E0B87EC04D662D6B0872F7C08
1C696CE08F9021AF44CC90F11BF2D0AC550280E478C0FEAA377F3692915F7AB6833A4A83F4FF
77FECADDE54ED70BA88070A604DE150FF214D6BD4412E86318ED6E0121DD51777016C2C43C6A
0664475C3A9C99FEEBFD25FDF27C636304B5767CD8307163F8674CF36177B01F83764E8970A4
F08300E2F784AF170A2C93C6FD0CA82C965F1461F69AEB5CE7B7C1D1885943C666E678B62EDB
93D71A44AEF63A1F8EC314F3CF56F2140E36165A8DDE978CF3D6CE6E186FB51E43D2D0F8C9EF
022A4CFA2148EC95F4E53FD28E79E0F4357E0F034AB8E5CB8C7CDCD3E33C573050ECD93A2907
FDF42FF8E94833C1125A2A68C948D3B73EFCBF469907709A5F13D986B9CD0A0A895E7F687A55
046857656E763D44460B25F7366B9B45DBC22254735FB57EF05D5B0BB26D5E26E0FBC6CF36CA
A3F421C2AB65286990C367D984DBF0C1B83D812C1A9F2239AD9532DB2EFEE2F1080B65434410
DCEE1B861808824D435F354847647163C896A2521898B505763F98EAD0EBE75D98871DE04FF8
B855495161C07A6B1FFE85F9AE85700C5BCFA303A16DEDAC0BC6F3E70E17683CDBBF9E101CF5
05BE7BA03803982BC58C01B2932892F46F6DDC1A13F5FCDA91A694F6EDC4E982D7417389F1A5
0F94050E640052E72418443C2973C9865E712B95C0A598D05871AD49BD3E138C16D95E6E1D35
B4B3B6D2D172BF37DD46855D26B5E69E880F51CB01A3D38ABF36CAA5E2DC86A6CEB379DDE71B
39B71245254C9DA1186E17311468988272C96618B43D1B4675F3FAE31E0A5060C5351F11A202
5DD891EEC1A33BF1D4926BD165B9C6A43EC34A41AE4065BF33C70CA43845AC54568607F9C3F8
5B3F959772C43E1475CCC9C59CEC68B171973F7389DFBAAF07D24DFB632C0E310522BC4CBC48
A28A80202C9797D8A625FB2296F94B5333CEAE4498FAE0080549476C08CF8E1548FFDDE309B0
9D5350914B662066B3B4CD416390624A622699A5A06C969D4D94C3DFBB18D6D952D02B8126D9
35B660B8DCC4C6B042EDD8A6A00656864124D330EFC22C9945A304DD8DA70430E876C3DCEC87
691F4AAB2694492409CEA6B2046A89887F2CE0708CDFB4E28F2B4347009132D7B7237D7F0A56
6FE53A1385D1C71FE3E35208EB86E370B4FFA5444450D993376688F25298D98205EE5B94557B
0081D6B25F7889624203261DBC6AF677913C39EE870610DA8270A33AFFD871D6632EE38A7531
F13E64F60659A84030D0F304FD7A9EB6B82E583F6662734C4705026E446EE80CC10EFB378FF3
4726E2EBD48940CBBA6079DCA26D425FCCB9229267B56376F6786ADB0A7D5013ACB7779246D7
A428F21DEA5F01A9FE808C803C638FEF34E8998A37AAB646DEFBE49AD07AE8AD5452211D8A5B
E9FEC168C1028F44347CDA0C2EBA0B4E75CEA5FA893F2D0164CB8D29C87DC676F738A6A6BBC3
DD4E4D5B205F3F8C9E18EA80EAC5E76FD0DD46B8B53A519EA51FE9A583AED55504378C5EBE0D
0A5C355F0F78E00B496C469EB1FB18C8C278915D5C8255CA650418724CA3CECFAC0C57716E65
CA76119AE6106306E009F5AB9C8ACE320E852C4C48927DDC414DDF5575C31C0F1D789D290D88
3D6F4277167DA66DBF7254958AC97978A2D134FF147A4DD303C00EC5D27C799DBD0478F3BA03
B7224DAACFB82A258BDED8DF4933267CFCA2B8A60F671B7FD081B0EE5C46BF87FD9A89C16A58
0B6454AC2374DF5A919F3DCFE69E4304415028DE549B8D22738F37BF6D9C8DDEBB1AE5E08FC7
B355236DD1380DAA712D43473A52DF356D8EC47D7E585C6A5C5F7073A703C263499F1A20559B
23B2977EBE44E8D3E93F751DAC945FFDBF3FF26CC17FC2110A6022E828E990542B210EDAE40F
A50A810C205783BFC1F5C469E6C4EA46104F527A14BD6660AC2AB7469B0CE2A0FAF2CC40AF50
68EFA1693153FFDD7364DDD6509E5AACD68569FE82047FF143436ABB9EEEF3ECD419CF41BB45
A1F92E6B9A996403657374807CB77BA426DB9DED924E62A04E8A7F2691F9E02A5AF1091FF954
8BC610168506234F43F2608C295D39ECC5318C66E35F4FCDFCF38548FC0F5A3EE698244C6781
BF1D37338EEAF87CB10155ABCEBF34FB77D107652B5540174FBA034A5C2F05F8AE3E6887BD2D
FE9CA78DA362ACF21414D90E9893AC658A7D833161AE7DB5E15CAAE0A5378F8EC678B0DD41DD
2947752BF558CA030820A7D46381BAAD371D365BEE3A699322709FF72CFADE10A359E137E087
9E858A0A63CC607694EFC8E043EB11C2306EBC9F01E487C4FC9F6B5397416EA0F7705DB2D57C
68C1466507264C6FCCB8EABF2D703BE3823F9E96FC8906FD8C0F448271FB2890CC2E3358EF20
6C4CD913FBEA6E0074A6CB362C5FE101DFBED55168959FEF3F32094C14E699FD3B74DCA9B2B1
93D2EF8CBDE1E97EA56A35F62843A6181B399E2B05AEF2259B47E70BEE8E5EFF156BF958F10C
F982C0773B058A34B31F4FAE6749D4A93293603B169432E0C2480B1D7F8E61EA99F82599763A
58A30888D6BEA13EA4AFF4F8032A501D34E07A1A3A70D52BB3FD5D9D1C8453CDE3B69F1A2AF8
5F5E79869D5E1720E39AF7D07809F5FF59E8E3A208E3176EF939E4A251982AA2921DF33F5FCF
79536F53243B2FEE40A614F83124B2FE61948DDA0DE1EC6113C37722CB636CE8249D6E4D3738
EAA4065E29FFF5A83203D0509CA46E118CBBF31ABF128E9F70AB31E0E36A2248BA66D01BC6AD
511E697DC5156E7D286F754FAA17B1DF8544CD1CC9529B91777A68103DFA164675F6F63DEFBC
63265E2669760CDF38601689BC143B5F8127106E7BB2752CB69D37162CA3AB5A358088A8E146
967A99464814F806B8B03D4657552AD06EFCDDE8CDD168BCFC5BA9F356EC4AE0E69EE9E28420
1C9B35FE46B8F103814E686AA871D013927A68057C4926F78F050DD5F4F54D2A16B8FE7B2535
9E0217299577DD17360DEE8814FC50CBA53E915E0A6A68C695CCF1DA801A3383EB16049F33CA
AC53EDA0F160410EB45449306A12446E57BC06EAD8103CF722C2E5E58E33FA4FF14B06AD6387
C6363C5B4C2237FA09D383749CE7FBFE6EC39350CE057A1A5ED31680BFAE17CE2E112EBCBB57
D1C65C6B2806A4B58E5DDF469197C3637779EEE16974F744494CB2F31C18A2C9EFEC75BE2C19
AE199F922F47C31AEF2103414EF14AA19D6D074191CC3B76117E712D0EAE7E599BE0B7ACD36D
19D5655B7C1F7E540A39B3A4C8D363BC996C5D0352B5373789631320F8730D5D1D9E29E91B72
DF708C54854BF1F049E296D023B9DB67156AD73A876068563A64124A2E89E23AF3B9B8373B92
06EBFCB80260F4DFD722F1006C565887397354140DBDAA3F9E7F7CA7D580E4E1EFF8BB0F6B59
9D5F34C2FA3F89E9A47499FD902C19FEEABC6008EBEC7464E4D51BDAB62DC1111A586B4BCEA5
6149136B1B0E2C73D2B4650BE696DF5A1FAC924F8431E43FF995F78760CF9B7B486561A478DE
2A26D31E24DE580276B832B025327F4A9C1ADC8E27D483D722D23D6D010450E7083FCD348452
4E07B8D49E734F1F40A06AF1B89B0AAE29897D1145AEB38B76D4D4968A3065C7C860F8BAC867
DA441C55ECC6513B82D0E7C8F09E7BAF1BADB00B4906C784D2A400A20916C4D4C7A40BE8ADC4
3180A3CCC52252CB355148D6B3B5451D94A798E55ECA2D2B1B876FF19A5F0478E4FC4AE7F1F1
18C157C16A273A420526F9A0BB461BCC38B0A122064141ADB8934902FFBA6CCA9571E678923F
9F52FDD59BEB79EF6077219593F4E8476D58A0F48A32E31E8BE84941135314135C5861CF9421
79B4559A9F7AA97E79D48B0A3DC50B61E4B390197471575B96C26AD20D1D4D6E7FA69D2A658F
13F154B5DD58480A6F53223A923C154E1B8F0B3EC308C183D43FBFE2A369567535F384FA8375
079F998265BB3C65157F94FAE6CF563FFB36ACFF1AC38A9BF9DCA4F70D850BC148D713064A12
6AAD4E98BEB8F4B338A294C588945E3D4A8835A59A7B7F724EC24C5FF321ED6144B441A073DE
107B849B7FF97FABC0821F812D560D2B96F4956EF3DBC2569C449DAB7F0C832DBA0573342567
995594418CABE02AF2D8980C0400108615DC7A702A14AA0AD3B33A0733441FA62CD779A249C4
245FC351C5409E6D7E6451ED4FBB74773FCF0856EEE30AF1C9FFEC9A0255572ECBBA46D9E020
C17713473E41C5FCE492A8E58931A61B44AD51B63E9014A1180ADAB33C0C7C82FD4DFEFF589D
F1495559388D853AEDD96F45D178BD00509EFCB3AD95BC6FC04672719845D40454870D60F340
478D553276365CD2480B65CFA75BA3A2E420BC437208CB35AE589EB624A8DD290FE1BBB32885
C182303D94E4659CA53CD97E3AA6DADC42702CA1785CA3C9B736D84787F1EBBD40518F53ECC9
E09BBB3FF80AE03A6CAF5C0E00A4A7239160DE0D2B67586CFACD7D811015F2D65C64CEF713FE
A4AE4193FCE2A1D598B361A9860807C07ED5C16B412F67F5B8FD1EE3A78995DD8F90FD096A53
3731EB108555C5D2605BD00A01E1269C136343544981C92D0424884FEC8A2E72CE0D031224B5
D5C0E9FF658038988862569547BF91A135E24F18EA6EAA03A9A01FB9363E0B0A3432744ABC91
C719CB0CC70CAEF49D09B3CE8B460A94492E51D3644E972DA4BBD3EC1844E7C3B40A4FFAC195
03922FFFE16C004FBC1B6BD6139A41DB1CD9EB257B297386F3791AF36CF3C288E1A33ED4241D
FE8191F826777931E7C9E3EED65837E7CCDF7F7F5DFD038149DEA926AB3CB223FEEEEFF58E7E
9AD93BDC035CF6F969896AA6A369A2D3457989B8F48853E61412CA7F2486304EA63F14E058EC
F2D8500337FBC78116E57AE1CBC727C31058E2C4AAD46CEC1531BFD6932E590A58DBDFC3E7D5
907348F8B7C4A58D59442DF9F3B724EAC4FE8FD366A0402A06D20A1756A4C15666AE406221E7
96A381B3E470E1D5466E6F7FF2DF0BCA19F61A3C4DF7A4150283C9176893767C2956DF6F37D0
96DE58DFE337D80D750FE0632A530203D787166942BC0E8BABC1391D823B5EDA42CB9D51067E
0470FB47203BEBC90BB92A632E26FC88A44795F96F916C40A1E92D7263C54FA4C46F0CDF5853
426DCB65BC81745B3FECD395C05C2929FC8361FAB3D6333E0D8798120E01A04F8C692A6B1D80
1987B950E8D916675ADBE9C5032A6D6E3B33852136C14922DB614378D85D3C1F4D14FE466907
C2AF6D31E771D3BC60C2C7733082CF78D209C128860DA9C8A787FAF3C50F7C2666FA7A64AB98
1569B5494394A027572C50F97D9621FC747DE74AC7B205E0074BF12A82A77C7150F85AB92B93
0C8EEEC146CED39961A59E3A72226BD472B7B0493B9CABF84C9A3AC0FFB80FEAF3104B285D7B
E109054EF83C6ED8B0DF9CE2C15A2F49FAEBC3A5D3E8845C31CBF550EE7E64A3E868849B73C9
3C5C82886123F39F88D46CABC18C8675D49B1212DAA0A11CBE84D7563A8E65E4C85415DBE3DE
A07EB032CC51192D07BD8A430B2C24544E82FC40E7B3FE9E56E638D077179770D30102192F8D
EA8EF192EB3EE9024F6FCBAC8416F2578C34490B40A9DD0D797CA2C51905FAE8F6BB03E06056
DF20F43125C81FD4540A5C408CF0F8A76020D4EADBA23D278477E64F2DA9A5D02295837FD68B
6C2ECBE502D1E0973FC1CCC130CBB92EB736E6515A19A8B15ECAB1E274A6A8EB3DE9DA669DE4
0BA15C67BBB55F10B4B6157F826FA54EE9244EFBD50F6233AF0A185FABBD87208CA5FCB04E39
DC1334758DF7F944F48789779DBB8737EAD24450F73A41C13BFAED4E87732A76FC6FCC534836
8699BDDDFAA210876AC47806ABD21A5E838C6457684B5D101D74F2429EC942B2D7FD34FF1433
1E0C277E5FB4CFF9845E5B66A3C88A816F76E479BB22DAABF9B845537FB739FA0335CC6722F8
5A52EBD137837F749CEC87E4813613FA70798E51BB6176340561478D99B38FADA8E554E87C7C
46CE27EF6A021113E360F0301FEE3F2A2DAAA850570BEE59D329E2AE8D1152FE898DA68AD9FD
4FFDE323BE089BA341F7E4E8CE57B0FAD25211BB21DE1878B59696D160F2395DE7FB29B08567
E0B317E23DA80293EBC7107CC6D7F17E13F9475B4515493A19BEC72F2CB9E5A897C4DFC2382C
947CDCBD530F147B3DDB36383DC710C69F2FE1A50ED178ED38E61CC8BAF1194E5CFC58571096
6446BA4C5E5C0043D25DC26606E3D700218874A0FEC28C8DE2A7F4D74BD7D1EEB8100D89C607
634CBC32117F48BFAC97A6D62613A8F1F5948D928A7DF1212BF96599785FCF5FF730B0D39599
2F033A1EA8549E6CEE9A43E24AB9646EE154DD680C9F8ACCC4750027E445656ABCC5E7B9D080
61B4C5B4E0904F2A40DC4317F991B1B1E527BDCEC8FF6CB305160D16FF810546BC3BD4BEAE15
9ED2DF2FE60F3F7FBCDACB1831C95E2B2C2E3C068909E4895D67C0527C00A400FA1544323856
C828E978DCBB06AEFE3043E9BF6F0A2C6F5669276F2FD7D6872AC6DB797A4D030693E5B562C2
076384F710B9EB3F6239F3867298A7830262B0FB49DE7CD48E596EBE33833DA59C228A4142AD
4D0ECA14200A391AA0563AFD5482FFF1E72EA2100309498DC68F9284A4B16441FA2782FB85F0
AC854CDAEE1446AA3DB6FD4BCB1AB8DB9248F326571A08CA63D2995C08A3841D54257B772732
7889EAEDAA4A256FAF45F6C402A67578F5141EC355C714DEFF99A1C98783F19332616C670FF6
440E728220796F752285953347C7A68D9AF35D33FDA8190578746806403818E3DD682136E699
CF449985FC501B1623236D96BC69498EBAF47E2B6C244CB3D6C6CFA82B753B6CA2B21D9C53BD
8A5AA2A6206F3C364403FEA128FC0F1E16F0D8022CE13F50FAFE14E949BD42E6103DAC0ED2A1
6F8EB2CC9D038565C3A110BC2CACA6DC00A7F9B09BA52B0FA68CDCDB3DF6F962FF871E189ADE
46BDDCF9874A8C62D07D30EB17191160DC2296631CF088D05CA1A9A1828EF5890DF922D63F6F
0EA2546712E54AB2672FE7A03016B3904114411EE0BADD1732063AB1E559381877B1D1D365CA
8F3F9A94152548B4F3D00E275C40C660EC7AC5B4B03C11E3202081556E8D829F58C03E1C4C37
CA9FA279CAA3118D3A59B9C5B4040EEE948D65335128CC90531DFAC6F4BFEA31FB3A8628B06E
C4534CC7702000D23C82A603B34399BA5991217FB3443E7DB86C714285B3032E36128F3068DD
3AF6EEED2BF34A0F4CB016AE18B6C6DDE2A84A150082B960AE64E4F047309DD428B16F418E22
196D9357544B153E3706AEBE915CED4FD4400CEA78EB6D91123CE0ACD3631DAB3E2854AAC942
EB1687F066BB0E7057BF585F5C74CD0B287272E0C440BE3BC58D3961805D0F7B285EC0C3EEC3
2C4B25FF932189560107CE15A3D5FB88FCF8C80989E74E953507877CEFE7D09CFF945FDF5671
B5B470A7C849A2C2A0C1F0811BA34298FFA9E1C21F3FA31CE24CA18F53F3B5EEA0932A63B405
C3D9068DE41C76EC9550C27545277FA8812A25C9C2D8FA9ED85F5AA096D6E268D34C93E8E337
990164884525CE2F6E0CE208C4122F94B11D3849D64060BE5F1D0FEC5689F37A40F1DB800FC3
E15170B90B5A911537EE967FA2697F5B9D87FF035792D9431D97554B2062325DBB8E5CEFC2A6
42F74E0C8E4A691521B48260108F39313109EB145F78210477F717C2798ED1FC04CC2CD3408E
8FAF4107A32DA3999EC2948A3FD3BED8FCF17D287E1CD81B86018D99EC8469872B08DA3033E2
18CA2C2FBB4AE3D88A8987084B27F12A63133C4265F6E55C9A5BFC7BC24C482EAA909AA37775
13C0145C6A9360EDFFC6A40465328950569195CE6429FD75400DB0B743F2A1854F2449518ADD
961DF138C779CD6C1BB7ED3C1C331EE4474810BADAC89277D0D29A41E8821F3D362A0D548167
F2B06D2B60A6F1EB672176E40320F059C85C9617885FAFAD1BFC2152CBAF58356DCC90471D24
61ADD634906FBD6E6B1CFBB1A8424D2CDFC4BCD31CAD30DC18CFE9EC68187013BCABD481DEA3
F65EAE7CD9BE66A25AE3B4EE16496DD5F200B568273A63EA0D559C98558E858368CF4FBBD0F7
77AAEC1817951048363C4DD79769E1E51D10D3D19AE653733F3F3B0DCC2C210254A431D65353
56968035D1C298B100A297AACDA32F0C38D81BCCAE6C768F09F85ED2ED7FF6C4FFFFBC326000
962A30C247E6076907BE543D8AB8DC29A9BD88050D786ED1CC4CD0530FB8D71BF9441E65C9A2
AAB2E6ACB4B393382D881F03F72DC700754FF47641B72A9E33E3CD23AA07B5CF61617CA290AB
265EB233C938712C7A396F5CE4E2220624AE3684BEE0E51D2C8C6C0474DF5B8E8EC68F4A1495
C63A831D54C2729014674878F5F518BFD90EC6C9CF462E5C5A9C546730D4E7E0FCD903B1F33A
3C5EB06A25BA9BD2955C79190097AC95B980DC69B491E72B40DCACAACB3FB4404C82753AC125
0F83A21EE9D6AB44BD0503004AE75E1FF4C7E2966CBB96FB6064E67EB5F7D4E4B54E0849138E
538FFB2C3C131B3A911997FA218AA86439BD380FB3B1C50561711AB0B5F4492B142CDAB56E98
6ADFD5DDB8EDF5C118CFB75B6FD9B7F0AF6FF3E07CA9B1C180B5E1E30B4AD0EAD193EB07F2C4
65D649E644405629A4104D8FA515A33CB6953D1B9CB702F735D06B0FDEC3987E9C05D2146674
E0AC92DC8945704AC85D5BEAAD88A3BF1DD6256C5EAF29DA0A049A9DB7E88F9BF6AFD45BDCCD
D866A5D5CCA18F942FA94610B29CD94F6CEE44940063AE1030C5497B85E1C279E75AEAB66C69
4E935E6B4AB96DB70FA4B56DD451E9F97B735DC3307FCE007D741A0F7FD9676FFE6A014D31F3
457C0E6D0CC55A100A21FDC33A842A4FA7EDDFB17FBAB065B12795A559E82C9671D3EA9DC103
EE42806948D5284B192FE43428DA62EC16BAC696286322C8D1B353B57C23914E602249F63537
4E1A8639B4ACE66C4701167D3AD5574A21FD1C01D3F05F97564D834654E806DADFDF8D19A4B8
279F0916BD203D131910756822DBEF3163CA168927B01A34A5CE86DCED477BA224F6EE8F0691
E20FB72902261E42DFCE4EB206D0CC3BDFE3DD4005E173748345A13E9A696A9937EFDB13F1E3
B24A3C0DE16DA81C5667ED7EE8A5F757370D2A50F4F6BD9C6283984142B8295D60F5AA1BC8D2
B77E88C83F5F08198EE8B23CFC5FC700CB3CCAD3550C546044DCAC1B7CA89378E714709481EF
A8A69F3F5918ABB97F5718046CAAD3C12BF570BDB799544DAAACE3E3DFA8047EB7597F2AFAF6
CE57EF332E98FE613BCB4C68B4890E77B8DA61D47B181BE821A43AB37BA69173335A20C14006
20FC594B0DA0ABFD4C7CA3DA7D6CB8DBAB0558322AC2A4A33B09763A5F9C490EFD9B261E1B9B
2F915EAADE65FD94683D7317778E2E0EACDBE38B6EF5EF44BDF6AE31411083AB00D22BBF5FD4
CD45AA348B11EC7ED6913E829858DF493434675D7D2F8452B12D115369F598A5FE5170E92998
1ADB20B89B9A1C3A7FC501949BD8805A9CCC2D36069242321B0E59F8270106FCF47B6977ED87
2D67A9395FE514A1158A9A45850F43114037FE5060FD5F9918CEFE243B4A3C10EA92BDB51506
782DE587E4B9BA604856B37112DF743C52F45EBB93528A46DB006EEA7EA588458FB96D559F73
5F717892960946A31B432E2B8B6D475CBB948CDA82949E7FE7872B3377F264D035167496361B
7093B6241A756571B297D03195C7817BE10928B26952FF5F7CD5D79D64E4658DFFC4CBF0858F
437F4AFA4D70C5DFB2484A73ECD904C7611998A826D6617B845CBCE6CEDB106CB11DB3772BC0
F0823E41F4401184BE841E00FBCDC9CFAFC39AA214817268FA2AACCBA34B9FE0E88BB3C5E39B
8B240268154A590D28B288ECAD25679F8A2A6FE9A4480AFB7E65633F65A7029A64FBDD63B355
884D93990E6530D791CF0942841F4F093E1B54B563882B31B9E21BDBB69E86F8C54C99B4C90A
A65BE64FF736EB246C827E9A307F4B7DE20F163E5CC95C476137C34B3BF28AE1CA41AD678A36
9D59A07B0EEAAB88AFDA2588E56AD09CC22F1FC82252601B4606D7E85C5AA99BD8264BD9B2DE
4F056B463143EAD838EFE7444C41407F00349E50578BA86872BE9D27100D856C47F2EA584A05
C08D55F6384EF9119FF4F9BCD0F6AF415D79E9AA5FD61B7CBB46408157877F77D0FAA856A968
05CD2D5194FA12F1E1B5D2770A18CFE86F665D82403F9DFD3780D155A20E2C8681F36A13F668
20A4357FAD417C6B7BF6CC731553F33914EADCA76AF2F9C5163294DB8389B19B9C5DD717D3B3
3BC532244365805FC3F94DDA55E3B1A0CFF734FE4D2560152446BBF4A8F00B0B2DE0355D9C2B
E969629FF6E20B2C5C1215D2608A424B809B9AEDB43B39395E69FDBC1762591EF2E0CF616CBC
212F49A9C6D5E104F5667B9EB0334AEDBA2FE5CCA4027C6ED236715AA8D100BF1B9ABE1A5DB5
C37A0AE14609D6D88F2C6ADA2306B666B8828DFB1DCF74D6C94C58F67B91180B26C003A60644
D6E616C7C006A90466A3C37DAAF49F96F6B3995C9387904CC8EA2EC3E4F4EDD47ACA75A4513D
6C3271CE8C362D54FECF3B856299BA30857891636D24A55A0821CB7BEF1E490521CE5B7B2C25
C8425CBD059C4CEE6DA179E5A7CD06B86289E1A76F6721731A75713037CFAF7876D1BC9547DE
D77AC1C6CDE2189940F58C891EA35AA9388188F5131A296463F03E582FC2F31D5F15636B3435
CBD69FAA277374DE9F8F783053ADC766ED58DDEF32634881C82C473981CBF79FC83FE4DFB462
E8CD442B2E8886742A805316D8627CCCC7CA7C20D225FB60F56B735EDF570001063A58E13431
F7597F9976240D67F437D4659671441654CA0D42CC71B82CEC5FB73A8AA3A9C3F1E6D8F05CF8
EFBE23942F089DAEB6C315C40B7D97803AFD334B9C05C3FF30D1F9C3EFE3DA090F259141FA1C
32ED84059BDE9198948E5C7ACDB83412028A84AD2EF6CFD087DA9CB9FEB2CF414D944F6FA654
35078C20A13D094056E0C3E99EBAF009A3ABA12B96F1A3E454101E3567E3B9D18ABC163008FE
CEC632DF0FEB89558B12B128114F466EE449A18F95A5C2E8DA1BE10CEB2B81F7025415B7C2F1
31F9100C1CD63533F744903D49100178D8B8BA8998181AC8399C69A424E7837D7853AED50E45
923D432CD87C28DDCA4DD3114EB49F416016B96BF3DB6551B07C334B4B0C4D5F91C2E575EEBE
61308E1EBEF2D7F2BBDB95C91F7490C72A81F2A2A425D4153CFDADB0CFC8D7A724DA03C66B43
75DA0CC44B8E242B90F92CA310D8982483BAEFABE4373C644663F8C745730E46585A9C06BC91
C23109AD6762707EC0BCF7E6505E558836322589434914D95921D0494B96BF93E40749B21E11
0CDE13FE30A24E3D8D228D22AF43EDC315D3FA44869F327E80D6B8F5A9D9498DCA0EE05A5B8B
104F5DAD0F0BDDA2E9AF915F28261EE398F86E455CAC1E9B12F5801B4F09CF40A05A932F1B37
390E9E3DCF415646BC744376F68D193279D2CF13D2D417DE7B3048DAE9AAA8CA8C4D7DCB85FE
064BDD5439F0FA1D2BF13DE184C7A12B970B2112E0865D412C52C0B33887FF280950737AB861
78E4130832F04C773C90E3518D66A6A532C4DB224F9C2F1D2A636144D749E4BE8E86EDC4D80B
2506C71FD74534CFBDB8C819912AEA3C00E47CC14EA7079D87F9E8F43AC299AD6B0E69A89ABF
4861A43130A7A742B7411B9022514D455E5031D0D2EFB23C85541AB3BE19C6C00A100B682BD4
96C39E12389F8DD70F7B87BDF5750FADE47E35C91D551B6D1245CF0585DE3121B2A3323FCE6C
83D2A178AA2F3783764B694C6B9AA7B8E6CF550A84BD583E75CF28E09FA8B694414BAAD66012
5573844BB136BEAF29D5AEF56BD96D2B1D675EE6C3261B6CE34E0BA7B912EAFAA7DD3A76C04B
D7C0097BD51A94539EBF664EA61CAEC333DBE69EB375E89FD5CC95E96B341A6611B2A5CE885D
44BEB9BAF71130EDEC451ED51D44D762DE54D240FBFCF98A47D4B486AFBAB4A8A59152055D33
92306F4B23C10A9157D0D036C94A8AAF2D91FB91F4B70315D66AC35A69BF4596BDD9154831F3
BB8A5ACC16C26F6C3671F8C909F9EC9859B5659772032D7C3679A86466296196F462CDC29037
175836BC0E2F876D2868DEAAB466D43F5E41A7F5869AD66DD0756698FB5A1BAD9EE951EFCC54
3FBAEBE37E3540C750C8A150C29039C7F9C0D757FDDC567234D971025BBAB89697A40151A2C1
79CA110DAC27F4AE17C8C1FEA5112BEDC6B3642BD2F758EC5F4440EEB76A0D828FA5E4294A23
533420FCC369A7C7A03056E2AC48C3FDC595B50F1039199E09DDDA55AB114FE2948B68ABCE3E
731978B6E6CB85C744A7326CB0220F29E485F28961867FBA467402F9B3A25E90FC50042494B3
8BEA1F3E72E23F9B91A500D7FD1DC9CC5090FED580755415F5AB0B6D48DC1F7919C592914262
F3563A4644724751691300BE7072AE55D7087A4E21D2A5ADA7A873C3D6EFC1EDD2F58D1A8169
68C9DF4B1BE9AEF1D028AD3E93B84B3BCF59FA36FECBDDDA7764D65915D4B2DCF1CCC388BD36
584E40A7FC6744473094BFDA97CD804618C56E9372FF20C544A51CC7AD10CA8991441B1874AD
A277D51ECF2FB7695CD3DEBC72ABF165F39A187EFB9453FE61BB60EDD246A08B89AD25CC7961
54E96009D21110B9B2AF271EE17E23D7E0EE5AEE0227C0447123244139A5B604E436536A0A16
25B67A4E05BA2F6D3BE931883C2841864850C4F17DE6AE74A73A7F80EF82E55C7DED997EF3AE
AFAB7B985283001BCAA2DF80514AF8992E17F09C6C2F26144326F527AB16E745B05B3246CA47
DCA1E195A4C8195CEE63BBF43E769E5B912D79F60A27857A2774CF16174B0DD47241A613CD0F
C2F1A4533535EBC71F13C1915E9703FDB60B1AC435F83BE1EFE89968743A261A42440079049D
C0B797CBC231DFD40B39C8346AA2DFFAA64B87270184BA1F08FFCEF2B16F751C8409E437A28F
5DAC4119E6FE5F19E03689D7EA394411BE8C41FC0C163DD380EBED006C95BAC420000F8C4C21
07170534BF5C3D60A1865A9304AD379DB44AECC299F4C5D1A4949480B126B197C8FFEB3F0B86
D253D8437F34FC345663CFFB7076DD491E86CB435B47B97FA90FB2AB9C41EF1BCAA3BBA9CB9F
C41ABB75B482D2988CBD59DFBD74AB4FC2F4737A18D6229F20CDB8C260883B6A402562C87D3F
EC66C6BA5549864188B2E8E6E3131DEB1750C8ECF6075CBB0DDD8D521D8774529A0B6E287D18
DEB611441DBC85B5386F673603B0D4A89E08B4204F1FA1A37C71F5EFEC2E690B95277091C297
F4E750BCE4CE7F803F205FC075845189204123C12952859AA37FC605B07BE8C3FFD23900EF2E
1631D249CC33475AFEFB18793D3C3E6F73C959E36536D7014B5DB73640E5B662944B7AD57D0D
CAEB856CCAC4A6998C6646B32D9633E5FC3C662186735BB9E45AE57633A32A53B7D1390D172F
2855349E3844FD760F6E9063E44F70C5EF8CF62A8F6EECAD9867D8859B259C3A5B85A6DF16C4
154DE6B620711CEB13C6452D9AFC5068E643F5D81603EAFE566A675D8F113B39D9D970096422
CD811BF545E8816B7447A4FD67AACEF1D7B43EB525CA898502839B021F96D3713B551EA61A29
6E4243D0A64CFF701E4164810D79ED0BD3E5B3E54A18BE97CD40C6ECC03602251C98BAA8E6DE
AEB914919A1C354095FB3222EDCA50C33C8CB3F14CEFEA5603BA77C0FF2EF6168D3A439A38A6
F8623AAF670711928A5E0C18CCDCF405F6F4A9239FCE98F9A12D8242DB2BAC449301DEA8D9F1
153B9FEB663E39FFFD2325D8B1E3A8391A0C59CF26D5EA3195EA282FB204FEE37D28A0111607
3D523B0027944B383281DEBCB5B0185274CC84BA6A2EEF1A9B31F74EBF79B74A31C5370D2777
F54590D3FA901026AE6D6985866B0B8D77BCE84707DFDD48464C099867B494B9B91B3FBAC06E
01956387D3B42436CE1439A7499E57C0E9E9142F5A89543B9A551382F3F8CAB84C773EBE0BC3
F9682F0DD5FA667C0B895ED4718D857ACB30D2CB7C265BE72E20AE6F99BF049FCD82402C1000
72C46F2A1495637B217CEFDE84D0B8A1AD1BE74714DDCE8974FD7E0F9A2988BE12B0DA753396
707B7124BD2054FCF7F2379C72DAA875D89433C4CF3EDF52E89C40789308894001D9179D5282
0D1F234660F4EE450577ABBB0686698450F2FCB375E78886813B6F0B03DC6D8CBD7D1941BA9F
CFB587920C0ED24F088702FB6DE921949F85E70FB39CFEE6159DE6EEE0DB54D235AE9BBAB5FC
E3CA601D6F7992DC1D4FC9381B014D7AC6F0A7A31B3347F0E7FF21B8439009D2A73F13BB91BD
78CA7BCBF5104E309AEFE6E577C29F5A2DE16DBC67B0D606462F61F5B8744275D2D89C676723
871FD0A14F06B2ECD375717C321A24BFB3504D7DE49C7428F4BD96189D78024D8C64078DDD5E
B5CEE0CFD3B3E26C1E3C11C38BFE552656571778952B6B3AB329236C5EB183DD269D6098672C
E6CE2DA3B74DB0CE3AE6C9E8AF85781BB8A15E2DB7BB6CFDB7E00AD1B7461DE8CAEF52948208
E43BB743004D01B701D3F614FBD3DF4F10EED641D042F6A4BB521C1E5583BEA04B0FC732DA34
FA188A41582587D85EF1733C150565B307CC155B6FDA180F80FCEFBB2A1247BDF80EA8A06EFE
1BD4311C5E5C5434675E8776D24EA0CC087093A1A6AD96E7F72D6E9C2A732BD3A80DD0902F2D
3297A9FD977C15F41B63B7C2D3AD26C1FE377FAFABE925A30D8A389C5817429B422446CAF820
DD504A07F28EFD6003B1B10B22D0E73570D21FC01950BBBC8321A4676B4432B34A196BF84216
1E4A17A48DAA36967A5CE44F1C347666B8F12E099E270B8939F43AFEEA152ADE1FC12D31EBA9
1492F1EF2CB34F7905EFF6B398D7DF1ED2D819A2D22A62F76B172207A9DEF61F15ECB229D253
3A89CF993F3A9CD7E292639FBE3E7E541241E67708281268F5575F9BE043234AB4BCD991E0BD
E8CDB0227CAC57916B0B3AC5EA9CBBA74C68005DC1942CEB1176AC3BF023C50475C508035AE2
427E9B2B446FD101B51E84D1A5463DD90267066D42CAB6109D01E65BF6DB4B49622C92385618
9E34E765254480B54C32C61753BA7A9E1ED319CCC627CADE7E97DA7F1796A58A758A7C572B75
2E71FEB0252BEEBFC6D1155C442B7E1CA37C10297B8F262D23B689417653162162206338F484
7CD4307C5B8E1F9A7D367BD5EB54C89922AF8597D592F9453E5EB48B24ADFC4C5B5ADEEA0C90
DB99CD076AB89128503B1714294580D0264E1E533C37E198C07EEF074ADBC3F507FD632E16FA
A7F0D016C6F087E823043D681C85FDD830D3683002E815FB5E40F0EE42774A89E2CFD4842C6D
41FB0EB994397501A17E8409A769A25E8A462674395DA66309643EB6F07D07FF7BB11F0FD62B
304B82D09B05E9E5AFD9CF02F01AA2E04DF791FA03BA04C3616D6BD471A7296113D423170B8A
18DC8ECFC40C089CA302F25946566C83FEC8F49FDF599F2E3B6B859F6D000338401814DE4065
8463BFDDD682694824A951101C250D9714E174114A23788DA13532397FEC10DE0FF03FC4345C
E7A7FF78246A6F187077448D7E4E333EDB53D7C9D288C414CE4F2D8D3D008610130295B6B0BE
49DA5D29E7551B23E2DDD836FB25487277308866BEF4FD7F1A128BDE694A001FFF75A364491F
A2160783193ABBD81D97685E2993F52648E558802C5E8D4F19CAEDDD609EF00C46E97833CC01
AB744384F2E841EE3E148D5E45F7C79D94C52E90FD1864F3FA2AD83356833AD63F7D8D6D966E
6F560B1582F2F738E1F4EC5505277FEA66763A74A6ECCD0A715A3BD4BCA7322D8C881C10A0E9
82F2BCE37A85267C87338E4DB13F661BA40C6C2AF3D8CE5E06756B8DFDCD29E301228B2F832A
912C03CBCB982ED5500D0E9CDC74A54D0A20A7336D3E933CEB60E02599B1C37F5D5FBF662943
2416B155B0ADC49544D94EFF37B8459A551AEECCA86D3B79BF43CE2A746925EE5785AF6FC1CE
652F17EAEA9963DCFD2C3F180405AB6E67AABA18C6B4E403CFDE8FDF6CBD19DDB85A64F0134E
F7DD7C602E8E29EC7A8CA8CE903676FF3599CBB0F420650456939E70ABBBDC26DF851D1B7D8A
8B4B7C6C86E0313376AF2B31B666D9F677F7B300E7E46D3DF99FF5F53D3454908C85C65F9DC8
8DB2649E22B6942AFF2344CBD77E01BA2896227D6D2FA37DDF0598E5BE5AE0D9F8950221CECC
D6423BC89D574A337672B6FC87D28D45206FDB7AC2E163A83653876B9BCF0D54C78D99DDEE8A
8F9FDDD0C53B1F016B230F80CE6EBC1CF99E0AAF60D949E704FC671F5D821100E5DDAE885254
82AC0705439CB09016708C5238AB91EC4799F0D341B64CCB93F40501F3F8316771A02710BB20
315C589FC727744EAC6936FD15A213C6363BE1C465C664B3911AF7D5AD30A60A2C04819CC12D
45C6E787691573EB70844262A08413B6415159F308EEF463AE8C55F6E979BEC68FD5A9C217FF
6A8801C0282B413D2BD104B323DEF0BFAECF4A715F038B908BADFD743DF4669BAC93340795BF
69E8F4D1D393AB5ABB04150E5BC1EED45EC8124982AC6D1D74BAB2B8DF9204F19F20258BBC6A
06CD20DF29EB1C33B3285CB5F6566613FCC22A426BC41DECDC6B5032FFE5CE3B4BDBBFA8763A
D4535C24EB5806D64C6E4ABBAFC09F1D9CF19146618C6D49EE65261F7C5ED494F552F441C5D8
C39476BCE99708E6AEA2F71BB883C6B4F1C09AD26C60541F602E7B0CC6506887B6D75EC5D51F
C38BAF00EB79941F4F8268AF237671090EE873670DDDD10534B3B31A9293F5E4E86DAE3806D9
46CB1B10369200B5656B5BDA2FBB62E864FA87BA8732B342887EC0CF0A8FF5AE3DB60AFF07E9
21BC49B64E999722083CD2C9FFAD5E30BA05FC58448595F25D39AF9D69B17EC1E1CE16227A4E
C6182E8C183AB02C78A4A5F40C17DE9A2AB5B47A9CD9F6B7103B1D4A25DA62B8E661BA2EB175
21F05F145D0703F782ADD231C17A7CE41A892F5BE4D83C9C22CA94DA82837F2609FFA095D1F0
51E089ADB4C6BAF06FD7FFE3683C85864945E1C58DFFBA9D88A34FB5DC5FF69AA35DFE1786A1
FDB7FA9BD8FB40144A06E9779B4A054A90CFEA6CBF556F7776B932F5FF08713FBB6AE2FE2C9B
92279B163E8EF63C18083C2419293A7E3C68EFF31B5128B04B9F385B1C3F57A7DECF8D59EA10
02D6323675E6AB6DDC613CD847532485822ED5477A752AE65BCC55B44B3903C14A2E3727743E
8EADC755B3129C9331CE58E8ABFC162096A7719209AD32A6E0DEC0605DEB4C204396A0047A33
DB5B9D4EAA587B7984F2EE227ACBF51BDEEE37A68B5AD481726568564C168DA01A83A397FD0E
53CA466BE03EE18AEB11CA037A8DB3AD50F73D0E7DC9A43C456FCB4350CBC374AF174C02757D
B667CA0BF4E42C57F719F46A0E1C43F9654A85F88C7C5EA5CBABF1356AE8996119DBD82B979C
93C75A549327CD4E71804B99E22F788399D9178054A935E6BA107C07079D106EB4931599100B
2AF87BEF00E7A5C138FEBCA7926BEB442F85D54E0E2D95268123617BA558B7B561B83D2C44FE
D9EB29271B202C8C6B8B5687125F22BC8A2D03AC5604B5E97EE0D3B705F5A48360EDDE0E1BCA
C110BD4504295F1E333C12E662C47C9751BE3DC1A6645EC39975F5F5D3B2767CBB81D20E9D6D
B74B82604E0C95CCA125AA5882C6995CDBF436FE6F08DADD078966DBADBD6FD86C1E45DD25E6
B22CA32E7A94832382E85D516D855D8D550D9EB8E22854C63441FAD3352238509C521B674CF1
0B99A6B2C2404C6684F497818C78F67C8E0B78BB73E5E646BD9B14CCF8744D20A9F4C880E226
E35C8482CA4922807EFE046931CCA404916EECF6045163BE581FD3A86667BEE83121AD36A89F
F8988E213FEA49134526281E898BF6AE3AE52985E79EA75A2D8B2ADA7046616EE4ADCD8BF00F
A72FAE2FA030EB73A63C3ED9C28036685F03EAB66622F9E8E732184CE2F2C642135A0BA26D62
CBCD07C53329F85DCE80CC0AD4839231AC1EDE3E3EEFF75EEBF71F5263B5B3890262ECDF6C59
7A3E2D02FAA41208AD0F12A719E4E26A9F1C783C280FD2A215F35F098661297942BD4D846F8C
D373AAD385D456D163F79230E8DE1B9CE080830CC6EE0F7F9F683D0657AF9C2B5F921FFC4CA8
D94B756C06435C30C95BF56E5247CA49C24A8204C328369773CD048BA99D5B4AFF65A65BEC8C
23ACCFF4D9068E4EEA9DD6115BF34E660434E5B04469D2DD7DD72DF143B24A44C969D7501881
933D521510521C00155015A63953BD9B96CE8FCB6CA3E4093FB264E8E01AD363B0F849883694
797DBF7A444B09CB0F07EFB19196934F90BB5B47E7F4958040492C25607C29542A5580368190
D970DA431C057B8B3AB3D68C4C6F9AFC5D33812DF30B6F3473A900B4F1BD02F6E83524045574
D2E155576192267AF7D83B7629F706C36EA06EB845151CF45EAC13765D4F5C64D55D71BFA237
531FF41159B618FCCC21587B89D1056AFD9CF6D6A8A06A5265954F4CFD67D6CACAFD49D3E638
7B2E2B4D518B93D4B5C192DC7FF32591DF7F64866FB61E6D0DD4A8CA794286ED4791E59684A5
FC35DE68FFF40191C88C8041B788B6BB491655644627A6F00E0475EBB995CE3630E6905C66D3
4D459D373BCA35FED376B0FC102DD77EA1E14A0DC375574ECC0E71833C9D9AD7872FDECC1C94
C395C203CB31AF4C68425B0829603A477363FA58580584032A3C17B427991F22D90EFDD9923E
192E4146A07DCBF431AF99D87F51B4BA886850D469948D90E26AD5C83F79C4F68FFEE30CEE14
D26A9FC66A1D00BC405F95779574A847732BC1DAA31C37184B938DE12E7F4CC69BD280E02AAB
A0271FEAC2D9C60410D6038A0BBDFD89DC68C718BA0D3D94E25C58BD0A08C704D2E9336D6DE4
A2F59753ECCD86E67B8B3BF0CD860DBEBB45ED454DF0303A9A45A81FFAD325ACB8CAC71ED9F4
9364299629B767E09BAF5D92BD986D440D30307E1910B744600F9DED0AF2C78D4FC9765A9ED0
8780C61498A39F9039F24B3653A668867464E28E3B0E75B833388D236A08438F5409D9532D54
1B0744A4BA0CADD217A124A249A6C8B0D16DE1817DD651A8602E4729399FC479BDF6F66EB0DF
926E3419CF42752382F4AAB5CBCFCEC638F532EBA5E0D5B34E60668745C18118DA33D0F8F5CA
E689FC56CC8DB574BDC7CF4C8ADB03D6C49FBD48CCF7CFA30A7E126BE9D163E3A6B4683E76D2
11CCC116D82D42F13676A045DAFCA7B7388F21CD0B4CE0E7D492E1FE7025A24CD44F0B828E74
B5D57CF947C88C1C9BE25FD38CA09BE8A1BDF0DD424C4DD0E768C94578FB80BC1C04AADC36CD
F4887A5D9BD7D039923D341540B57B98B7CB2CF530BEA1361E6BC3F1CC66A56AD734F0F2D880
9D35A1DEFA4170FFA0223F30F67A74080BD0160B138E5101F9899CF4554FE14B265A528CD142
D2237D0F69A7833DCF281E852B2FB145F017BD4DDBAD89785CF3A9A1573AD21968B7A0596AC8
935329C53E0EC6AD9491F349E14788544DD1D7EAEDFC589AE82711E55262D3DF86D04385DA5F
25BC2A2474EA0471B0C7A8E8AE21C2C10E9BAAD046A58C606639831E75BDB5791AA879479258
A96E03907DA79212A3A5C6F65B68D2F6DC64795A7EE176AC3DE7C76631622C9A3CA3C10D7E2D
884EF4891852682ED243DAE62B078D317926BCBFCCF765243C80849F50952F19676305E75287
4574AEE92A31EF5E390EA23105170DB0EE8FE3A217B0FD690D9920C12DA9073A3C7A44BE4C24
1AD384E762A31087CD6FAF25A6E809B29C1B018A280DB2BF2EB57AEF2179718DC6FEC45395E5
B1667256B11ECC1FCD743CEE5D5F03D3BD5FE7D26F961F10ED2B97F5E251B759898C434F0721
2E3078C7F1F953D2C73F310ADD96C53ADDD85AF53C31383F3DB0314FC4E96BC011BBBE91B4F3
7C22FC0E902C4468D69E6A4E36A81B77460994F94B11BCB72E65E6E4230F9177E7BA781D64EB
B8C73D1CCE8F670CBBE15FB079AADA07B5F28928C955CDF03B1FD2A1F30BB85A016591BCAF80
79D1E3C086C3805882E170BFB3F991185B02B491833CF6DC956151DCB8840B7ACAB4F299A978
4C0AEF53BE0C695BAAB3F5CEB8E1CAD8C501926B075E5D69FE264CBFA74F76ECA248FBFDD522
8F03F8CA0827C067A6700C17E6E726D52A5E9AB0A9DBFBEC31EB676E899A1B36024800BD5150
05D3608DCFD93B83FA3885DB86D83F18E96C074ED28A4779AAB6A4D8098DBF89170D30B3F031
A3BC0849AA079C4A06EDA37DBC68C4396607779BB35985114077AB13CE76EF5D48D6D9F19363
46A176CEDA990E51A9FA8AB3D284B4A1E93F64FDA631C7F9889C293A9B7D2CD355200C4F4B92
7F325556C2D8BF127D52CC5F0EF5462B958E3B2387F803D5BE01862C8755864B19D0B8F32370
AADB8602C1E11DFD02B2423D00E11B97D197C7F788757C416FE5F5F910FFC859E3C6F126ECA7
579FDC8C6A2489C0569F98D2803E8C39A3D5DEBAC8E9E8BE1B6504A6001A3032E172DE05DA9C
DE952161E23991AA59EC90A118F8F05FD219486CDD3AE746CD6200923D47F4424391907A891C
ABCDC7DBB4799F51D4E4F77B6C53B91F4E9038BB1C04511DDEFB79CE4536F144C59D796A0746
671E75EBD7EE2AD5F48EA679CF28EB70F4979780DA16501001F8C5074881541CBBA777F7D9FE
C78A0D0743898F50ADEB6407B023B492C80DF0A787BFEA8DB3639C74B4562FDD0CF0B35DCB07
23D638F864D0ADB3A8569579F335AD00BDF14775ECA7E0E75F0AB61E1544C02EAF00153A4756
E4BB3428D7BA790A21982DB9ACE4B536E809341483D4805D304849ABE3A9801949FF6075625F
C99D87F2628BB1CA123F1B8BA5BFCFBE6EBA43539E2636A60545EAC150D746D216E1BD0765E2
C92D747DE32C9CA8A535F020644E3B2EF7BFD9523C709568BACCDB6DE4C07B2598B66F25F749
50C6BB6BFF2A9BD0175AED1E3996D04677953D48A37FB006676BFCF0D0AF0CC70F1BCC98F542
664E07545CB249F166936664A045805E46D8CCDC29558B935A9E2ABFF33021FBD6E439CEA389
86993B0766D3B8330C09B54549D7AB4CAE1ECDB23B894FC0427E5C088893613A633AAB5FB70E
DE06A42261F8E10E6F8149E18E8372903E7339C83C996A1AD2083C602FCD8C8E6175DE29CB15
CCED719FD396A424F3DFBB879055E8AE87D9DD2775BB0903A39929E7DD3E16EBC082EEBA2B20
75EE3203E7B8FA5F0D45BF7AC96D84610C27E024CB46445EE97632B957520C0843C317218DAD
D9B9E0B41038A2C5411CB05D893B087E6524CB3A7C390E86559B8F4681EDE54F9F08A549AC8B
CF2DBF90A2884E255A37D970CD9855CBA1CE292EA340A3423122399452727FFE67F07D9EECFE
35E840ED90AEC306AE76C2DE28C4E8E2848920999BB074ED3EB17EBCFE8B851D672F598789D1
6E4F59BC1661AEB2F9C674D55BF7D2C75A5036B12E20F72B1B06AA5A832D7D85456FCFAD73F9
EEC11A81CE913C16C5EEBB275A603CABC5FA7C1D9100E539C23829946BEE9B55915503B0F2E8
219C07A47CB70B1DDD1FFC43A57F4D220370B001D72AD04EC355F845A292ABC6EB2E0492A6AF
91CE5A17F0D191F114EA711AF58CFF2E49E781C981575CD2D4A581C0D4EF176546F1239BA40A
E490E264259E77A8A003A81390B8DC3BC777C231A1A4A0F513D6037C1EB17E3368FA0D998669
0128DC35955050983D227C521EC09005DAA0E108D88B171AFA1E74DC9CC51BF9C29B81929E6F
F12F1F548434D7392DAE638223D7F953EE6A4EC94B2A76A120FC1AD89EB1344B5A1749817742
8F1CE1F4A797AA60ECB2ECB2BA431EEF20CB365DDFAFDCF708AA8432D17886B1E4EFC8B80E3F
073C016057EDF3D723FCAB9205FC7191CB090E087C12DABA132FFB94997D77992E73542DEE88
85580AF0B83C55C25CAAA38F9D54597A7A44BA23B95D659FDEED17AB295453B9A74964368566
2CF2387AEEC0ACB564101F05BE906614AA7E88B650A2127227111C68F34E9C61DA16A1DA99AF
98F8F029E669D25EF49065915AEFFD3A88C2D3073D962FC78B35BE874BA93AE27D1C61425E63
CB718D4AE7DE185083E4973C9B86C6E41B747EDE4954CA3DAB6CFB378D3D992D6002BDC3406F
FB4D69D1EB75BFB9FD4A5DE4AFF904A712F3583F8E094667BCF4A8302AB972ED0CC2266D5C3F
C90DB10288E23156C92E74F5912994898638C4C191922FB3A40487438AD53E55133A487CCB5D
2DD35E72F204C531C6611EA6C4CF44DFF27311E1BE4B258803474341DCA8B97C2B0E63B303AB
E6F4E8BF18DFA55EC3D0F4E171A796854D62FC25D8F788897D5E7309241C00984D8454210F5C
539683971B359B9007E00BE11FB3190717CCD3AFB297B083824BA3985545F146DB94C4EB797A
77D572586D366F38DBCAA5CBB961E01E9B26DA8E4AB833BF546D0C0E76914F7F547B8CA803CC
D5F4C65C25F077B268D9B776F9DDD2D6DE27921A19D6E9B06BBFFFB1C32E1267370F037DD256
F54E7E97A1D0281EF3B8C57683F522BDD1DAD122D8BA3881D4D7CAF049CAD62B9D4220822200
2BC438BAE9D586FA5E517DB1490469DDD8E7E5D06BF59050F0E45E442581E13077A25019D742
786374B352108A485E68F8CF7F8F0FE95BF29F8C59B00F0359E8D595A9A97EDC83AE52587297
4FD0BD3797B2D1D819E6B1F9875DB23CC9093F19425A0C90C0BC2F64F9A22FAD8FDCF98ECE73
96ED7A19900DA217EAFAAF18306C19470372C195DD5AD8064175DDC7455C1BE676A20807DD72
E017FC35D1F54AE98899E8E5DC2691FE5F327D54CFD660D947D39A74302A10B7360799CD9A98
B8325ED05EC765AB2CB2992EA605317293B6B0F7CBEC6B4A3160684339012D982FA4481B3E13
451E30B70BE8B640E8BA849AAAD79DE8478AC4D3BE16AA54E16E23222E17E9424FEA437CA01E
720F02428E994A9F7F90663D8F0FA1E2E169F52765DCC26C6D0CD5F9314AEDE7CE5621F812AA
FDB5CE40D8EEFC640231F1D1CDDE222043549E6D488870238B7E72426DE2C74BA6370901504D
1BE2D4151461532839441E8BD4BE95685C3F23E34A6586844603E94F2B949FA05131478EA7D2
776E4E3696E984B8FB91F1EF686D462377E5BF6755C0B406631E6C3257CD036601BF78C6C410
E3AEF20D8D99D232E05A3152A4D0D9F378F10AF8806A7FEBF8E940D4C5FFBFC8AB97A28184AC
4582CFFE2EA4FFEC108E22EE026F5CFCBBA09D9784D61C77F2E32C8BD883D04A4B46FE3BC267
9E94629A721C21D49F12BC14657ACB39801F896478759B85F7037037E114DA1EC65DC1EF0686
58032221F264E83A9410370B33C66095FD804A043949149D5380E98A51187CA17E2D26A02CB6
8590A395BEF498676444E992F2A21549DAE4B8B21663AD4154EBB58545266A052C87046F657E
F8C6D5C3194BB9659F82F7C8CD8722AD8CDA3F4B05132479F76E44231573139C7DF550AAB54D
47E28A2E76480B7299EF8E4245F1704F04A091D1E3C440BA7B5B92EDDA6D70AA6DA458D0DAC4
63CD34BA248E186206A02A060058A39C69139708CE00CEB730A7C14CC075D96ED0E237721E84
0D6591F8215898BEB7E7F78251FD46074F4E7E65E23EA9AB23830B2083D1AE45FF3252440357
366B0C80EB7BF1AA20846FEFA0806CECAD242011D1832D9BE54E2FE113AAE07C466547E66973
3A0BF78F4294667861F7688B9F2FA2DB9E2BF934357AE506CBF73E84F415A8ABC8FCD0C05D66
B0B05624CD1FB71F629BE004E939D42EEEC8E06B497994B207AC9C2F023FFFC9DF51A2DE3BF5
59A350AE5A2A3CD882E77A22E7B21AEFD43AA9BBE919E37734B138AE81C782753146BA9FFB81
39AC5021F4897FEC4B6FFA6ED42F47AAFAF996ADE2782C9486C041E7F021E67009AD9934ED07
A07E71222406284E83371D12E1468A33C4641DA8BE9482B804EE20C6C8FC66EA6C4B8CD285F1
CC2388347BFDF365749D3E6CE38C240640701A211C28E4782207FAC86954A1A77DC424D93BF8
762F438209BB92F957CEBFBCC223F65A159B610B736DC2BC6949CC1EAF4AC6E60B090E96F9CF
60915CC35FB0ACA02DE55822B21B8B70B7C5BC7678CEA9FBB07BF26526FB300BEFD272F85BF5
CA99E37FFDA11BD7860002AE0564E97FC8FEB437D283A68446E6F504D8386D6DA6D2402BDA94
3720188C71804A8D2F25B5803F9C9CBC20DEDAD3E327D64BFD328FF89C88B8DC9DAE2F35E603
EC46DFA6006999D44BC60435C9CE13064FA9C51DD90C64B68323A582229DD40E9923EA2BA8CA
53AE9CF73F9F21715D86D4B28B2CF054098FFA12BFAC1A3FC34CD1E191C267EF871B1EA7B9C8
092FBCDC406180548210D035106F0D21E46E51A1FDF48E7F1F91EB26BF891520EF8C87BB5D9D
E49FF5600FB2344C6CEFF0274DC308589A335DE9B23DE4DE14DDC2A44C8C8BF05FD99E5A34CD
126C6ACD50D689558F39F4C7E2892E6A02C4B94D5C454FE7AFA29CDDEF165BCCB07763B09922
DD563C2C757960A5A97EE1E6E51A93417115A7819CBB45556CE8E62FCB55CADD8289FA70B7DA
E965294D8788F4AD0812A34CBAEEAE148457636D5F75BE1115C1CE6DD6A04A1C20E2069D391A
ACC21871001B759E4A8BDA7F1D4EDDD035E6FA9783B814604E18102D3F7FA9164A7E9C6C13E9
249B0EBB5B6161A95326697C026CE221E5260C522D36DD99DFEED87F40545994C90FA7275B67
419F61D69068C16053F24B70F5A9A8023061061C6288654056C85848E6C9A2F5E38B23EAF8E4
8927B773DB2AF445D05CDFCD924CB828107A020FC353358C7B6F9EB7BAC704ECC45B76396555
3257FD2B0425DBC7DF83C3A18CC950F0823F9727B9FD786FF667C499A284EE4F5134E506C0DD
40B2FBB8952153DC1D753AF3C299CEFCE1C9B0895312846B784E815E2600D2D63AECE8D16AF1
30141E904825D2934DF4FCCBF3C71F2E280908DA0EA7419E6328048242117D4A9C9EEDA78BC3
B77C07DFB542676609954DA1AFD045F661CEFF1434D0B8A290CF63D926E0CFC1DEBEB6F576F7
864DFA29EC9FC3EDBBFCF275F5DC3530C6413E54E18974C020A17193D83E7E7FD2C7AF21B9E3
4E6B4E9D64B093970D2CA213412C0C398F05AEF130F69D673A450F8FD82F5F14A0CF338E9BFB
F777D9916A91ABA604387AE9574EC3074BD3496D7D71C29DD9546BF7DAC668562F3251FC02C1
E0D1D705BD41AE0F4DBB770006B834F96FD46B909A5BE7B25997031556439013D1A77D1B7B98
B92B7CAA7312B0CB6B10F526344D34898EDC64BE92F08618B979222E02D0A282680946ED72ED
36C8B736F370C76EE39CBFCF91121522F75CC006402A57FEB9E28DFC3474BADE3ED1BBC32286
E9A4693D918B890765656DC2ECCA686818060AD0AAF54352F4488361A850D2BC4E7BD1696033
2DF1F7FA943E1306F9E8AA1CC6FBED8533A03C35A909CEBC7A5CFE7559421B7EBDB671E29F7C
30730FC149846937D7ED582D2493C68B2E0DC93E618EE54649959DCDC17B78F0F115CDBE915E
AC678167680B39AC122308C4606C8946ABC0CE68261EC2D82F117274E10D111F30CCA108E55D
3A419FC51D279456062D825CFD5BF1D6B70411DA70ECE5A6B7CABAD815FCFB1967B775F39FAB
6A1BA28F82C918FEF9957353EC7C8DC87E84363326AC7BACB25287764AA941A4FEA2414E2767
69565F49673C1D82C23E5D06A9E2E06D4F11C5094138681C755A6B76913E1A409F92471E47F0
F359456AF31FE5516A25884AB295E8925DAA69E6328FB34FC0C9DEC1D42A991D8DBBC6591EE0
5BC5F300ED66202455DF2BA32386ABAB33B3EAE40EF0C65FD02323CBAB0161AA2574AC54AF19
4D44F779AFE12276FBADE09379E697CDE510501DCAFBEE795892F65DF6FCED597B592468D032
1D500F4DEA9A418E3B2A4650740C3E18DB1ECF7774A4CA18B3DE647C5946F873CEFCA2A67DB9
936490DA089E084EDF1FF811AFB225312E8F6E0A3880A6573A74786850DB8303E52AA1D387F1
D52E2637001EF473530798F2B489A6A5598B8F70DB9AF06AF1684162F328962FB39F142ECC5A
2A18D7C98318F00424971D749739120A06022BF2C74119D1BB563F46CFDC393F807E2DCCD9E0
710E911AFCD9A46BFB36E8DEBCC81CF804991A7ACE8DD54D65027D55E63A99CD3E3E33F05214
82601D192432C34034B889EFE4E078AAE7B70DE9485268841A91A393F82C759BE2D705732EC7
01B68DB401484961638436DD91914AB4AE035C599B2EDAA6578C2077D0DF2ABDD894DFF838D9
8DDCFADBAC786A72A7926F087D9CB435F238F4546AE5BDB9978805A2A60CCFD615E1D7CBB063
3A19E7D05F9F6823C62A87685140BBCCBDEC8D1B35E819630D3D587A352E09226DF19DB10F0D
C987FF64C06E8A062BEC8A6EE0258EA5D96EF80D8ADCFAA99519033666354AD36F6AD4EFD33E
B62568E6FA563B8CDE6E6385F6B2DE7D7A943EF88B2E1C11E85575262C5C5E804E47EFACDF10
AF0D3C8C5EB9059CC2BAF59C5C7520F0A09A495A275CF5761333845ACB9217DCA4D146BE0B4B
4990D218E4DDEF0F726CA5EA06D17F06E7DD3473CD694C8495F85B02858B49F1352C8AFA339E
904A27B96CA1B7F3826B3C2F529B9BDE98FDD20A526D1044EAAEE5368A03E09EA752D2C40CAD
B1BED9648FD1925D5D35813977570368495128E1C9C74F268C4817CA60A5C27E2917E98B5C16
C8BC0909F29B9085D77F9CCF08045D31CE9991F8A39E3A97075F3CA6095A452168ED5AC5770D
26CD2507CC1BF86C75AF2AC3E382D1548CE7F3A39C61CAAB2CAA950C08F51CB3D9C410E689BD
4EDDB1DDF6EF56CDA255F0F0F1D0AC65B751A066148A4B0FDC2193877F8F9B9C3E5BDFC18BA2
89806C06838CB4AC41F3452EB90C18FE3B82F0C2243B32AB0CFA88D963C2BBF74019A74106C7
6E00E47C63FA30228E90F40103AD273CF64F16713414616B357972F3AF4F1E2C5AB9A819B0D7
6FC68C643DA81A88CF1D48B108D804235B54A77B9F98FD453EC60228EC3606AE09A6F77711A7
232B3B90A73E06089A6332639BCB0ABCBF01F3486DDA2A5153E5A740819E4DF60292D941D766
2B298E6C18F6E3024D3327A530DE89BD793B7E756211E209EF5B56E374699E6A2E504B0A065E
9A6982C7914C50A31A0D5A3DC885A9E5475405BEDA956309CAE327AD7915EBA32D9E71B8E490
D8AE4E5173EA2C82A001A98674BFF30E826EB627583E3CE85AB534F54D1FA0A3591639F01F48
AEBEF4E658C274DB82DE58BDAEF0661BED4B21D9A8ED86888DDA30654539F2D85B6C35BE6848
A940007D61BEC4AEA887E66FE7814B9A7C4B301C297822EB11373757EDDE179BBD13CEF95D4B
21F8C285228A14D9D9101E82F811B142F1C4B5D94BB96F100A82F88F9515392D39D7CE71878B
A29D9DDDE1B5094DF5B1F4879BCC77C09D68299EE432E8BFACD82E89F608C075F2168243A4C3
7C3B120240198A82AAB105E6EB5FEA32A6DC969D5610C53593733DDC99A67253E614B0270100
1227AC8E474DBB9452B2465301EA948271CAF2FFA83B57D161C3C50EEB3578D92B58B1CF0704
CFC7A3AA1EDC53C7DB6729167F4C55AD7557F6C5D9CB1F3009ED84C7F4920FF9F1179AEAF374
8001407E27447DC763BD0CB2C4AF6561294C7D25CCA7FE4BCC687CBE1C48EE041B3E63006B52
36B33AE6C64A0FA2A9650FD0CDD7E230443B0388B0BC94AE51D4D802994E481832F800AB6321
F82AD8264D1A2639D68391A99E504C7CDF2482E56AF3BE3CF4A433303D2B78E161320A55A6FF
D0FC611994852F4EEFBF6CEC6BF0DB6DEE9A7C2BA3EE2E6B69049EA2ED36C1BE218C1393FB0F
9E0579142E2BFD217E9AA359D3B55BD518C0440BE86E558612483E5CD03D6CB6E4CA75A77A25
567117154647FC33588CBD165202081BEEC00D07F879904AE296693E3F0B89CB76A650D16538
3F66A55F9A48A63F4A1188E83C6810B48D0B6A5BED552791505809321462DEFE97B984D04142
AA5EB2F0B46CB942552B56DC934C84D38F58733AB995C3D43A9C98DCF53189037F5AC6389208
496DA1468BAA65F562D975329FB8FAF47EEA4802BB19A4822E59F4011DED8E9576E49080D135
0B97BB69567C23898C8A088B693CF918951F6AC61ECC5C4660B12D2EC2546CFF989CB3C7DE19
C7E76F8F1B96BCD5D369ABC0B16118752AADF5A728D9C571E530D4E2E655CFDAF1053F714B83
2B6AAD6A05F09AC949208B5546F9E5B85CD9EF221BDD99FF286E8C7AA8CC2525D15D1C3B6FCE
D8FE7A471101D35600F731E7B5B7DC66018FCB9F6B8FECF7D7C814C98BE7B35EB70FA266620E
9204EB041A03FF75850052BA7C0BFC247A29CA2464A9A39F3956853D11E9C80269E9A123D7EC
F899EC00AFFABDABB7B16056860BB007CDBCB6C629306982DEFDFCB8D8305F32BDF031679417
29763F42F5871D57EE2F9818AE6FC4A5E84A87A8ECF8232F1AEA6349DC16705F17670AC9C8BE
6D4C4B36851DCF36D4572EB60C5BC422DBFA4928C8C30E5B3878513DCBD4649C2DE3FDE6C09F
FEE03A448693C6BA3AD9C0547B46ACC3BC5B363DACC635E8A4539625A2DE1FC4B2301E87A608
41EE60B18136A1D2588B8FC7DDAA69367E1AD938C60D83B21C292C5B853033E574279DD346CF
3166340F5949ED1DBE30CCE9DCE164EB4A5AD9F967F1EE4909F964BB52D5F5DEA2A03C81EF12
F203FFDCD3A7AA3331B3F09568C4055E254182AB0EA66A1946AACECAC377CA9D014946F2728A
1DE0735E9D40C3742EF392A79BF70EEA6B6CEABBD23CC1CF2AAC1763139C97FE5B09880C03AF
B8D0549E95D7D6A0BBF4CD32D050A308C8D6303C17A7EDD645DEA213A19089B5BDEF7A09434A
6E9D29337CC9EF9C40F4CEBD85770C610F66944966A9CBF6C474E854FE865AA59C1765E765F3
97340BB132A6FA5E50FDEAE4D4873DEE7590CCE0030120CB4EDD607EC7B10183E5DED67E8A58
8567C4EBDBCE097300F2FF74B0EC7FD54DF80ED6E7DE0DBF0DBF59330E4602A57A5ABCB9239F
A1B7068216CE637F6E1E9D12BF322C169031DDCF04890C6D76F84FCC1414569B0F3C917DE85B
D83A707B55E3E7C97C1CEC2660C91DAF2EB56C31A86E2205023719EF16D692CD866B868EDE0C
1D65C194B3F761EC656B0B5A79DF9450674A88943FE87C5490C211DB76D4403D7C4B613A6591
CC2BBC86FD4826F0175C7052A468879E5084076195027A9FD11D43A1B993B3261A5092453C32
7889C5DF6D95D38E487949CC72189B62D0535A3D809BA06B38EE5BA2370030AAB098662F77EE
262736DB036472B0B733ABC82B848E93B6191984BBB6CEE7B4BD505F5D6195AAF58DE4A9F6C9
9C021C40F4BF3E02D65368606C5E433C02839190EFE8FBE86D9AE656FD6D80ED4D64083EE8DB
FDEF2B0B2EC62A2F1ABD78FCA479536608349C512E51C8614366C602DBA9338EAABE6BD004C7
30A8F2AEEBCC2777EE96C033E00CA0B62967F726240EF86F6FA203B20FB9CB0059EB1678A199
4895C93C63B2DCD3C61872E2F756D86570865DC8A949C038405F4786CB8E3230F2AB0664BBBE
BB99E07B7A1773C0A78508F90D4E80B6A945C4FCA0D4C5983C6882CC01751F9118B1569CE7B4
1E4855176331F87A88F5576947A12B04690E25500EB2A3FAC46FACAC7264486C25ADBB12D457
60E71656575D8ABA1F570A4254C4247090B6E4794F051ED0ADC68861D1269B54D0F368EC8BA4
0C649BF223465EB81613EA0463D0EB9DF7477A180FF356684B91B852F5ED55DE2BD100ECE8FF
2B428AC57D4D6AED71CEA15A1E824E9FA1CD1C3397184E14C338B859959A1384ADB0444C6FE7
15C87EADA01E7EB239C1DC11485A17756762DAB335CDFCDB942DDAAEDC805344084F65020024
5C6B4D83DDE9D96BA89D6CE6A85D1B597478863E599D35A059EFEA6FC64ECD4CB965028B5FD7
C692C227A42C7A09636E275FBD02E5656CA2BF7C7C15CF5471D15076571E54A89F2125BD3787
F37CBD5AAC96C63A9460CC903FA791E54C61FC24DDDAA64654CC846FEEC2B589E820F5BDB6FB
44E904CBF7F8CA43C9B6BE11D482D42E25B81DDF946A811FDEE000577E9AC0C3ECEB27913F8E
A6942936929E280A8BC1CF1D31C355983D38E7A008E13C56FF15B4F781043FBB896F0D3FCA52
13B113CAED08917260922F22D2F2359DAE1FBCD768B1DE56FEE28D9D784158AE6C4AD12C27F5
827E4E7D627DA6E9EBC625CB80FECA9A641E100DD6892F940617280DC87B3E910843A9776104
7DDD5CBA5921AEAE339475A21A8444E470299E5AD0EB3C143CD0708C993E15D3DF34E7D46EE9
C5421617B660F3351D561DD518594867621877F7843FF57A2661DFE400B276BB60BBCD094E92
355BCF357C8D15623384CFD3BD159974A6D1CC5F4D43E27EBA0501C40BBCABE830840606F077
CA60549E5D83DAB237E6824F4BDFCEBB52EF4C29E08668C10F5F8579489BEE9745F2A18E6EB1
4BA02D2A4E5A06A817E6AB8F56D63FE9F91807A07E2FC0E9FCB3968A32C8A066EFE92D74638C
42BAE33312FAC15C70F3B6604B786F3AAE4F90630ED5E4663667891A24ED927B5151B18AC60E
D724B8E2785B12673D7E0C32876B10D79FA21463091FC3997A3F3AB60BA395F8883E7BC88C9F
92720D3F3DE2961D3CFDCFAFD9723254597F134588700F87B44443B442008DAE54FC276C9431
7631F74BAE6200495EC2212A3F942DC3642BA8FA33E04301B010B370B667AE040BD4134FDE80
CEA0CB89CF904FEA7A8017AF3E2EAE8AC836ECDACFCC7DCB0FA8498D82EEEF746FFFBE513C85
5783C3088F73524B19B96F49918397EEDC5962F0733CD2300C2FAF997B16CE117905D471E049
BE28C44062FCCEB934EABF396F8BB0BE8C26C7882AC76C650A1FC7863B57947C14DBD618E8F1
FE78CBA20E5AB63F2669A1571E6FCF870B5702273021FE1ADB07A91B0D9D0AAADAB838595BA4
8CB5B8953CCD5C5724CCB6531AEC9E35F2A98F358A9B5096F5004CEA569EA608FA2D6F185AF5
9261F27C7BA651CF0E8899698FA47E8573C387C8C31CAE037E47931E20AFBABBA079FA9674F9
43E7EC7AF31FF5565BA2F797B8388D8BC557052DCA3934CEC84CD0ED157784DA670B22DD0228
EDC1E7B4C9C1AAED587BD85992D2CF03E64EA3419F979540D98CB6240F12A629A08ADC7AE074
E627C632895EEDBA3B4ED81F3248DA7ECF0BDBF844F025C59CA8A2D55D972778AF64297C3AE3
CE170A14CE18335BB7D152559A1A0249C4327226482EAA677C714BA2200D656600EBC61A68D3
0E6DE5AFEEE1C7873BAB3CF340DA6F5297CFAEB6B41714FA6C31B00E3619C74D061D5B9E955D
EC2DD6DE2C87EF4D2DCF442C1EE7E2D8301823B290B9240103AC943C77BB8A0099DC2A72850B
8D4BB29D2081F861BB9C48E3FAAA14FA21228EBD7F7E771382A531A7D3B30CBD6459A5991D78
BE3FF2A8A8F14DC4C9D3C464AA14A393F696AED77A50D9EE9CF5F3C4DCDA000DFE2115FD9D60
60F9272544C9045D4CF0B5490FBDDF117722033F02CC339293666D7E7C13BEE582D157C6B46A
00068AC9E284D0A7E354FB69719512937C3D9D617658D7C1F82A54C3EE8257A7238A8A7D9647
CC66FA093D1D103E68416929A59F12579D72CAE5E961956A2FB0AAADBF778FBF7B7B79C96BFF
BD5B9781E1AD3A7637AF20D9122A70CA061ADC28987BCDEF7E7B173D8D4CB2874F8BF5D6D73D
C36CEC16EE17A5C7E06B5C4E7DC9912473C1E50836376ACA9F9C9196B461B2F827F61851B57A
519F3A103C4AE95CA716EB3895875BDD22B8D49DCB92A7F87D76E574C7DDA5F90F9F9A7599DD
375C537AF80056CB7FC011EEE09BD2DED4AB2D02E912F77FF555B4FB37B35D3883216091E61B
151A068DCE5BA7C4EDBEE5DC82AEE2602658F87AF45D50C8CFD1EF327ED89614ACDB3AFC058B
7F382A60D75FA27E0929688940CF9A2A56319261DFDCF2556325E3413B6543A581C4FAB52315
0F1CD36FBC841771601027990747E681C78381EEC7424BC981E8A0F6B3ADBDC3A50C04986D8E
68F86C2BDE0489C99F3D68E60D79A071D1D9F574BF851F753755A9B67EA653BE442554CF4FC0
2665E6A6B577DE5A2F02D37154A127AEEEE5C1229E07E4CC9F88243F1FBA07491180A7A49B74
56F8BDABF122B06C67C41AE7DB9319CF8D91EEA7ACCA4AE275F92365FAEBEE513141222CC262
41930759D851E67621C1B25EDF0D0BA627B575B702F16A12181E27219DC3E39AFCDF0AF7C80C
3AA07B001FDBAFE203017B6C418D9045050673930281E3250A9D9B56E0CB68E9D1C8E64A9F0D
8A0C1233DAC6CF515F14115AFFD9026D88B6CC122C096CDCD21143CED9C93FC50D277E430E5C
4EA06533BA81F5B11BA7EBD8388CEDB611D71A6CCFE937E074CA69A31BB18E317A0FE95DB192
EC9614F5AC9DC3E1FFCE5B2C75EEEB32F2BC930DB21517CE717C5F836E8CA1125CA8090DC27B
BFFADF2625BEDDE0CC03814D6E6D3566F1A0C6ADC3548EAB99C441EE0DC3846E78BA69DB16EB
B5BE775FDEF8B437B122BE7A637845436083DA5E92708BA3B9B19FA46F1ECF8A69ACFA7AD33D
C449087057A06047DFEFAF98CDF25984D247598F857B8F28769B6760388FD193317E963BD8F3
B621E6F6DDEC888B97020BDFD09278354D8BE5EED8E7C99B2E1B2912F36A47A6DAD01F9E382E
024B722FA42398F24EFE10D773E1060081E5EDA5551B4FC90540F01B09000FC3E17A73BA3CCD
4C73CAB81E12B0251F1C93D344F376D6A64492F94CB03736A57235EF2770D81E228F1BFFC2BA
AF295044C512B873580703A589CB735C726DF8E5BC1A71683CAD5C6D9CDCF72277D17A25DBE8
DFF81CE0153EFB639B284D073930B8D35B857C69B7ACD271D04051E1086435542BE8E664B79C
B58E2E31820866840E465758AE4A6EB4420BF0EA5D745F41E07A2D36FFD81D378657DADB062F
33752A43B5C6DB8D94EF6E38D81291FC8150743E79B634999AF536F145ED4A7EA59066FC6F40
C440C7E1EAB397FA2E2C3D3A45F3281D2B8FD204391F4C90E6A1D8587C24B7CDB5B9FFC7F952
38612FD055323D56DE4AF1ABA6EDEA54B43DEE6DF8A36D4BC7688B469AC5E0AD85E490E597FB
01C0D4652E0F56C60DA7212EE14D2E60CC13B83929EECA1F51D148EBC8ED978DD43E76241392
2C6F8322E93D3566AFE778BBE4276704A5E6FA1CF4654AA310CBA5EA12F748DC4E8474E22529
92E4F8C6506765E5A2B9779CB7CC008CBCDCFE156B6A91D727960309A7CAE08EF31C69DA379B
7FCEC84DAA0D7EE388AAE206AC6AC782611F240B3B576240F1A4161ACB6CC57172615A835F57
BE523C6F3193C6A56DF5E8E51BC640649A0C78135289ECFAF8333DB03DAD1ACAEC2A7DC7FBE6
E0A2981A332A7DA16FA6BFCF6BA8818E89FE59EBB0282040DFB4885B095FE583D550B9EE2C83
97E851D65E05A6066456DAADBEE698E0215EDCD0189507086CE3AD3BB9DDE905C8BE3927840E
A58F4C6A9E61D444D421E1B1F4E53B55DA0435B5AB10957B04F32F2716BF3833228541FCBF17
060276BF288EFC1F8C33B7A74BB02984E07BA302C82C8408F9D88DACD33AA3ACE9E4AE96ECF4
4094F189EF19E12960AA307609489581DEB3A3AD2EDDCEA9CB4F0CF40708CDE22519A1E9484F
F52BE6019B4B8050989DDAAEC05E97010FF03A482D87E2DD45593356BDD9854CF31BB58C53AC
96D449000EEA70298354D24A8034B4B92B99B0B2952D363C9885D1F4BB78A8B1D65CEE8263F4
E6C4E775F6467081045020ECF7BC5F9762B5A7BD487AEBBDBDD89A813AA296D958286B14A093
6A4806A898F2FBC2060AC9E42D6996DEB066A38A4DAF62C784BE8968101A50E249486BBA8F81
3B42C6F5483853F09D21050BCCF9B375FF781654D6DF2F24B6BDA43D5052F0A3DE757CE9B8CD
6A98798A7A2B54D058B732C51245B6EDD2C65778F7FE7FC2645B99A78B530B606D98425A4A57
A81200D3A75A5D85518EF7AFB99A4E9228203F62B1326000F70159394365A2A8B6960D629C23
9CC2638D7B069A81431C62A44A2749E387AB477481D3CA032B48ACC77045FBFD384A2826F362
74C9208C32300C8865D4BBB362E1A91AECEB9E4641BBFE783F2DA447585554A599D67FA472C2
6537E941AE510A92BDFDB460986B401E336EC2F3CE7BB032F12A2661AB1FC21C3E3ACB998DC3
5664169821CDC829E1A247DE6159244AD84B7480847D42246EF616DEFF5D6CA0FB4F76C6E8FB
F2873AA55433DB8F676030CC1CE37F712FD89F3B9CF90190F8DC0A00D913F5C4980BBDD8EE46
07277B975C527CDE6140872CFC0F5E8219EBBE509498816C97516FB67267FFA97E4F4FF8A440
7013BE36FAECF7F732FB9D1BCFBD33FA7D7F239AE2CDEBC19AAF754825F8D121949E5B01C071
85EA9006B2221715ABB0B8E3F688E62658E187BEB6291F7094A777A8A6416617A6D6AFDF031E
727484F65ED7DEC3411E5B239AB62C96E875135C841615758322A67BF2A67EFC6C5C26E6D039
84F3D01C69152CDA51C516F387A902F41DDF513196632DC6939538F12F29A1E979BE64A5D6CB
B18F8D598C4740C28263FC980C9406E797B8EFDE61B8E1FB26DD11DF0C332937265AFFA3841E
7A96DA2E5A9888DF76097B154BF84FFD5525469989D02B65AA2A2319351D3E99ACF6462AEC28
8F79AAB39D6D849A6B32491CB5657D85B4FA86548B248BA5AC52F83B8B731DF3258CCE7BDD40
9E8CEAA580BD7002FE1FC9458203DDF9328336141608B2E85DE4B2B15B93B73A7D3261686CCB
A6C8CC1E98A0BD6E53DEFBB807E1DBA2214AC8352285A9815C7B250E13319165980F7339A9FC
83A96933A4E6FD1E848A81FFA8DB1DC64E3EF41B1D8CBDC80260ED8DA755E9154168AF0F9A56
4E6553E544620EB40DCF24442B97D1E98028FF596073E6D95066DF962650D9FEC08FE7F6FEB0
AA2A40E229BB8AD13376BBDC90D24B12065D0F0B55B5AF9FFC5A5D2FF1A17788B33C831B6215
D4A107014277884DB47D7957C70E66662C14A6BD24ED2E27735512963C56B9FC7742BDBF2B0D
EAC3B9114EEC86C89B382EA4A2C6FDDD3FBE91683C63013585173F5BAB31EE06BBFE814A6B3A
BF040E49E02CF7F86A32B027C06637E2A03DD5DB8B48C772F4F0ED016DE720864281C5374E67
9AAEB59C31BE88964B8A4F10B16122B30624EBD54A073CC49C60C44857DE650BF52FA02B81AC
52E1A73AAB4750E8DFB792C417F463AC72869CBC45820BAA5718ADCD53846C73F2C1FD5174F5
EC78D1322892B171F9EE34354EDF3BE4F28EBFBCBC662E08F28A9691762D2C89409B587E4979
663C9C2C4180C5B1AF1DE6EC726E4D068E565D61EE5F199A0C5C3007BB53780389D43225502C
8492CBC0338504E4F50921482954E49CBCED18BB15BAFC4810B36AF6FE01614417DCF376FA41
502B51C9B440CAEDE2A4F2028C8DAB5B1AB35CF6C272E35D7DD048996C923596A95F6C4D401B
2414B7B14BB574577C39F6DCCE7E4E80E86DAA04857A9CF15935D9337838806FB4EC884B26DC
2A06647139B4D6EC4A1A14DFD88A31E877FD4E79AE702106B568187406644A63FC39D3C654BF
B66F1A13EF6F77AE228846DBA829AA08DA4744C4EDED0F1B1D755BB58398B7DD39234E33E1C2
262C72D0E3C3BE36C28CE61A43E4A8085143C652A6E5A31958F02CCFAB4FA8BBBCE98872D5A9
A0EDAD853A599BF48CCC7A777EF714D9E74C9D66FC6546FD93AF6F1411216CF770994D6F8250
F6FE254DEF400EBA065CA35AF9426671EF8474AA97279D381BB1E13EFFA379BDAE703014A09E
6BFBE7065ED8FAEA54F72A351151BD284E8CBDE683803F76705E694B50B8364049E0605FC19C
B1A6D3FC6FCD91D942F52E1F321123C25AB4D016619B988DEB43536DE0B38A3E3C9C85DBFF87
DA75FC81E94F934AF194815A13E95A14F16E5AF00EA70D7561250CDE486DD7255434F5F399F0
3C6A0F1556BAC92755F215388B9ADBC12A8ADCE7A7B8413929DF748BB18C76E201B43954B496
7AB4C489E817DCD9B54D623CDFEC8998C9B80C38C602C78F2684CED4369F750819BCE86DD846
3AAD5EB59B5896A525540FA9DF72C484B84DD4DDD8BFAC518E4B1936040E6263318C46009694
182E84FA89EBDB0677793C1565B13D771C14B122E2000F9BBAD298B7CCA013E8744C6B3622FF
13077C2C39E26A82EBC852EF28E99A00787BC9DB37A6B635BCE4BA0F48F04F365557B7D61423
53F53B6DA41C059C9E439958FA214CBD2BA0930A23641A02659AFE32763D2FB20FB2D1249773
DEBAF69171DB5EE64E2C301EF95A3AD08BEA7006A94E403BEE770C5C1B14DDF2102D80B5DF0C
693A670AF610CC848D961571B8C5536D6436443820288605C67BB35719168097559047B23147
3D7EEB9B936392C39A329A6B60417994C511BB95ADDADF409CFA057F3C2A29F105E43DD4D5F6
8DF7A254685C107153663E0285B35591A644E903673E2EFEF37F5A6130EB7689C9EDF5DFE30C
8928423A84D979E6A34CFA7E95D3257F24C67BD28DA85ED6AAD17B4E0DD7ED769E8107A98B61
2A4BC3C26895B85B088D70D2B790A237977EDEE69227466FE7A49FE99FC1D783612DCB86EFD9
6D9797D11B3CAE210D428B43EB8F4229EB95ADBEE8AAA3BE354A62EE0AF92FDC149BC67501D1
A7656D8402902680CB9C2153FC9F2B79EEF8B448BED71B35B57071B7FCA5F82BCB3C456EEF3B
6931374A2735DB522A29D390EE47B4195647CE32EDE5CFF1BD57DAC2D2A8FEA209B436F26C8A
F48BCA9E9873DD57B7BD8600F1E1251F669EFA87A363A0D98DC4DCF94D552936A9229C787A3F
64ED2989D09B57A7BFFFF63CF74628D75F4ADCA09C939221800886DA72FE2EF45C8282DBB818
69CD40CA8F780D6C070AB50ACBD8B34B64D7141DD84C126F9D9B7CEAFC13AFFA6BB73CD8880C
65B9167060399CA5D30A5CE310EE606CECCDF26252BB25617833201A4C2A018C208734C20B95
659B0FEFDC08DE7F777D9C663FE15B98BDF92D61FBAF8FC8A0FE89912414F0B874533E1D9FB1
B35A09EA380514F643E92B3EDAE0B924AF4E8DF5EBFF82C120112DE20F8ADA9E8AEE8E43DC84
DFC3CBD27519B89EF47BE111F190AA0357EC24AD0763C82B2E06D16B351B2966CF28E5810FF4
8041FB910169D1021AE38193610ACE045D55907A12FB82AC13F9465AEF27354043CD7A5A67B4
E566D41B8D8D1AC85F5C685470EB4984210A91AB23D3331BB2B1872268F218F5F618B35950AE
82879F7D170F3BAB5382946A1036389F539A75A17CF8A2646A226A765957897FE1CFBAA2F84B
9717F218CF92DF1E81A760FD437CF4C86990C77D1A686DCD6A80BB8FA7CF695E062CA5EA9ECB
262B0558A15FD7DBEF31DE315DB0CC393CCAE585077A510667768DEF6D03B242B6DD911D8DB4
30B3D056790E2F951AE3F226AB72109FA2E17AE06CD92ED1758256EF73908BA1A65CED9CF66F
654F9818CF3034AE5BB558A69DCBCFF87E1BDA4129ECC7171C5DC12060AD0234D0A3CF5A6B47
83F5426744B8AC99692296F3332FAD64A490C4889065B484BEDF78458F8DBFC156F0730B3666
12A7A53FCAB7B9288BAFFE4C9E879D5A748AEA72929CB6752A6F5C4970BA60160BC9D4AD1329
6D4F71D195F978409F09150C46075673833FB30374E06E92456835E829B3D27D0642DDA30F19
9765BEADB33EBDD0509602D206C4D5A70D109C43BC50613ADB59F33F8EC6D339B1894E04C0E8
523A1C6FAF07992FD61015E5D62D89F8B75B63578E723B3947F06220DA4B426FE080B685BD20
8D872AA2269A40DC3ABBFD7AE7287A07D7855783E7A4CDFB9238537CF0ED37850F4851AE3462
993D1F5350C4596B0FF4E564AFF1AEC6FDC2F3057E55C010B0743B7E61CF9FF10A3523603737
8643A90CAB528E7C81A5AFA12EA4E0D66058CC42D57834342DA04E78189DD7AF69BC4D030FDB
CDFEDE27ECC6AC7A499373DC449E11A796369CF655DFC8044B991DEE9F8CE0BF9F4E2D3B6DDA
6C3EA573BCD9569CD382FC38169648271734E556CEF0C8F557E7916CAAEFC977034DB8C28551
9C1245B064DF0E0ED160066E24E362A0F9C98CE45E4F31095E8692869018AECB9113D9FCD0CD
3CD5E19BD033EA169750DDE7EC09E7658C8BB7F442C63C3AB3664D7690DF332AB1C31F0DC0D6
0A0B89D212D0A0625B5903FB1086215BFBF374C3BA02DCD8AA76BA054FF63AB4584916BC30CB
B7AAEBD1205F2C3D75133D5FBA1071CAE08170005905E7F1507C6CCD5B4AC26EAAE01A58C40F
D60E5B84F39151842B12B0394AC5C5007247EB1C06D6A60B8DF57C0676D179C5481498A17AC4
A432D961468E8FC85B5969B0B303B9634A3E67B0F761BBE395A7B577179B16A0505A15FFC180
C5A56036CB529F69BBAD4AAB54F90DCD7452650BF7D580C96DF61F682BCCC4538E5B7AC68F46
E5402BAB2EF939DAE24175BD022C845477604EF2FFE87C2C8DED096B82D77C5B456FDC8E74BF
AB9C7625A2B14637FBB8BF00756CC1057CE61CBB8CBA2E25A283F5EDC5657756AEDA7B7AA7EB
339236D507DC585CEF57B9791B401A84E246EF105A9FBBD0559415EDCC128AB055DF8BB6FF60
C5979EA397E23C51DD08B1DC743A21791E72A4DF3EB4BBC8C91094F6ABEC42BF4F0E4B298FEE
FF48B821B6367CB4E998EA41B22906D17034802A3FE0E2AD57271D9DF5E521FCE7C8AB704CC0
F08C3EDBC7746E757634210349B69981F97845672EE0A627A2B78CDBCF0007AF1314C74C4D91
4BC020B90DCF27A89BFBDA562F5A182ED3E3D0F575D2D8051BFC0DA1870767CF81F72E4C316F
DCE8B33DCF5EDBF417A1DB405EBF885A5F57D5EB534A1D94CDBDD48EB7A7429DDDF504283B2A
1AAD3E11C6E758EF741E5D3CEB1E0E2235FB099D9125E72F16838C3D7AF8D9C72BC5454C4C5E
DDA75CC3DF4E7E8772A6F5FDC5DCFFC223F6A7EA041E5C4B74F25FB732E91619521D1B0A898E
C39191A2F2DF4A8E9B81A472F9F441C9D8AECF8A61546CE20881F8B6AAAE08F074CB1BFC89B1
FE417377CF5EFF6284CCCF7EE15C505CE6A1E41604CA538595EA5B48B06C3DCDCF031E4955E8
C32C4541A75B86D1ABCCA06D2394E56A78E740AA170CBF22B65CCCADC86AA8BB693961B486B8
8B6C69449FFC4919F2483E9868607067365141723100C03B9C8B5C0249CA0B34BAEB6BCD895E
D305B344828349525CE8166E9232BDA16F1EE95A8FBA8E4CC74E9FC68F3AB8D5715D42211D98
A3495BA170B878179F35532C6E7FF805A87685FE851CBCC5416158F0E9F8AF006421D9F3C46F
6D260DBB07FD89CCB0614874E4405247D4C5F993BB228D4C4AE02D7AC8E8783F3746F9DF9F6E
F4BAB52BB8EBBD6B0B419CD8572F3B6B56DDE67785111D72D18E98845FD804AA2607E1087D47
604D0477BD4937D622C72E6804E6E4FE6FC20E1910AB9093403467829392A5801A0B1221B4E6
28E2479E676C77A32936443627272CE1306C7FA678EB517711509025F1D8EB23A56ED1C859C3
7E405F85F7F472505C5DBB2F1C764C7F6EBB44F236D6A640A4ECA83AFD23C4ED76F643C62347
D6AB28B79ECF0F5CDF38E79BB830A2F69AADCFCCCA6818633CD55BAE364DBB6FFF6DAE052070
547FFABAF8B927368B019BD4C11C122C6F0A3E1957DFB0E46582483FD95BEDB0733FA264D663
34F39045EEE46D977B936DC284C03DCFCC97D37DFB7E419F870AF05F8483EA021AD5FFD71480
FAAD2A6BB72AED996C8BED981575612C3454A1F5B8201EBAD2928FB66205D9F36A39D261CC72
F97439F07DC58972092E8B297F1560B6A5A4468B2B250552C09435DD38573FC6676A75D01A5C
58867A8263AA5478FD7D49EBB904BF32EC75044A8ED3DE400DD1417B2813EAF70293BAF70219
BC5D3B6E63110C755570FC315896BACE15EC936999B7B6786B25D89EF6D07BF5941D55ECE511
C3139668ED7DCD2CC969244E312807B3A9DE2C5FA66B5853FA26AB5095B4788A3E4961BDC083
E29BE6406D622CD6768CA4C09E13D858D69F888C406D0BF2F5DEBC3388D85F7FAD07A0CDFC78
2280B8C348107CF01E384F7868612E21EEFD1127EFB6F755AA60E27308B914F7C48443BFE110
D485E96BE15B9A296985A9193DD9977B03ABA4EC0DDCCE5CA089867BE013BBC457EE0825C607
FBF49F4943994276A49C1395B9133C01E6346476A40840010398C66F59FC73CF60427E1E5F6F
28EB2243ED0530742815DC3D4E979B3DBD04D6B1CB6E1E540C220DB7A049E367E6913BF47E1C
539CDB6D926C8B90CE98DABD8C410E5B87B19B4D16AD5FFF1F1C25D950870D9AFADD67E8015E
E057F699160E9FF4E4D4D2A960D99EE55CE976B5D033D762CDBC6299FC949747F84A8D23FE47
65A7F85101AB78099183BA7836AD7D8B6D70CDF456DEBB804C7C76E2EC92D045286B88231DDB
A0EA84DAC0A85E65818FB42A05FB7883EFE36B9F8AD060FB6C7CEEB488328B2C7791E1C3D7D7
2EC238414CD6B7A3A55F2525F6B4BBDC4FC46CC0994E17F661E9EFA3F596B9827773FCA68745
F79BFB548C9DEE8628E4F0F48D0A1BF363EFEDDB2E19AB127212E6A19D317AD18E1D788A5FE9
E4AB700F5F9F8E756F2C1500748F2E0715671993D3FE4F0D71457C2C71D1653D0D9FFCA2EBE8
EEEFD33E77CF8C6D8F04D5EE64A8BF593C9F0B09DCC154820354FE1F418A86F7CD0087B5955C
122A69AE1B532C89146FA5943747D8612763DD5E7B45E62B686EDF653702B12A4B03C873B045
E6B5FBC8495C3A802A6FAB8C850765B9A3F3DED400BCDDA1CF4A0711FEC6785FD870C1E66BB5
26E8B76D7A169F21905672CA90B80C56D9F13F35391BB35ECB3560FB0ABD9C9AE955254D3933
27D3C6F73DB2C4B91AD08A3B24D1C2BFFF49202F998A37C07BACE3770E56F3C37698275FD257
9A056B934362694875587FB11B66CD444857EEDD026B1414CAC07B70391089EA62EFE9E958DB
E11834CB6730FDCEA78DE254CC18BD4FD63484EE6A1C82CF303019C9705A998DA231A35A79A2
AF26F4180974FA93008DAC31CD28AE2F1836D93066359C13B01E0521D1BC58FC18BE1E1AB697
27945792B4FF543081A6F5E168125F2DFF66555FD33C6E70485631144CB008BF4FA67C58C7A2
0B0272729A56F450FE62506768657AA7342D64AC0593155D9FDF515387D307D423B2E15353EA
25F0283C500BE626F01B612E462A778DD86C9E3892D5F066BE95DAE960017EF494E9CAA5CB5B
134D0DCA8B48A80B9EB39E7DBA362FB291BD425646A68FD61BA02EE8E7B62DECAB365D3D2669
F9562D021B182BA212FDAAE82317BB1C687BE7615FCD43A0F1118DCE0660A2D7681E080C8793
D2BB94CC61F9DFBC5DE81B281472A67AFB7F14CFACCAC382487BDB84F72B8323D55314CCA02B
D27247BFA065CCE1CC834FEEC5B1894ED312DEF25F77C84C2075F7ECB16FCD3A0BA1B93C773E
FC9AB64D307091DBE7AF5D48FA264D4C8426A142F4A40A7F96D546DD4D460201CC7E6C6231F3
F5D12186F38CBD6E817B3F95E6A51DDF50F417665FCB0B3AB47F6D568050E4CD891A95FF1BD2
1CF9B9C00C6356EA5C9606A206E1D046199F783BAAB6077536EF1193BEEBE9EE3658CD4C4FB8
7316BC32FA18F5919650046626F0A02372BF48705B20224D10DF44908E53D7660B58B171EACA
2B2F665CA740A97CD94DAE630544CB4025D1E1599A4D000A90E2CE726FB5A47816DE7691AA1C
14A5F8D92E206EE7DD39FE52747FFED89030E3578AD1958A38C876F1DF95A591CD80612AF582
6B5735B1C51CFB0662917E84C77D971A55E5A7B112E8F3B2C34AB6FEA0D11600B36F6994A8F6
F35B54164AD1571D1F3E85F35C99B1307963636D4F4B6EEB8F06D26180454FF64796A9F7075C
34B529830699DF2367842C3DF9F11E46A5DA323B48329F5389C6007C2266BD6711D4FE891B91
8DC0B4996B6C263817CF13C93E1C0F755208E317F97E34BC930ECC48F7A7C4AC1FDD7B96C1E0
E639B242D23D48C4FAC28E0B16F1B36BC520CDFD66D5481A5D1AD43E28FD7240143D1D6CDE83
22DE6BAC3A3AACC6041BB6D9C4705A02C8E75170921DAA8D61E66D99501876E67D956DC70359
C5F47D1D8F73EA26F10584207001FB5255D44017084BB2491A39963AE56CB3A42163F2F93B34
B68AA0AF3AA3A2F5C501AF422AB19B5ADEA519FB855309A8913A36C7A568EF30DDF79D9EADCE
FE0678D069F1AEC8E4851C211DB2334628CC426187904B52AA14EF00BBD45D2F414B9785BFC0
4FCC54732F6B6CD868E7FFE71BAE69387951D577C46A4B121532945519CBB0CFDD95B86D2980
2C8973EB8766D8397D61BBA307B2595E33C2BB1D2D9D3223AE12AEBF47D92770FBEAC0A589B2
D89D48136F312B3D0E78F0F9C33238D53B929DC51C2D6BA9739BF855536593D81377297D5313
82A93CB1A320D68CA5F60285336ACCE159C9539AE61A0682B81268F1191918088876C9F6B2ED
9601F580DDFFFEB10E9D25020A7F9EA325741B6DBBCF510EE805DBE14F4A7510432575088796
B78BE064A0C3B202A848F396EC269376BB010D5C5C18A254B2B2CA8CA36727471CE4B5D9C37F
9F079282FC02889E7AAD3DD57601307A4F0EE5CB8256DA8662E070350B80AA5120750F58CFC6
65072D4AF7164E301B90B6E8CF001E06AC59DCA9DA5DF73A2502F94331BDFC4969D4B2E5BABA
4DD6348C19DA9BBB550717A0C090884D25703703B4052CB296187265EC518B62BB009458DBAD
FA96FD998C9A0B51F6E9532520EE85DA3E6A54F87037D1A1C6194F45A00BE48DD3CE315BBF9E
92F80B744761298E2DB7BB96DD564722C69A93C730BE799B778B06C7638500912437389AE7C4
335CD3EA9AD0DCEAC931C6F25D5DC3B860575A096A427621B87CB0946439693801A4BDFE094D
DA468238CABC5DB7FB605C12121421F77B022DFD943FFCC1460272411BA98EA2F7F18183EC3F
BC8F823B110311356B822CE795CD7597BE4230213CD93C0E5FD0CE18B06FD548BC013FA67AAC
BDCDFEFC8B7BD2CAC34460352A2C2C4DDFA1AA7FDCE3777CA5B6C475320934B4FDD4086C99FB
E7691C561BDFF760FE12F131A2E0846BFB5374BE0F3661E3972D2724B5DEF8A25F98B1DCF4ED
AEBA902A3018A4F159C0DB9113166DC2C5F7AE8CC9C3FB45F3E9E40F2189600B0A9C17BE4F9D
0ED6E019F71D9C7BD85F715EF12D3C7B20908DD63C4B5F54C5D7E407F9874C8D167AED2575D2
D5C8529A11F8BDAABA7941F0ABA4E9FB781FE08EB82274BCFE2E9D2D88BBE0BB2473D8274F79
1258DA6DE7CBB7B6F9E17DA3B363577FDFB31DA7A9F4E5738974131C1D5EE0369178FEA662C4
6919350E94DDC6603F321F79AC737B3124D94FCDCEDED2FB1255812A959852DB61FDD2B41FDE
0C00DBA6DDA8BA70247A824308BD8A6BB40F90E355D458EEFC8B5AA77705686B445A9D8E1FF0
FD22D619C10081D4A6CB78F706F5EF5B23E2943179E16883CD780B1C9FC0D0738C7423F6871F
AAEAB508403D2578C08891F8507A97CF69A0788108BE671F88E2E63AF40275467EFB825E9053
438601E8B20B8B484CF0068CAB4F7A83BF894F2FE6411F6A3577F9726403FEE8EBED717D3012
BAD6A9975AFF269F7EE3C0FCAD173C26F96ECD1A84A286D219D2D6E07E867CDA509224D4B2B6
873127EFFBE777A8452F30D6B637DD8F36A0596DEB84C8E63CB59DCF8924BA04C96DA93C5541
9BB7949EBE84B4745233B589ECD5EF9B0A250A4EB612D10C02D7689A027D6D27B5608CF48443
FC925288540A4ED37924F7DB4DB49FAF191265AFEC34CE8956174B336AC8EA4235F695EFC597
1E57F7A2A92472DE33552F4B33033EB5499AF3C4279BF1F8BFE398AE661E36FBDF1817AABFEB
A44207B974E2856B3D79B5EAD9DA5377D240C60E8D137D57013933C9A0ACEC699A46B616B60B
FCC22E3C015BA8C46D7E83B2BDA1D54E3033AE6FF01291C360E79DDB1DB64E6AD159451FB5E1
7ECD98D15F2C9FD8FAA7CCC2EBFE03653468A6D1F4E563A7FA3AF83D17EB47204076BA86C5F3
1B534E7B1B6147F13FB741554606BC43DDE356D48E4C950A771849726949D36DDECE56CD656C
E311DD21D8425FB9BD8BDFC9E213992FC2131C7B55B6145E1D4681B44E3B1EBC6B63FAA03F86
E7394213946CB4F202E0F93071E661E52C15D4BB7C4B49D85BDA576AF020DE316757FC5C8072
FD6AE19F03CC5CAB7A39B5E17C40629B579D15F4B633A1A306B5E40D1550F1147886E8B3C445
DC2EC4673234310514E9A15E97B1CDAF415C89A7436888997AA1F5F9A51AAB45D1F8B1F278E9
85F28C689814752598DE9A220C46AE7EBAA1EACCEB296C261F2C9BE0BAEE52AF307AE2FD89BF
2F84A4F5CF57DE4BEBB4A91CF62254D71E7EF4EE530AE2465A7C0DAAE81738A0EEB9A061ECC1
83D318859CA1E22DD25F2F96CA715956DEFC984839467AE9E7493BFBD651E5522E33C763A5CD
041C0CE14D58E11909DA69319AE1AEA4C71DF51C6877DBDAED09DA6C34F10F8DD0C0A66E9EBD
AC9F97ADD26113519A060396A3A6D7F7C86BC520FEF44AF23751D420D3B7CDF4420F1FBFD321
A472429FEA9E20C0FECBD29426644F7181444C702F877E8834C5839FB8AD0C08F92FFFD78AA0
A6AAC0D6629F665066CD54E8D221CB8D394B4CD75ABE5574961329B636139037B0A0B3CF3CB3
FA1AF53FD639049E5DA8C7AD8234E87AC1E35AE1E8E49933EA8A4CBF91F7B8E3AC3CF48CDBD6
7B3F11C35247C5F58D14B1BA8A637B6E49A9761D8374E71F41100527C0E5B5E926F3583E5423
A588166C636F45B707AD0C4CB3D775819A6680401B581AB1F023C55C8DB94FF2BB9F064A4EBC
184B143B662EA5F8A3E0DB5FD32DDF7EF3DB5CC958212614F446451FFE2455AAC1006792F4DB
11C48683E471DF4E2CA930B115D455ACD3E2942540AF2D43E3AF523447EECAD71EEC88A8BF9E
7670E7D50C136415E1C3315EF054D42B20314BD32FA0813026F273D98423D661C6177AB3CC0F
A7F56885C5C8E5ACA94F9A8B541B8D8497B734B38D846C5A3C082D088747DA0769BC0B5BB0F7
E87698748E91E05D624D87923185D36E86BD503D82A9FAEA6CA0D99D90832B11B73BC4E75B76
9B1946F214CC7C68DE30D70D4D37277D1DBED0C3ED26388FA24946B0CFAC1FB1F3A1F581C3D8
58F89075DAD670FEC247BC0256917D753373654FD5CCF9B91AE8205D30881AD34BDE8709150C
8871793541982CFF0A03FF875A1952C30DCA36B6E567D548F460108D14C854187F7AD8FDC65B
741353C7C0E607BEEE19A177F3F9F8E4F95E2AC08A768652379CE6390A1B0489A73EC576F970
76C8A489EC20F8515A99EEF11FEA8717A1C879073791463C9B8F40673657E486A0A4255FFCB5
86C16F22978A4A38B3821F24859CE41E269024ED673DEE867EB082664A9612C81F22B713DA34
8271387A50E8522AAAF811465193AE4192F032E93038AB172C07257470E751B7A5C77089CA43
45BC3437327A22A8D41E724072418D1222F6FC21266B13D93BB261B75D483508B872A7E4456B
94CD472A20D2C071967EF16F6F36A1640F7456E686EAA7086FF9BC0DC1A72C7C39C49EF2030D
4955A81BCC41F3AF054E9A2248E536C1F1ABECF242D0D19181C43C10099850E6531DD97B00BA
3FB3560A4A6A50FDA30FE3DFE02AC15904F5D2DEED51BB751283508FA1C2F97FD769F3BF57CF
BBD494D180ED0F941BC6F99472A3CFE4ADED07E2C6AB931FE15D435680282CAC2FEF934A5744
F523D37F385C50091F8D867A8D41B56D94CB9938347D32B58E2FA3B6B740A318FDEB1FE60E76
C0C379D43CFFF2E73E26542052EE0BBC1BCF8A42280F2E64B004005938DB71F3421199BEC6AC
5A422553224624B15E7D3FDEBA77277A420E0EADF80235820ADFF26B2905A684E5F49A9801A9
AB30F9922784F025974E59812FCC3724119598576E3531E955B2A565258C16CC146FD808451D
88DA5D6CE7E92EB27D4CE622F9737F224BBD727ECBF78B74F8092F17005FCCA4B5623B10FFCF
07522DCFD5D9B57E3231F44AC61BC55F86AE7753684564EE6683E192112F52AA024089FE2676
CA185DFE4729E0F0E31D90404BE74C3C8151579AE118DE4BE71CE5FEF14747CE412EB5309613
B04E6F02D29BEACCC60954F53AF77BA9A3802F48322208BCF80D875D69CD84D1DF366ABC6EC1
8C07F4745E6C84FE1A51EF13D7CC53A10C007B8705B10EA34960D5E873CC667CF7451DB00446
B81E7F329D7E8CBD7D23D40959EE96BD1902AA255F96EF572733B17F890B08FA29B81D4CEF61
1E0E1747B4D4AD31E7B1B9BC014C39608658115BECB4C46397A45542AA6AA1830471F7352F42
C46B61420CABE23CFB49EFF7BD781969CC03B2A0A7C204A207A4B91BA03BCB72A33F811E9C04
54B43D181EE7202B0CCA9F3AAFA34EEA0E9CB758E6430FAF8D45FED0386E8E024D2EEB54DED8
A99AB0128DEE8056AE4030C033DCEDAA6EF96EC17D5D7D4340A045B432DCA415128764AFB76D
1971E3718B8C17648BD7686B9F2E55795BBEC4FA04C1005FC0C2F23BFFBD7248CF64312DAF7E
D0ABAD921A61C9E2ACEDC0724FE21A4A4E73739C7E7C313262724251E9120643ADA7EF1C9933
B79AEACB2A511685409B9EE90EBFDD32A23B7D4747E616AA68C3A30BA0266D71354C131043A1
8917FA12DF66CC887BE9FD75CA4E844232CEAC72466EADD5CCA691F35AE5FAB58101F04E7CDA
F5E3E68474A853508DD5B620F5325A630D3886D35E9A4F100DBAF9FF58846FF8199D22AAA0DC
D4A02CE62D05CC2AB92EF86035E2BC7DCAD0A56615F0DDB448DA20F8874A5D2031D4386359F1
1E9F8E3341B3767FE5D5C16B90199512A2A1ECC59706D6C8331CDD55FD0FA6D254C6A42E1359
7C0774684F19A49B7021B58F6B371F182C7E3FE4F4251B9814D5154767AF298CDE355BDA6F9A
5492A7D52A106A2B08485D4CB6473B501C9B1777CE6EADF1968F6030D5331122AE5691DF6742
BF205996FFB7CE6F9CC74D3FEA8D1DC20C3699F057090A2E6727B46090558FB8E33DBE846CEC
90E1057C2591D3396BA6D5F676C3FD75EBAD028963EF55EFEEAD7404CB9CA50982DF11CE5AE2
E4BF0F52F2ABA5D469371E94FA5C479E2469C357DB908C9B3A12A17DCF67F51B8838B7031584
9CE1ACF01EDEE63E0FA50E68D15E06CD47AAD7D78BF50075C062C23771B44C7C01773209764D
811E8B8C0284AACB0DC37011106D6279D7B4A457300293DD39F1BF4D57B1C0EACDA30451E6A8
67D781EA70275E2B6685B51FFD74F5622FCC09608450E13DD5BFF4B11B50A7186038FB04B8E4
0A6B3EAA4A69BBDF6C2E951E77B2B1129260E4C5EACBF741AB5A68051F894E0C4607B562CC71
445C0D55F46B5DDE05966DC228DD3BE3462C4E81DBEE2C34410BA015EF4E4AD993574CABF780
1698322987B7EDA100128DDE1EA980E824772CBAB746BE0CB5D43A30A0CD4830A783026356D2
95302173DC6E3282E422DDCC3F7857FEA1CD7313354A919C36D5E81D783409F1F602A63B094E
C29DD99D27988DB6416EF1CFB37ADC2A22EA9ECFFF1C2A6D15E17416053CB0BE908B3F6AF8EC
EF68FB64D510F1A366C5314B7D4C92F7B108A593684A7FE1DC575A618F006DEB5C0F9128E185
E9010BFDCF803B1193D63E81C0FF8811CF18F692E9851EFC28CAC4F4C6DD45AE0913CCBDD905
B1AD4B4E6200FBC2ADFA8A28E02221FFF8C6C4B98EBBBB617E086BDEB8B1AC5A48BC418DF8FE
41B0B587AD17AC5ED8A2561266388ADF732E70B03C825127395552397BFF75EF2C89DB0153AF
BD249C395F2F4BF8EACE70FB81BB924A924A57E7D78891277EECE778C1A0A5D7778EE2C9302B
F72A9F788BE31218FB849EF41CB44E3DB4CA67F38830A566B50D326484C68D95DD95E7D355C6
2114C37B5209CAC04510C13A9A08655A61FCF62FA373BE7359F814A83E611E4A9A780F6A059B
91830B2F5B30399F599C8DB49A13BE81BFAB6FDC5B1D1F36B5A74B4B96D20662D785EE14B62A
44532EAD210CBA94EBE90B5057C674F45FFA4C39310B4471AAE8A10FA6F8EDBFBF6575B9B288
E9FB35BE95820FE75D8C59676453E34E88854F15F85C4267D7E87ED612EA1DD52202AF3EDB3F
87DA87FAAA488E938554E3AF76481A34AB075185F81DFE57EE31D9E1EEE5019419CF4451AD93
C5B46D4AA1AC6DFD8A7C944BFCAC0243ABC933B63EC435528BB475284CB800B7082AE53F2A11
6DE83DE31DF5481400F10A351145404582E007A00C73CDB82DAC20D828720124B805CD29CD08
C08413DCCF6E62079B514F79E7DB2356A7F3D5ED21824740C975778906B1EB3F73845E54A472
4326C95B80B2D9AD260844AF04DDCC523410808B276E924248F50778937AB78C493E6DD2200C
B109ECDCFFF7493A4B63F6D7C20546010A699CF8193AFC1DDDA20FB7371F4FD2AACBCAF06C73
7EC79C2D7A9D22A535E932E3ECC745A20D63FB93ED110AE4DADC072A758F18A351754A34A9A0
4FE68AC35B86842B377BDA4A071563830FA042A2E95CFD32C168E4B64B0E67E25FD30CA8673E
BDA9B0F7BFEF8FF101EFD0797B8A852D8F0FC1C51DC550A44022521A8F2E4A07528D7DC8B205
391A105843A0312E4DB11E4693E34075A21417C3D31A1F8DFF1E28D92427FB2B167AE0DBFBC9
2F08C64404A2A8F764D2DE79B984380321C32CB1793389D357791143B016E153400DFDE01CBC
395FDCF47917A08D624EBB187A6DA5B2478C75AA03FD6D1DEB33D473A691D044A6C5AA4D2D30
2E341E13852B57710E22F1F98824AF732D1C068E0E3B0EB55785A8BE7799E3ABDFB0625418D5
B23D1BA19F0794B8E81AE160C14D8E9BB5ECC276C7E3A123DE7577BDF0D4D163C4E8E78DF34A
540069CC15AFE9154D847A7B627CB53CB5864262D1C4BA055916788E22C6E8676ED87E28770C
66788B054193F3DB37A0602CE3D731CBBE79C5629A079867EC24FFA8D862E085A74B1FF862BB
6B63D1CFB2974635C145F7579B109D7FDF3486D220F296B35596C949DF388B7C3F187997B050
2507845DBAFF8828E110297405D8A395C2ED64834D14C5D569978DF15772ECE7DFF14700447F
85B7C95D866F08A99EAFD0E881574A4A09A823C9E40810CCCB8114F1E2CD5F572E0EBC31FB3E
499A66BA57BB6209C37DBC0C7FC199631D204F2F3397A6CA48F9C70B5AD25EACC9AE031CCDCA
4A6F559DD13D9F3D2F08D5BF60564D19CA1B5096101BE878DF538AA8697DE536B5D204C410AE
CADB2CD49B91820C69050F73601BF558C60F2CEFE6D2F4F08FD40640109187ECF8F9A550062F
1B43D5D281F9AFF42818E3AA52FAE15EA7DABB0B56347199EC50DDE1D0EFEC21D3C05D6686D4
AE2DB4742B128405AD67A93571BCDC435137181DE079C6BE4679A0E500C283838DC4E0E4DE29
F5C802C9510519DD34DCC0430902C41107A04712B255596EA3717B37458DDED00E7EFB410F56
D26501C4EBE49BFA72643E9DBB8A27B1310BC55230971960DA2B493C1F5A05A816955C2A0069
250D35BDA1657957E5EE51FF2BC3DF22194AA4158DFD3484DBE3F59AE8C67DA9B3427D1B34CD
1E45364E0A16140BC4C097A8745D4E34F20E40C33885D10F2BC4321030752BF6620DC6D4B34B
37DDB49E105300BB728EC77E3F1708C120A71E39C133C0C1DA3BF366AB1C329D5F9C0ABBE1F1
7158BACA43E79238D73075B4D0B4EDA1D7252E98AE9EC1020A970681369010A11CD34AA954C1
41B1F87982D377EE3236EF359635721B5083676382195EA0226236ECF321B1A3DD14943512EF
9AD912868AFCF711CA1B7D6A839286C86FD11D060775F754484963D761CFA2039F386C2C80C7
8B1A5B28992CCB069323C62F29043AE6836087BE32D4A143AECE16CEB06866D10C90645E5ADF
2EC56EA7C664532015AFE96F77E2C7994345F95316414BE7172EA71B52719B267F378826BAA8
D0696094385B3776CFBDD2A8232B54D369483D0B79477D4699028A60813EC9E7FFE3DFD7B2CF
3667AF9AAF2A7C9DAB9700469913187EF257E3AD647A13A2C20F7A5C026FD8748D4609A18F96
0A5ECFD7FFF8CC5C6D990C7350235CCBCF89CBE4BC1C286A88798B3CE2D0712571D85E0D266B
4019CB767B7E51BDCF2F1ECA7CD1A94B88200DCDDBA00019EE8C853C5123BB66411230ACD8CF
E07D7C8500F12DB5699A9720F0E2A7491EE2356DD6B9047CACC11275275C2579F214346DAD18
73F9B82EBC0A13564A374DEE740FA0478DE6631F2C35B67A5A22A2D4AC6880CF30D24035A117
207B19140E787BAEE865152DB5A8CB27DB323EE21DA6B9DE876EBCC0A7B9A7D6EFD0635F0DB5
DB76C06481AB424AE0C85FFFB5E3F278D94454B1FB5BC01215C4FAE48BCAE3A3535CC760B13F
5EA1788B821ECE4472DB0CD1D595B64CDCFABEBD85CCFE880DCC704845486A7DC2215E9F98B7
7092A4248FDCA3877BA9B251D0388261779050875B45A0D8677E84E5F61527559763D63F18D1
437B8871D0640D0ACC034D1E19A53FF09A5C88339AD3939C85EFDE47A5FD60C1F426292125DF
A286429F4E5145532ADDB90527A50557D24366F26F465C3C96E2B625DAA5BD8E938C0130B503
2090FF7576B700C7DC64D2269590193F127D9D705138795DFB26FEEB0690957A0DA714FA3A3F
3B93A3388ABD692B7CAFE01B4797865D982BDF1CC19CF6CAC93EAB812FA7FC559A7E5D7696FB
A56AF3073F3C1A75A7A732224C70029EC82A46D84014B8887FD74EC9D48C1AD9B6763ADC4E9C
2F85B7741818D6C2951FEEAE950910DC837D475234BC506503A009A405782653CD4866F4BA25
24CA63FB4187B325193D8E89A5FF3F31FD489FBF8B47D52F95F9B74D64DAF4354959C585B099
B887ADB187D52F7EB824BA6F74F3350654E0DC2ECB413683A5A47D63F863935D0468FCD92B01
C57DD3F351453002F38F576C8C9241BF2CB50D17B57064A36E9F7225B5BFD391305B8E6B0207
6C598C19D43E9E3B464BC5979C5BDCF8B65294E79C8B9A903B01000623872D92B8B3F78645A6
8F72285FB225A537862D49AD89AE22DF0F865B6A1C83D046978D264606AB3F69877DCB72AC03
0BA2782105C6C1540DA263AA8CB8EFD5D7DFE12D82E9ADBB0CBA782A84201A5C09668999B4E7
78EDD0C693D30787C565B679AAD97056AD9EA1D2B2724322F2AA036815B0379443D84299F1AD
4CE9C3444602B572B7CCEAD79322507264F3F548A56F4019CE1BF70654F87EE3CD72C9A33AC1
87B3CE7EA2910AF779658E392A83676DD6C8467A6E556C21B2BF1D284B41CEEEA6EB43D1B87A
6917918D9F82C96A46391DB2A591D0418E2189C8CC9EF303E3131575D6EA70FA70C04002564A
C212186D7FFD78C437EA5959505C53B351E8873A4D7DCC4DF1FD922C8BDAE2356F81DAB76F07
6FE4F73B3276CCC3497CA743256E0EE57167AB4749FA06084D7EAD855F332E90074416BDFC53
C449749B488273B65FBBB8FAAC2B105829DFA0109CAEFB9D60C809EC2871AAA88A29DB1D216B
F9A15948BEFA0E9845DF48F909043C5853E0321C5ADDA1049827EF3009D6CFF280278BAADE7B
F33A8FE09CE278081D4DFE8AEDBE239B71C45513F03A34B24979AD1352DB7B51DEBBA3416D7E
41C0D63FB52E7A8758D52D0E6BFA80A4CFAB27DC22BB75E554A0EABB2FA6DDBCE846DA832132
86369241FA9A00C57D7BBA7D0D9888C39E3C84AD7A54C58B7FAE61E689CEF1130765ABEF343B
CB10C72DB2338340368899069F6215F78DF65E5A5916507656F857301B76A5E31158C2E1C2D7
B22FC5C9F5A9F376CFDFBA887636A30BE3DE129EAB0771AE8C950ABC35AA5DC548CECF7B6CA1
0E80597CED57D450948BE352B723B3C76CCEB52B87F20A72BFEED223A5330DD47824E415F327
1063A7C6C3BB331AECA6F7B7F79960D32328844D98101B5A352B0836A23958488FFEF31B7BB8
417811D5554AFDD659F4CD6A87B9985FBA0D92E6BC67336D8D2CF3E2299D92739AFFE53C16E9
A7842BEA06C70B5CA9BDA4B9BF51F79BEAC61DC0B7AD89A7E97A1867B1E7D3E6184DB69CE292
45E0A16AB248F9CD732D9E973996C651A6A7B12E15624347E2C38BD3E0E7090F3ED8F3521515
FC1AF7E133360A55C792BE736B7180F63002DD956B66DDC9D43486DFFB1D068E62B1543A9ABA
97BE61C97756DC919B54E31145BC7CCF9AAD8BF16577D784933D3F1940E2249ADCFBC49893D4
FE29833A5BBD96434A4F7BF540283AD314DDB1F6CF5707D74B7ED0A9009CD3352E354E9F90FB
1EE33DB6F900182F58C8FD31CA8703CC17F80D635AB97F45CC4AB4A5E6D19DFA3297D2C363F5
AC561B8BC9893079E41128D43AB1B2097DED7E3E11A49B61542F81545FE6BA75DF43FACBF6B0
896F1BBD1ADBA60FB307BD431D4866ED3CB1745B9F448CB56D60D43E8C8BA945966C0C96A9E5
F082E727ED8AF0BD6FDF6D81B3ED7AA7109E0D10DE0F12D0765B2D3E2804A6BA4E84B225A8A5
309C27E101DEC9C3EAD81E24FCA75A55B0DAC70F1B96CDB02A52FFFDB3E96B77AC2C6DCEE891
B31071E657E8D40B40C0D620EDCE805A79837ED641C77399874B676169E8D1A6DFBF4C82F8CA
1C160E1E3E97AB91EDC1DC4B9219951CF8AF5E21C705F5AD68C78C4C2FEDD3E39F711F63618A
A5D3D9121FB26C2DBD31C90AACD5BFB536B2CAC6BCB955445EFB41AF5178C21ECB0ED54F252B
561EBD024D1F73B299910EE6229FB7C53F17C5CF2447B09ABF8AE492508E865F8D6BF766E0EF
E2CFE96A64CBAED09C1B0CC85B27333056560C55438755D2C3D3703DA00A52A2709962653B42
BF487F2F35581E7C5D3F89D144CDCB2E067872FD20F2EE1D8315A8D36491D2908EB250502CEB
1F32C76F7E4F9C7B4A76A12D0CA2B708A35589D8E64A6FF9E0C420D2ABC037A3CA70BF37EC48
2DC58D386871D8A3644B92FFD0334E2A500424CDE6923730FE9533D85539E646A3CCCF89247B
02E5DB75B1E8815F0707126A27BA073A6A1EE5007A7CBCD742C137E56C1BFA5FC466A57C3D29
5CE7667BC75DB634EB721F37B62D3D1BF8537CFC643F8140D152EE2A49FEEFB03F10A0E86D78
FF5E8B0CF112675EBA3C411ADCAC4B4AB626988BEDA40C978DD940497193F4E4EB75CCAA8BFE
127F0FDA31ACE926EDDB4AAFE7719AEF234A20E79C5EA5E26E3709344DAB7A279EDC5853235B
2DC1757CC348C73F394A742BCFFEF1EFB482398A0B735BEDE920FE6A0787E97E90443C692249
430BFCBD1399D1D881F75D375760808715653040AE5348BF276A07B94B08EB812FC0F3DD281D
782CFD438C700B0A737D89F21C53911A13427B71E5A259C9846DAF077BC895F8436BDAADD15A
DF0F368FA3743ED4EA226F3F70FB2E1C85F0875F1F826ECD6360B77174A3B259BC8EB7918445
019078CB42FC6EDD915B640916E6D4C8F0FB6165162F42F9FF63B1F5AC637BC9F8FB6BD0AFB6
B23463632D4D1B03CE1222029E79C7DD52710F449A68F473CC5D7DB00F74366060F94590B3C5
F28884A9F65E0B3D793A5A7E799B4336FB549B59325646BE99C798745310AE13852CB23C6352
0F1923E01067AA46B13B22DC4CD1830D96B62A33BDD3D2EC47E062950D14AB114A5A7823CBB8
681E50B376F9F999585AC097C444FEE480E10BC754324C1536F0BD662EE1500E4098950F2B21
1FC54202F199A36B7DCA2A6E1C0F53DC7335876F57D22AE2F95CB366F228A8D9B8926737014D
5F8586D0FEE36122B9BAA82B84E70D3DE614709EBAB636E9EE15AB1063C36F995719802AD688
5C3006EF58EE8FB5E592F34C93E496E002707CD95CEB2A0A44E5C19CBB3EB37BE14BFEA4D1C8
0335DBCEC4A4A369C190B2875BEA76F3DAFCA9AA1A84008F57483134CF03AA0F9F1067510D5B
666F712D980D09D77E7F6EDBCEDE845886A8272F3BC147147A3752A71C781BD5742EE28F506A
E723D85084EDF1E0453586C5740DCEC131405F15806B6C10E6713757FA499BD0DE1C8040C9FC
8D236B3F8EE923637CC80EB3F4ADDE8CEC206EA1863462F59ED8AA12FF9CB66166F8735ACEF9
1D45C8CE6D8549D13763A2B4094931CB58D762AAD8B8B17F947D962F3617135AF990EB92882E
380F5E57B649D6FCDA9534BEC18BCD5FB1697C5186C4BA1659A217A68038390CEE66661BD9BD
7F46E1052089364D51F32CD811EBECED46CE5B100578A18B791DFE09AAD47A8B226185D76571
FC9E26BEC7F9FDBB7B421551BBAFBC3D91215EB4A54C5590D7A0295E6D77F7757874D2E2B602
8AEADBCBA07994B38B6919B6BDE51326BC9942F4B4A869F82B123FFA48645D34FB46471C85DF
2652A426C2B34F1817A5D4B8DDD32E7BE7BC87444C9320BACD183FAACA0F4105E74796E1A464
2981460E4A410D2B637B7EB9C5D71642FAE3C8A0A4B655E6B2E29CBF3910CDBD8FCEC696A68E
C60B836B1B1855BCDEF07F943CE989A8D44A0354B61BDAA812450BF2F0107AC8FD56A106BAA3
6D50EBED7ACC1CF95EC31CC58714F6AA169915760432D5689E87876CD4359A51FC64500F2852
6D5BC8728D56DC8145A80C01D95FB2BDB488EF6FAD902277D05785FC206398EEE20A5DE4EEA1
31D66861879A3B0807F2BC2145A7DFF0BEB0759C59A2CB5645DE85219D209893EB9C4B3BE0B6
AD6A3012BCA798D70C59352A52FFF2631E413AC0B86158127D0600065AEFCBE97992B712A43C
C6E070352CF2CCE3FFB5D2E72DC8D43CA1DFCB4DA9DC20878CAC97E4A8BC33A8146D1C8C04DC
E2DC2FF829AFAB4923D1F7D115F198323E88A8E556F1D29D09F5B5045567729C5EA5CF0DFF71
972EDB185CC3B5C4EA78A3D59E50708C1A0DF7E0C33439848FCE0568BD02DE842ABFE603D39B
8C0FE6C6448EF7F7E03B4AD658A03375263399558B59DD3D08D80DBC657DBDB57F257E116FB0
4DBEF3C652787DBAB354FBCB62F90A0A80A6ABD1F68E3598D71EC3516F7A1ACB2DA775163006
3780E34124BBB468A299253A234D466657415C8EAAB228BCC2BFB61AC3F42DC619A63BAC3DF2
A7B624848168F98CE5938C38B77EAD4262E4F0828F05B9048CC70994F1C7940C49F70A867B41
421D64E85CED0A19200F641D19AEB00A9298E5CE1BBE086212600EA1C6352A6FE9B1619FA015
75B5353443F150B630417439CF0CD20C9B265257AEDDF34972570D18C8783930B35A6987F06A
17F2D4C93F90AB6CCC6B1A9EB6DD1A51C46F4BF433FC4E8735E084376C90E0E1E106D3291910
1BA1E963E81A88FA6A0CC2A6434CEA8A353CEA0E8D233C5FB8FF8654CBB1209C1A54FDCC7886
369CA1428EB2B04A266541CF4C2129995EAB1E62182435EF1BE3BBA0F937ABE3388A61A23523
49E2F727247529083F7FE869730E5F58F0A2FC0CF124F0D5EA6ABE08174F46E13D6B001A8377
CE94EC180F0B3BFE56088C228FDCD268A79AEDE027B5BAA241C8057720E0D2B44E7A0651897D
46C752CF12677A768E247EAA3658B8AD58435BB40066E1B216A050A69E42BF797A0233BA74EA
1DEE78804503A007EAD8C24101C4751CD14DB68C220486162DD0464E39F760C12BAEB9BECBEE
483C77DB553524BB456B05780C3CA8CCC4E6D8E8802CC15BBF90F5D16E2238499B3DE03144B3
525603FBEE64EA64A2D39E1328F7F83035352BD0F04BB7A05159EBF93AF362AB334EAA312FD7
7D8251E10A041F89603AFB76B55C1042EC49AE6AA33F13BCC3393C6A5A318AF8C759CCB7B009
59731AD457A27106FEDDC21AED026CCB73363B1FEB14C8472F94972E66983911FED02AF3341F
50DEF2ED2B9F20C1025FDA3D3F34E88F59E9D45C16059D4EB4C71B2497D331F98A1245922BF5
AD97CCF16AE5BBB53A53620532594158208840CFCCFD88FA56566C434C9D24B0501D78184220
255E2DDCBC000FF424969E7EF801E49642A1EED7CD2BC2709887B59C49B69BBD661D38D8291F
5649AA863B5DDB2559D1FBEA22F2A43B6DE831D23F9D6F76BAD56BA1FCA0370F92C56ED71B83
9AA7C67B5A26C9769DD7FF847B02210AEDB5CE48F7BC7D214F5FE01A20AF3E975698DC5BAE40
321EB2E8DD8D1359D75B2888E4E2092F7F10D5FFE858F614F43EAB8C38AD829CF8B6E271B4FF
9A4A34F9EBE4516CB0DA1B4661E7E474B1BC32ED18FA1E69FEF95E73D2B3610CC0B79245D840
D9B9C65865DF4314445E30D498856750FFD56D4AA6AC7B92C1C33DA3095D82812A4467AE8814
35759ACCF2BD2553CFE8FCA6A6CD8A7A02F06E64970690D59AD25E1E11A4793BE0F06B47991F
B740781970535319E8433A1A5AB85C7A47894BD8FDE30B40064F3A12E3F292DB637987E8E672
F486552400614B1280D38FD5139C059E201D689BABCEC9C13853DBB1F143FD2E60F61FF2AC84
27A3DA758A56FD5741052725F44BC9F45283BE136B4623CF542CDDFC799ACB255D655E88CC6C
23EE318972B073A77988BB039BC6DEB1AFE073DF479F7DA7FDA8D800DAF630E62C03337C3CC9
89A11809A213269C61A1577002A1CF3257BEF7525C94A66571EDB56CF3762CC0384AA222B3A6
A208430002E3E83FF1B4963927C8E5C094B4B42FFFEE0D450296C12C58A9550DF976668DA2E7
661A669889FCF72563587A7399BC85942A5DAD74207F8E1C952CF83F934938FF9E81ACFE7292
67AA6994C385699B4AFC47EFBF5982F09A2C7AE4B40BF6DA3815B7068AA78B52F30E9A7A6ACA
BD3A95A30548AABBD1E9EA39C0E382DAFD2AE525F7B89D6F966CA75C0F88FF99BD2AA60AEF8A
460BC4EB4FFE0DF9E00695AA14511B66E1B69367BC4ED92B691EDBBBA72C0CC0753C69452244
8FB091BE89F5C515B9BD28F7B689F9691633219424F88AA5CA3C7D2E568C9800B947073F7652
B3A27040AD091CCC655729303AA3E1BC2EFCA4698DEF7DA555785039DE58BB4387707FF77534
86EBF81FB0B664E1DF28725D838299492E889CB9AFF5EC1A2A46314224AC3CB24091AE2B5ED4
4466C4C70582CE9D077FD95AA9FE057809F9C09828E4D705402BF63B4E92FBABE718440F9AC6
20FF784E9CE960E81B274C44781BF9054929892A28B59AE3CBCED7E64C28808AF8FFA3080C0A
2011DE991EA261CBF36EA76E5BE8C7B432A0DDEF4158014C558C9F03A74FB5BF11F6FF037971
6BFA2EB2E0C4A28C42AD81771D7A67D2FEE1C737905FF6DA4939E6DD1A6E41F65D172FE71484
B1232F1E2B8EE5E0D2B958685FCE94FEA2CBAD2FA13408577918360CF036B13800ED8B475290
C2E9D394A60B2A136A64F31C3B294E1FACCC3B6AFD151258271F2D5CABD28C0999D71BF8873C
22034720BAA543A35EA99E2EDADD822CDA58697A58FB77EBA9A4C181F2A46746E79DA835D4B7
C560D3CC7758199C699029B83E25D4EB0846F93C4400A8E360622B8768E038D2861F781AF45D
5552082D1A48145C501AFC9D6027EF1D6903594B35E8D54233D2F2E4E3D1ADFCE09652D1B62D
BC472962062E4E3F7552EF1BF31F2DDE6C217DDE12FD88A07D6467B651759F553D954AD256E2
043363C7ED496E46A5643DA4DF5993659181F833278EB683A514DF056CA2FC1A20F2FD089CAE
EE5CDEEC2D0450FE2FF9D7CC4E1F885FD2E2BBA5D52E7904EEE6D511839263935CD890668523
935C7B5053DDDE366DB1CE03803F7856B8EE98DD237F76B88C000C055184E6B6EF7E209A1B48
D855EA6CBD8E1B9599DC2501FA8A4B8A0B6E4FB4CB307C099C3845590D8F20C965CE0A468186
2E64A38354634F881069FE80488D8428D3595D0F745D2FEF481D5C4319487F084144958EA253
8D142199F8920C96B3A99446E31CE998106185BB9325794E79C369CDD67CC39B7F36D5CB6C2A
C93CB1B71E06B2BA21134B4957DD0CA167A7C37708A42D3556E3DCE1562DA3A5BDF9246DCD70
197F05A25E0AC99343E7E7C80C5BB57DF64454F82008A830084C6AAB36BCE12036257FB3C582
AAF5E281119468A71CE9585BC8973374C166153CD954EFF9C5E2FAEC356A0035F5949D1B738C
DD3DF2A43782E081860DE635236C170C9771B52A5C309827F0559410893D05A05A1E1BFABEDC
084058463CE65496D8A998695EF3FF575F067521249231644AD5A95A7004C772ACBC7A0A254B
B3D50BD32A0F6238C05425924A864D3CFCDF6FEE0E68BBA124D07CB08D42623355AF292D167D
37D46C9DDEBA271C4C54DB9BDE673EFEAAA97A46575909F4057F870D3688C88F643350F1E778
D061643392B20EA758E590C33CC965941A836BBEE4B06A23141CEA9C7C64EDDC10DC612AC0F3
AD2D89D7DDF369940E6C910EDA8022A80BB31B3B3023CAF752F4C155B3A50D0B277D4D03D5A8
4AA16C3BE0CA4D582F405B9C2D6E55185B88B4E3D28C9F908DFE218794C6D9908C45D1EC42F0
AB0F2C5FACDC615B3CE6D39A39F545303671AF701E62BBB30F37F4E7B0380B4103EB821BAB78
66A0FE3703E0ADF3A5EB4FEC7B294171BFD90D2B5B35B76CB571FCA775D3D7F13D314EECD70A
0DE1D01AFEEE7913FAE526516F49FB1B92D4AA86156720ADDCE44E689F2515DC9209A0828D41
866275E10F09AC7AF538DF190D74D14A3D7CC4B684A2ABBE3BD97654880EA8D3432300DA4D8A
3DE58B128C6481963DA2977A3F05688F05C457F794F20E9B55F828FE367FBA4E985AED98241B
FEEB9F92B07B96B34838E6F01FF4D3ECC7B71380B665B84D95D389B0D886FFFBC64CB5759274
2C87BD0061C722FA7739A6F74A4A0B70E0CBD6D10588F25D3D98DD12C1184C193CE61647668F
E09228C20C1CE77414FDF50C09DC14B37A66AACD3CB4025A2E7986A6F2214DCCD7E8B88D3C9C
233F1B2FCFDC493678C9BAB4C9207EEB4A9902E71D9D27CA3DC8B965A4F7DA7DF43A5D363E85
72B9BEEBAAB9534844F486A4CAC0579335743413E1828F7906CC50AD961D96E22DC01392F173
EEFE070CAB321A40E450213AC24898320647ACB177FDD75B01D9B7B2EF0969EE51F22CB4CC2B
8F7A019A492AFBF763AA34B34A23D679293696A2C09AEEB8D276848BD72FA5936A774EF53CD6
63B80C74B0B34830EBEE2750520A463D15B57F161E65EDD67A5E31E9EA7F7ACAAECBFC5871DE
7BD204CB088F3DE9B37FC284E5053AD2DEFC93BB529F39613C86A8E034E65F718413392830D6
9E97C0E9BE97EB57E2D2C3F2ABCFE7DF8886DA980BB4F080B8CA92C9FF2E39EAC22A6A9F78A9
9D6E93E90A480C1E6D7FD0D55C596E4AEC3C6F94B447DE94246C1BCDC9A87F7E5CC9A458B301
4500EE12A7AC57C05761C816DA411D5924BF7E91177C4BC36AED80211F7D8C5CA8A6D03B96D9
931193F461BA6173E1B8B101B134AB4B480332F17C8994C2DF738026652B2A2E079F07493F15
B9891849FD431E765624EB3E1F34911DAFEC398E3019F573B8155CA4A58C1541AEF789E73417
08919D8C82013AC478CC292AE15A2C3AEA9A912194D5AA1434BDEC98568210D1FD5FEB08032C
92ED423427FD1CBE5EE21BB5DFD817A83A9C1FB8D163063C89736F3B3C1215584389562937C9
67A27C80EAE5699F1EA1114655861CFBED4A5D0245FD305ED3B059028D1EF8A98E5765FBC8AC
E111B8AD07CD2BACAF0921972B11A71C2A2615927742F5A02F50CFD22AAB61D03EA7D1B314C4
78C37F4695D43E537E2BAEBD5429CFDBB658DC4CF4D7AA3046E8955BF4F7956F5BB432E00DDB
8887B54188098435E347728E2C481630639C0A4E39DC12FEA5A9CDDC3789D80E282309A91C40
889DB165A8E20DE0281EFF3032BA811E2D856713BAECE115E8C946F908F020A0BC4F440EB222
9573020681EF160CC0013983C5418F2CF3F33FB0C2A8FECE117BCF322E28D1A3A07A8777B125
9EA010976AB8C67F17AE28E5AC10941A759B558193301D861D8270A01A38B8FFDC68082FFEA9
02E8173C3D6C88F055F9820F0D260B7DEBA7AF3487B0B20A4AAD51D1FA5D45D0CC850B3127B3
E5BBA9CA5948307E856CAEFBA2B878FC0A68FA5D83B20BBE42731FE6890DD151239A2712F7E7
138814EED1150A313C670E52E33022A46BEACA365AB06AF87664A28E1FD7FC62773010B263CD
6087C5F19218DCF66E674B8973758828F0D6B2B5CC3D2CCB78E5177B81A597600DEDF1A67725
4EE7BA76B93B48DDD67A46DA966081AD671E3DB9F60DBB19CB782ABF51EBD34A5DC26F4E3BBB
8B8C6B5A6321C537D94C9B83E8697014ACD2947FADA0D5333DBC024FDFA83D1897B614C5696E
1529CEE034C7EE6F1F02DC2D156D67D6FBB129639006393EAFB466362198C2D8CE58B33C548C
69FF6B9F1504F7057E1B38058DEABD6D3E17BB174BD7C4759A611A3DA591297E8950EA2C8E7A
BEC3618BD6C6B94092FE547DD39A1578497BA2E156F0B44E645BC0B078A31F4F42156804DC8B
9188321EF5FEE235F90508AFBA9716EDC9C9C5FCCF12CA08F8C4E9CB6456566E58DACBBBB7F2
56C4654E5ADDC4C1607CC7120A66B07EFEF680C533CB03FBD0BD1C16565743718D57697ADE07
711C2C80B4924EDDA306F85810B01FF23F36B20F350663CEF1AE6B97E74C57241E590254798E
C58D0DD95076A97CE5E18928FEA851E95C6B90BEC23FA440243F955719B2924DC29B5037E4D3
A038B874689A26DF8F60856E24C99EAA8197309F76FD5D35781A7A788CDF39E27E5408EAB702
F1DEFF3DC1F83C3D46C73240CE226972874996E54B3DC6051FC390EDA066358164923167A404
C989F92383927DA8639B6C5A56D480B2F4285E9FF141683A8E595DE09712F1C45CA6407A1B63
56D89FE40DEC814CBC2D13BF659F91BC0EA870C7235531E0257F9A501DE357A58F1DF4BCE016
7DB980292C6DCCC5B48877B696990F8134B669962BBF480D7972A6FC5987C41C10FB3791F362
D9F0598492BD03DAD1ECEEFD7CE777D45D2EA299C3757F4C96B78D5D2064DF1C8D988BD22F0D
A961E7531FCBB5E7431E99F922CD200B9779BFBA016D0156D7D292E637C961AA9B46033A13C3
D4070EB97B59949A0C959D7112AD88C3386A63FA401A261711945D347A02A58F0C28F3232D13
F2F91350F4FC69EFF7F92E025A5FF2E428077033AB13FF2D02FBF306AB3894AB29521FB325F1
A48176D6593A1D85DC4592D3D4396AF528AFD9EA206BFAB9E9CF22E9185DB2139D2D817B72C5
9B0844EB2A8009B44CB52B2726D6A8CF95513EF18D4E563606BB09326459EB62D08FC6E79663
2E2C761ED0FC4DE3CEAB2B97B60620A7B5EA16A3E3438FE7F264CF8BE3514AF156AA1E2A3186
1E46F559E7CA75EEED62DEC4A6BF705B97E76D43A9EFD499A428E83C6727BF5C6D30AEE73343
18DDAC5D60B435E8C2D9C7D96C84944D42014B55429BC11B99C7ECDC78042867ED867B9D7369
EA6BCFF0CB797BEB85618FFC872CDED0264E66BA1B09243306750C9DFC262DCA561DCADFE72A
DD72BFE5BAC73229456FD299E423F1ED1C432D78B06949138E4186DF080D66A9FF333C475101
9FA2A46A04B5CDDC740117576A2ADB86FA3D01A836BF935C2AEFB305F9F867FE489A8C94604A
0A53AAFC17AD80749C2FF556E116777D4EB828F60595261413DE632AC2BCD99F9C6282ECB11E
A82D1D9B3A7C4213CC6F4DEAEC9ACE4FE9FC2D756EF1626046C2CAA12C5927A6D0E88F72CA74
7D9A2B2884936B18A0C7C3A0765B620992536E45F8422BF643B53E33156E56BE6165BAE7136A
96704C67190AF639B7A444F1D2CAB994247962F4016FD770A0D4F4355AC6D4CB2FD1C28CE526
B5B39BB5568402521B07B6BE723640B319D30C566459F72A6F3933EE36F972F873FAA0418FB2
EF89818D10B0AA77CC03DC15C7DC9DA8FB395C4639E73B2DAB6BDFB48E2DCF6A284A9EBF0FA8
A949B616E0BEDDED4461D3A179A37CAFB59E8753ED794F34E5026DCFFA0016DB0693A80AC9F5
1341EC04699D7149F13EFD5CAABFA4D43DB590C8B07F7CA0ED55D6C0A081FC2731710707319C
11AF85B53CC8089CE32BBF4987C336AF7233DE7F5369305D7495E25E0105195DE7F2FF3F7425
7F0549BAA5F0DF1FB65C39B177E71D456599CD170E43301238C9FEE84AAD1A16D174FF6FAF0E
0F6F8CBAE17EE0DAA77A9734C60B13B66D742966A378C6A595CE78D148990D866D6262E9D42F
9A5AC49227356CE5E3CD1662A245F5DD916BA11EEE82AAE9DDA6D9BD0F0376CB86F41844A162
B2CE6C66CC14EFDE95459A2180052B0267D84FD9713AACB33468091063B0D1473F1ACF81759E
57ECCAA49EF426A9AEA3A19EFE8A8F799497C72933ADB6E056422C57B968DDEF940A45BF6FB4
FBF669FC0EDB0D378BF86EEC9DFC583FF4E6B42FD8B6C326AE3F7392E0B4D339230B4DE76CCF
2C2D24B8539269086B932FD2CB404D77FAA9B53F467B0F44D5E7A165170133098A845A3D5650
042AAE8B6644E1DD8C5E019F8EDC95FB6F342A4BEB14698040D90407D5C4EEB7009822972063
95E1BEC288BC277F4CC062880766C2DBD96BB21B3DDDFE8FD17D0C926340083578E407C13894
DC892EC3B2BF605E5F8C45E78A268214C9E5341CEB2875A8B661A5071FB516B423998AEBB5FB
6FD72333EABF8F54766C88D61F1416C04C55745157AE3394042A6BEDF0C692C7A3653A2EDE65
7975D2BCE33BFA7678D5226FAE3C22CEBCD76F7647E6D117F0F67FC6E9CC12574C00488F5E17
666999A6DA0E95339243C47299DE329F34A8DDE3B7B9667CDFB5F0A4BF1784ED413C09A76316
648ADFB96B5645752639F72376963807BDF7E1B917FD278205AE72F7F88D236E65A584B27529
6919C0A54C0DA1555402C44D18778AEB2A7468568B3C0C13AA0D3260BB90C36EE9F3AC1A8EDD
946F3CA84C613E637692141F506C97153AA02C9CD38F6EA0CD401341A4C08A6D8B7808230C79
0E0B0F93FE1FCEC5D78AF0CF1D608769D84E3BA3EE1C772C7185FE8E5F3DF4C26298731DA251
351C012935FD48CCB858F4FE23EE42CC24744F1BEB860D54EDCC8B39473F16A4170DEB896676
FE3D643D44B088027C11E732FBC032060554F9AEFCDD1479946F872AE9ED1A96A5F1FADE3C58
CC2DD03FEDF8123BCC3711D4A3B99F1AFFA620B54BF4D7B624364EA751F5388B6DB557E5F025
12333C3E214FF220AA359ADED762729C46F19040BB923EC671BEA10B4F81A471DE9D8B079B68
8307A841554125054B259F3407A184456C31D8916211422790539D7D02DCE5D55AA6F324BFDB
1CD4AFE5058034357B17A7CD373E50EEB7E429D05445C49C376BF089D45D4827BB314FB20990
9AF7DAF552456FE93B87DE0B7EE54887849EE638D9E80DEA6231664894E5CCC4B8D19C28D2BC
8A6D6958FBE41F28F342651BBF7FE94E1EA656735C93007C556DA27088785FABFD673E28A2BD
3166CD4F1CF3AE88B4490031DC94E8773A782B076EC4D17982EE2B603603654CE2DA191EB5CE
05C6604613598E533602B7DA8874D7342E2F1A7B34A629348871F59F1E7244C1A5658339F0A9
82463643269E8ACD6D71F51C0C6E442FE7D1FE2F39D03C1CA4C0A4FBE402CA30DA1CD6AD1A03
857FD9DBBE40D13D702C0CD1EE6AA02D48B32E7A33ED909CA700F59081249F71337F851B0EDC
4453156BE7D71B1688D6930E61B8B5F4273F2834CECBFC123F6809882DE73555E6F6F9D20722
EF75C08FD613C1AF0FC35CEB88CB9F3E753B803B720BCFCAA4FA4B68D30A6FA39B3C8767D8CB
F7991BC26283D7E2DB2F9BFB20EAC556D00E3633FCD1B0A3DAB966A81FA8D13A452AC78415D8
6F1D7ECD486AFC5DCBC542AC3ADC0802FBC0674AAC809DC36DA43B8A5B89BF177E1F9A87CBFB
440919DF9FB8C50634EFD418EC733BB43EA2D693C58903883D9EE12EA83C934D7D7C647130D8
F74503EFC2E863EC3AB2ACDEC997FCE680C46A41E9A1EA4F271D931206B10610D7DF933A3565
83AD52CDE17EEA4D66B0EACB4B5BB1893183C570847BE198822F35119952280B99172ECAD9EA
DD26837CB19ED7B037B0DCC53FD89B47DA866F5F1E48051CDCCAF5A082C3ACC3E299F9FC7119
F437167F7E7445F28EC6197DCCE3066D267C01DCF0D53C6B821D70C36892330E9CBA232C4E99
6431098FEDD7F02649B01C0EEF3008724FA20E07F5C373FBD68B8584F7393E3965D6F7EB77A2
A988D42925F24779922BA75E7C4A1384BCDCB70EA4130F94D6DD29A5466DEB73BCA16A683C99
D2EDF4556C2C1D6707F1352DA83760D34993D383317041608FDC4CD4A510801C278365895F8B
357B526BF76E15C3C79F3A126F789B0E117230926574321A58467E7B132325677096ACC38E87
03CC3DF1FE7BA0BA56D048F417912CDFA15881FFDFD62AB48050594EFAE00ECD7DD13F87A917
F80DB8483B0179FB0A4F42FB4670E49707AE0AC10EC847C4B33140DF88EAA2568B22A396A350
D7FBEF8A183ABFC9EB3392387C60EDA7738DAF9C3A767155A5A5DDD4A6E14A50C17C3F2AE431
5B57042D10FC115335D2EA7710C36CC3C0F24EED4D3C596B7A2887426A6E7EB0C31EBA3BEBE8
789CEBB41D7E21B4022B6D89CC53D0B9449F8E0071C51D068AFD1509A98239B88C0EF5E947CC
27D370CF2EC35EBA6AA5979C2C0A469BA99ECF26C3E97956AFE6A572CC7ECD7E23097795CA7F
6EF9A072C2B8484D2EF162CB15C67EFEDC989563C54E0AF5A9D971969C3A6D04845D309C4855
5763BB873B4F3797B0D281BAE08ABC7FF0D8610B65E25229BBE22D963F67100F2DB675BCCDBF
7AA63D6BEEC7CFD4C5CD709DA8327CD8D74C53AD98A53D39D104EDF02D1BFA2C072B89BD9985
1823F1A101FA92A6CA72616F634F82D1F1CE829A9DED38D344373663E54C0A587F9313CFBC0C
13917A8D1A19649269ED5F44D40E73ACC00391A455E02428A8104360EA87AD6B8A71F0CBEEB1
FE4F56A73841F076074355F7FF6C55FB8209489BC67E392DC502E76B3A51DE0C771153BD8E2A
FE032B0914D12BA8CE842D30D14EBC340D2188DCFC38D4FBF2EDC1BF234C77C4DAE0A65BFE8E
4DA6588B31CEBD977E85715982C7BB97B5E14A09653322F50FB45CD9B90318CD08F871DCF879
FD07AD814538618D3514BA336DFCB47C2A4A1AB5D21CC12B53D8E4A992C9814B0BA79595EBE1
7A0BAE424BFE74920C1F6D83B86856EC2BF6C13737E1BC115D2DF30EE26FAD3F9217AEF8DF6E
72B6F3591448A366FA12C7F404FF0912342EB57D5D25AA3D3C58D1B1E9FAB827FEAE40B850DE
2EEF7B8E183B6AB0FA1932EB8C16508845A87BEAEC074278E86AAE97314F3C5016980C80CB74
D3486F6CA5B658D80A66BE2D2CF6032459DCB43CBFE2517510F9605F1E373F33936F5590E39F
2940EB611D283918DF02EC0068D576E9ABCC5F1F8B3260BBEB83F5A0286D64C787DD135C6BC1
9A91C6DBF300948B98DB3D3E06F304C4F109FB4566414E50DEE67FC27CF91EBC1B18BABB46E6
F55EAE93358012D49EC86044305DA9E9570EB4CFA7ACAAACA5025307DC45B042443D968189A8
88525353307EF13F08185E943A3787C2C57FA6E2B40F4B1208671B0075CA20DB8309F75B5B1A
B9D2B71423A4ADA183028195D01DC7FE59B2AF05C0FDDE7B4AB190ED745BB58EDB8F22088732
32175B3590DE3F1995E4216D8488CE4EC4CA40D3B1B9A8F7C4DA1180BEBC4394AB60E62FB765
189B85EAF9231A8AF9AA1CDDFE5D907EE8928EC143B022A0B5531038BC16B5C75B17D97112CD
3DC633D1B260770C63A4391BBD8696F240E49DBE4ACEC3A4CA715E95D94B561D52D6541C2404
3420BD91461BD40704CA1C9B6FF3349820CD71CACE8E520436F96491D3BC40C7E8265F6C5356
FDB6FA5F6A056A02FDB2DB0F076A6EA42171D5F6183D812E9A685AA08572EE4FBF8EDEAA03E4
E52BC38ADE0B2681C5A3C5D28428501BE3F4F51FC84C951E239239A539880A42EAEC6ECB6015
2F5DF33FBFF1A2A1D5BE84010E918E54B9230B6037DC3EE9A71310C988D3CD15860276BAB2EE
5D56ADC515C247692364535B822D822F7D1879033FF5F3C61F2C5A64BD8A0634B64339B640B7
D13E2991DFF373EAE7D2252385092F5037FC86408B1304EEF32F94EDDB1D61EEB0A0DF4477FD
FA78380DFF75F7F5BEC17F16C6FAB300F4645F3584859F34ED2626CF80E42E6952F64AD2A282
AB4A26FA8DCEB7C905E9B8B0A89B53C59DA1B636907818E9D0C171939AD57030898C4BC58F0E
6001A6C586AF66AE093F628FFEB308A900B862A4C2725E6C31ED20528C0C77B74918809C7079
F7BD5B5EBEFC5C3761C9F13C345F3388ADDD6FB5CF247ADE8999C64097980A435D6033DEBC57
AF8353940907C9B8EEDFF453D75C587F0437846B37352A4F20FA431022A92D55AC7449C29EF7
AA8755AC892B4C6AE1054F3C5C1F296856C19CC8A2134562A03F972CCA17A98FE22AFD0DFE93
9A6F84A1971BF57F39A31045B9E8F7FDDF356BD072CAF00FA04D4DCB849C8F2440D330C0F072
E1F29AF1331896E44CD2E0708BC1722FB020396B73091D189F94A9B375C3B770094000474E0C
4FA9481C7C8DF5B579511750C1A16535FDA3BF219E0B00226B5BD95F2A62B283A33844C3B2FB
D1C7F236F7C92C2DF564735A5880D3C9AF4D4BB46AEB211AB1F6D4523600277C1495C69FBA1D
DC574C6AD9FF9AE54C40EE346255CC14524F57FD9FFB70ED5843844BCA6D2183620B29AE22D3
0E547D718491CE9A48C88FAD67FC24C7854AD78F39779305DC0B160C1EF1E3620A3F59E338A8
0570F94B5D22D3511AEB1D56DCE8258D2EC5D0EFBF87CCE46AE32437F6450F4A08957C644D80
86265B5F0BBD33BDE90BC6A012C045CA4E223DD7166766176158D8B574F53C33C766C745D051
AC37564FF1C37B93B5E069CEADF80806618571FD3AC6A6206B734EBFDF7422FFF9AAB00BC179
AA64545845B5173F86584C2699CA3D7EEAD5E086A52D69795918180FB7C432FD3BCA83B450F5
3957BD5305DC8B71C34DB463A0CBE850AE2FB47940B4162A3D752A67AA9E504D4E7940D13CCD
C250AB232130CB3E69B3554CE4D05A7248A9B63B8B93A011B2F6E54B4AC03170A6D40CDC035B
C4F96A6E30A06B568A008F1612A459836AAB05321E83A5E90D2250172FB8924E2A7A8B42B0AC
F398509D26C5B9D11A8A4B4314ECCFC7739DA363594693D178EFC23D971DC05A6617094E492E
0012123D8FBD8BE5D2989B1F7BA0494623FFE0EB71631828C8A83D2270F5AEEE969F6AC63B9C
E6EE788DC9CC2951AFCD3ECF238E3DC63F6FBDB5A5F67C20D3519B7C332B03A9072D5F7EB413
6A233202CD03EC3137D45ABC98E73E82FC01B45692619E744996C0F0023361D1307FFD115AB8
CAC526A8F15FED0191BDC64B2C5B5127B397BA9372C942DE1210177417DCD30561E493BEE4A0
6DA4F0D0196F7762362DE98546FD6FA85F62BBF8E36FB4180E63B8F61C9AFA3439D5121BB3CB
4BD94DEC1D1F20DD26BDCBC506CCFDB36F0F9D0B4E1C0962464366DADCE29F3854DF2CB9BDA5
A11DBE57560FF8A063FE59C845ECA60B1E40485BAC05ACB65B34E1918CCE35B39DF357DAC765
A76AC40089718263B2D648832367677A048FA8FBF3AB18A5B079B4DEC0C2F8357A02373C3216
FA935E20A8A02EB3934C52C57BD3A14B01E3B3B503BCEDF68118EFBD356ABA81FBB91D9A7E74
AD06A3A443F4747C182E139CA03F1F9B5F83419506544D272C37A5626FBB4730B0C9CACE20F2
B7341C9954162D500C0A1EF892A213C4423CC69C554A5CEB2DCF6B6E8935F586B1A6C54E7968
CE5957DBD6CB32C276AA6E8946E3CFE1F480537BC87D1335E15F5435E43B682B812FDF63578D
F9E6B3ACEC6DDBE58A83B249F99F16CAFB29CF852179FF9C65839914CA3AB0928A9050AD806B
70C97859B2BF70612F5926239A11AB7C6AD685E7E992D6F3B8DC0A750CFF4C9719ABB02509A5
AA0F545CBBD9DF3B0F77B3D805B0916288A7DC1DA026F730249AA0D36BC5DA763A0BD67C02C0
55312226809E74B99AE719923C6AE3C913903B589BCADA8BC4F7C11CAF7106BCC4028279E431
E337B99DBA1199FD42A3DE57FE3553127F2D11A7F60BBA068230BA6230FD282D3E77F614BE56
960971FDD7CE5B01A082C258C68EA3EB86C73A901340283B4A94B172EC36DD96BF4F869C8B06
4C659291995E5DBE2DF25CF00081326E93CB76A169D913C009A087E0191A532B31D2C2221BBF
256D010673C29FDB4A04E198F77164D5BEA0E21A1F4949D5DB3961E17ABA58BAC4646E886275
439A9EF18D2B5E063C4AEF7474579F49311F3B5BAAFC159E9E07BBBB6BC6B8794FB2AFA20BD5
A2D5B8FB907663F3E67AF7F198848DF045F68F9FCC0060EFF5F184190C40F987C6DFE5AF94BE
9D91AF5E5D44B5A345D608D8FCFCC4399BB868CAD4518B0646FDCD6D4A6FFCD045645FE0A557
3FF39FCBBE7E44451FE5EB74C1AE2147ABFF7FA645245C7BAB94D43824D3BB6F47980BAA06CB
2C74E8C0046091CA6DCB53C3B7EDCA8E4253137E83E74E48BA92E1481288A060E7F54D77B338
570366A92B69B339ABF1354BC30B9C30AE46C64F54080B7D4F0C0EF0ABF8B2C77EF810CCE642
DDCB49753FC632DF6FFB80CAFAA49DEBE3931C1955334A208C0570909AEE53E9407E82A687D2
36A2FC4FC01385E87E95F79BB9C69F8F8CE1543AD2B33F99BDF99B205C211311AA2500C8788A
190759E44B2D141AC7EAAF972F9CAC9C4840755F4D85BB5FF6441FCF3CBF32AE347717E7C256
96EAB1BBA545FDDA934B507F6FC284EC2A377CCE610C35C9D14B7832DFBB7D5A1FB4AA4D147B
90F6591C478D939B5A5DC487A261C99959DFC86BCDDE594989595A31311227824FEDDBF26765
B937B9D549746CD0695A2DFC528859B97E37C7EEF7922301F588A49E1A77A1249B8816DE54E7
86E8464DC84D5CDD366834B351DF2B04F8B7801B75E802B96DCACC3423566DDFDCC511029E64
966BD109ABC8FFC9E14104FFEFF5B662EFDCA67A2380B351CD61038623832E585C44AAAD8DA6
DC76E8382DBFE03EC5426EEC3FC2E1282C0243C1971D0FC3F65767184838AFA6B0B103616FC6
758B24AEA988D854BBA3BD6FB7CBDAA4BAE12BAEB0223A1CA2B0469D4071378F2A2FC4A2E934
D9CB00DB0FE2665C2EA31693E476A29D98578F209BB2E7A3385C9846D7BAC69D67E289CFB324
61B1D2EE3233BCC3CBD15DD27E9A4CFA86B692C070F1E69B686795AE37CBC0934895CB3419F2
5346C745A7334FB51A7C019449A1881BCC5A295CC6BBD6B38BCF888F5521F9D54271FEB37C66
3B6584CD0D811D9F4CA53AD7F5F3D4E35F4EB4D317D28EF11FA597D2A9E8F633F32FD0ED9A69
7BD4BEB5FA43F6C020F98000390C53CACC49C51468A275C138CC4FC4008880BB5D31A1FE5D10
F78697A93132030BC356590A0C7DEA64A5BCE6A84284F5881001D5001EF441D5C1A1656F3141
1B936796E59409AB7B42124DD2494795BA75C175120708B8A01D0D4A5B6F262052C30513058A
34751461B90D942B602059FB245CE34A3C54E4F3DB604CC21AE1820B383E9DE12F99E66E4495
A0676FFC0232E3AEFDDF5DC91DFBBCA30F04D955C816498EA132617A921FD6694E6338955FE1
BBBC89C8834F66A3F2E5BE6260DF1FC6AF70E3FE1962EAE546D38B8ABDBB1A37A7B1579EF8FC
9824C51394BCED1028C468C68149DFC887FB4FE05B85BB06589CC3BB65EC714579F42CB6390B
AAD5176B0411E98A6128E716D005C17F1E451B79E751BB482FA79D79BA283D675F8E33028CF8
038FE21CAB7F875FDD4A766943A31B5D96FB5BAFD9B0811A90F7358FCD2B8F164E270BBB8849
7FED64B8C82397F47A6E4C54B17BD0FED310BA2EA8EE4A450DE88EF3EF3E4CF0FEC18FE70843
57D16D7844659F2981660780D081FB79C03A6058C8B434559399D8EC161BA90BDCD8A4FF0CFE
A1A86C618008D13850550ACAB33348413C82A6BEA9903964B82934987BD9E095DD87FB8B09BE
86E6E3C2CFE26A3E6D35CC1E1D2506A0C8BC2BF776E852FBCF0C66ACB1E2725A9CC4829BA3C1
0961C58FA7990D604389E10F3C43EF8389AE8895D77ACAF4925785551864FBF7A05E81A0242D
49979798C718E4EC9439E22C40983F6AB4234D8D3CBAD523CB193ABB653B1FD97D4B43E72FA3
FAB535B5687CE4F47C2872F08C19C5DCA95D52463B5763CA7EEC5F223DA12B3AE105D724CD35
EEFA4E1237012B38D0FE3A23780C3C29689CBAB9AF9CB13D248B25F1D4E01CDE35C2BDB7C8DC
1797A73786058F9ABBF4C40DAFE3CB549E0D11F026F4D6E92370BB92986912430512E1975F95
87694F0DA758FDB7815DF77FE9983E32C15B216E93E42978075C0D4C45257BF43591473F0520
359201BA95626B8381207FF8FCEF946709400F2E0DD88E02E25FBB363E6043DEC45833C8456A
5423AA3E7BB020553AEFFCC12E57FA331225D6D60026A94F4BB4320368F693D28C7F2FBFFBEE
CCC4BC903729E939C1FCE6ED8153C4434A2D27533390644B8531300AFDB3BEFDB8B84D266B3D
3AB13DD1D094D34D68673D56617B0D49C0621A368E5B402D7EC3151F50BB9D5C8D4BEC159704
9E986E6BC1B16606A242DE0E8E0AD8B73407BFA5EDEAA195B2AC90B6606F8EDCAC4087AB2466
3BCE154C9E98F5969A6EE0612C48357C2A48E6B30B78D185C536186F734DE9E8689E9B67638D
E01089D86856A246E6DC0B704B32489352D3612F95B4BBFE824E69C20CBC1A665421FC8EE96F
80FEB7566CA18C804AA76C0786456629EBAC3255A60846347D3F7F772706980830082945856F
1907CC564D77AE9E76883F755FABDA6C93BB973E744CB6F259F8165395658985ED07C986B4E4
CEB66DE583A71284BF6A10F454D4C707C666B488FED03015E739E3A2305C60900D1BBAA54A90
2BA9E9CC1F2355DB9653DAA359BE4B3F3E06A197DE7ACBF6252942FA8C31B85C99A5E98B5C45
8F089A45E36AD6DCCC4D149F7934BF5741D6256416397B566AD42EAAF77AEE96FCED66CC8B0E
115460F492B2F3594109D90BCEAFABFCBA47FF71F8F7EADDCA144BB83D2D483B7D71E87DF77D
04B251396CEFA6104F2140D4933E385D64AF82FD3709C0EA1E4B453DD764AC2AE649B4228832
03D22376AE05DE8B974EDA5341ECFA676F88690F5E4FDD5F49D69A37F678AE750BD7C7207226
CF57233903932DB1D498C71A494EE7800148CC3D48CC265800FBD38F53FDC0A96C2D5BA162E3
05D7634FE7A5588DDC69692ECAB7AFE172EA7A1E9EEE8C03EA3C3368C2DD099F0356C4656438
77AF18BE0DC87E5860E2B536F64E9DDEE90D7E46797335199EEE9F2C1A61D2C1B78164A2CA0C
7BF552E25EFA727413B181CD541761649135132108D294C6DE3D3B06C691568D8C34B1DFAE34
0DE74D2842D81EF25FB2AD425B566D80460CD003D948067837EB928E8DF8FC693A713FA188E0
69BAA6E4BFDBC4AC02FABF8C0C70B0DCA46EC436C90D2AD5FD4209C29E8F1194CA554841699D
809A266EEDE1429F1A9D38C0E6EDB08B98717605FA7D728DB5EC56D34281ECD55B7B939BFB04
9C6B138A691DEDDE4CA578E124D5ECE1F69D56FDCCBEDF0C888ED898C62B0A049EE526521FA1
D409D7981F097697EEB63058395214BBB62DC01EE1B2849FE8F8CEAF350FAC84D763503DBE00
D0AF2454738A3DB0BFD2188A26E11B735CE4D4A3826C38D5458BFF04CC553107A3807568481A
BF70641DDA318DF05CD8D01AC8B66454E8607FDDEB6EBC88E498262B2B5BC95D38E2C26776DC
76CC4CF369B6A58C0762947152F85AAAEF24282A9F1DDF055DEFA4EC29FCFABFE565F3CC7111
3FE933C505FCF999BDA92110ED4EFFEB5C89031859E17DA016CC2946823A0775BD46AE3D817E
5863658777FA7509C2A4A9DAD3EA7C44820F4C185A9C52B3728C5C2772CD300D238F71394114
0D494375FBFF24FA83CE59470263D51F735E3AEF0869E9A0DBC71333019F54774897AA3BB768
C36FEC2E8F323B7ED45A12BB80B39BC74B760BCA14BFAECAEDDDD26203BF5B28B4750ECBFD2D
6DFEE320CE8495944C99758E23D95ED68868C671AD652B488F5D5AE44002DDBDFA7E35D0E9B3
085280F99595AF8470FCD546FB0E895B88A2DB5BCFF50F7FB23553C84C0755AEE1B08AC3835C
F278894BE27C5C4CF55B629164B49BEBCA3F2749FBE5013BFBDE908D99232AD844225DA239AF
D96168D260187ACBE74721A59219C5718ED25084899D323BD68C4F1C042C57A31B08BB7D8D11
3C3B8A92E72F9099D40A50D026836449D1D0885051BF7B13FCD6242776361E77CAAF1DB6D688
668288B54A0B13BF282A666D789B55AC4FF2303EE348ADB2B753CCC3E85AEFB2BC6C81DE723B
7CC78196002702EC21BD340E5B1ADE2D51D8783592FCD19F3A4E24CD22EFC8DF7514C3299F4F
EE63EC79D431863A993A66BB53EA422B551BFFEF9E7D7754F63791C67DCE853AE1F219083170
B29CAE220F785EBD5A0F524A91514144931955CB6414033DA205489B3873D6B75E4F447E33F6
7DCD4082344311CF8B8C63E4D1B501680DE60DB398FC5D9C831387E1382944FB28F30D0E9DAC
B4DC9D29114ED6EFC2FE1D8DBCD1B7C3B3E2B1D2C9FB2B71B69881613B14761A33937727D515
6813A6139EDBD1DEDEA16F2033FA3BB2AB01B7A61F6C57ACF12F16A5BE9A058BAA8C5B8A51A7
9DEA2106DBDFCFCE946265679DD05E9CB1C78C255411DF48B8BAB9CB202C6ED55DA0DE1DFE23
D1D1D3D217B39DB561AB23BD89CB2C5CB1372761811584F92313469115C2407B9B6BEC04599F
12BEF91CA0EC4CC2B897CB724FD6288A8DD3E774735788506FD84390EEEC5D2F11300CCA82C5
85C25395DB8A332FA40571DA1A4CB5D1103350B37881731DFA4C2E248F30F8EA19ABCA2A2C44
B6EFA2C3DDA2FCEC5CE719C87EB1A4ABB4AB2044B1F3D0363E4EF6971EC21B2ACE98809EE10E
C801C72E6ABF5021D074BD51D47564404EBC394530C9846F417517344363BB41E4D4BC72E122
B5C87DE1D975B00C681487FFFDE1D297069C06E24428E267ED82A3EBA512DFE9D79581A9C4A6
CD45A49E727184E8F98B177F203E6107532074A44B69E2440030A6C20D274BC412C6367AC640
9DEE48EC2006533B40A5BF9E86E9E9BFB916E6775D6511E59FBF30F169975E5F509F725E5AEC
727B598F575DAF4037DCCDDF95B41B9BCFAE73D4AE20A50743BAAB43C2031CED4C7447A21738
29EA816EDE6324BA9CFD791375C0BB7B2A534B27FFF08865E834839EC7F43FEE18197F402BFC
FB7A4010076F7859998347D4912A52DE5873423CF29946CB6CA5422C4669F0522D90F4825E2D
8528BA44E290A95C5EC5D66ED390FA49F0FABCC6ED6AD375FF0555E4BBD5409BC596BDCFC844
6CD121F5E881385D0155C7FC0B9D3B8636662BF4A5F981F93B5122D679EA0E2D6E80105305F1
DA0E268861A62F19D9AB7B3660B84B5ABF7653D4E191CABB7DC0D31BAB4E8CE27D5AE18D2348
DED48084710F1ED742C566305EFAD169934888BBB0894065C3657CE8ACD88F5D033E15E707EC
D9C7BD339C10339270AE0DDAE76BD155E6D113E336EE92FAC4543AE118130CF90667B93B8080
1FE8FF690641374B07AADF41E27523EF3F71F45393EFDC0F2502A5EFF205484C43356C55F404
B26CB2BBBDA101570B19CAE92FCA67DD80D2BB5E495A1176643B1CD6E561073C58851DC48E0B
CE5C02B2FD17AEA6F0B932C75CC98FA817B5B18F62F198927199588408242FE045BADEC08163
0FA575998E1CF76607B19D5F926A56623CB900B2564B030CADBE122834B92255CB21CD888492
29DEC80E8E99F13435D24E41ADCD42B397E519444446F0E2728448B7F369C787FE9AF953C166
C324DD6E88DB664523FADF43B36700B8885917A9B1833737940A03FCEE875D1AC597BF6A4B9A
352A270C6A729B9659023846FDDA23FE141CDB1A9C6F3505444991324658B748727041BE51DA
2A7433644447B86E7A7FDAFC8D7140F86E283D8873BB684949A9B02CD50F08CCA299D7EE3816
142F8AFB6C410F81647572E4D5B7F7BC28EDEDAE5A4005D6BC4578A87920AA5373C0FEEDCEF1
8CF379E5B2673615808D860EC4D16058814A20A12A08F9EE5EACE2C57923B4BB482121241A83
ED98EEFA8524B1F208DC0BAFA7E54E853090D79C6C73E7BAB0CFDC3D36124142D0678535AAD2
766A05B25E7726DE10663A1D312FDF1E3E6DE409695D13F42EAA011CC06803B31E799BDBFC1C
0C44FC5CDEB7AF3489EFB68E4C310CAC449D5101B62DE8556C17556B81D76DCE97E2F405D448
5D2240FF35CE02A9220C983078E8BC4BF88B351667824B0A4E8B496521DC190D772264B05DE5
469D4F2C7EC1353A1BA82AB3FFF8E3462AAC58B79E5247018C906F3552D37DCCE72DC5FB07C4
26C17DF6A2B23772CB72B944F9B1BCD89F26841BB02B11A39501A39F382722DF64F1DB194D03
E7B956AADFA01260352A1A9B8671C04A5E39904F109A05F7FD5B20E14226B7AF183EADCB6DDD
54FD91D8992C44D4EEBE29259593E40576E917588FDFDFAA12B661DD2401D79756207C768201
0E08D2DB03189B4CC0A6171E59F9980B632048D51ABCE80183815856CDDA908EB4239D10FD29
20E2AC5029FB77A1028627A1A336412A47A61355955656DEE8935816D34363F56634BA0704A3
7BE9973DF5BCB37452919212CADE1B09609DF373200290DA1D830C8D2143D0D90BD1A2B3C430
DB107EDE26FD1456F4EA591C51AAE788E1EAE3541A01675E68BAA529539D29FD946571DF5841
E3CA0DA65A4E7E04CEF8A6D8F9A8E1951FF1B567C44DA4D0E1E063C8A5F0984CD900DA8CD1C5
52E6CBE1F939C6FB539772DCF6799E657DCA9429186F170575AFB969F8F62C2ECA7DE14E03FF
1ACE559CB8789D9677BFBB4B02798B758BBC63DD2A7726D583116879F4CCEE429C5F282DC3D3
968FD2D9E25C15ECDD1E3C08CC5A42E83BFF7242A5BDCAB8C5CBAC3E67F814744C53DE018545
06BAE2D683F7D86917CBADA95597A96F60F2D0F5F1F2BFB33DC81E20A6CE7477C1D581919DA3
3DDB37D269D5DC98B627EF32A50449F95DAABD20776518E64660CC6E3F6123383F81C3A647F0
08AE863807A6A81180985ADDCF2A739A74A837A52F04445EBB830CDC9E7C730D24D8D44DD5A7
D02D5E474B8902DDB93F17F3036B1B39C2E4E8FA8B4BF0BE0BFA5406D5A53C31AE15380E1741
1948BF7E1D89AD69ACF3B00D43F869F34A4BE60B0CC23BE042FFC47C1DD194BB7817F2927609
7FC60D2C09F4CCB2A0B56EDE82CC235CD972D5D22C60DA97D3209091D813CD7FB0A7338AF4DD
8522D33F9C231B230393DEB17C2B5C1B6FA3A6E30AC79B3F97672F35EB9E296EFB04F88A3D29
9ADBD25AE6BF494B8417D1AB33A659EFA31EC0E4CAE97A9F67805EAEFE8FA2D0FFD0C91D8619
558B79BF28EF8A14A81BF7C54F3168D3CB092B51EE05C0B29614B79076ED31436617052BB876
5158C1F245185413E3BEEDCBA5D5AD2A51B1C306C5E8270583638F3EB70BD12FCF300D193CBD
42F0E0D5228899F0F84C64801FF47BE6757BEE628ADC207AE379B4403043E35463BC47D4C2E0
CCBF875520D65B0652063A3C653753338B5C38DBB15D4C08185ABD22E7DB59CBC2AAE335C4CA
C78410BA316555CE1001266013666741137CACD113727F9C075A705408F9CD597790F1F91A14
C59EB30C648A9A10C8214806AE3017CCC6509DA9B333B8F483F1FDE658941C9B360CCF715411
E56D4E96102224051F17247876116C3D4B8E109E7BDFDB599F2913D8FAE9112ABE76A6D62C78
67B66FDA9C093C89742D517C4C79E29075A5668E6E875D068B9BCB9F8BA5B7C998E8D5EB51CA
BE1FC3964EE6A2882F1D3108AB81084C9A18755238F3D83DCD4BBBB3206F68248D057426F06C
294C4BDA3D7DD210C8C28A5971CB72C99D4158C1697941784F0F8D2873F543CDF96AD3DF3098
5A88AAB0024FE32FB46C5A39352FF22E969A8645931FD9402C013411D77CF15D45F187BFCBB9
78C9CAF7D8C7B921A5C4F900CD0FE0875B5322C105BCFE732C3D6F2C3B3D22E3954B6364C6E4
FC5B39F24CC0AC3F37A5096B8BE324821813517F49BCAD020B695D0FE6F758B33E1D0DE95FC2
F513CCC6DAD8342D589CBDB3581D55F980428D4566764A3D99DD229E4A786EF8A853D3E0B944
F113E62E75AED051784FE2A019BD075B0B55CF0F0094351E13941021912A82D41E12FAB32E69
E97DFDA9D2B3EC63F1A14717BB0BD78E9609D5D77F131FD02161599238101BF80F021E38BFC4
F0F0FDFDC70E7B96632B701953414A5977A17EBEE7901586C3A2FD6766582D1C9AA5F22F56A7
B30497380D74B7D27449BAD61E516A5F7EF41A993FBE1D17E81EE9C38F43C7468952D7031467
2703FBC7A6BEF24A689D61E6877712DC6C32416A95953CA060D40EFEF073D706BA43C1D3054F
EEA647769B69115B10179F2EF6336C241E86EC6F9D4894F2AD50D6E5F3BB98AC822381FE5A70
51C5E55053372B90AC6C45B29168DB878FB7201F8D4FC7F7A64192A012A0A32F5538DE1D7682
16EF0807E19685C8CB84F86E37C3A02E650F8CD78275BFBF8DD1DD0D0DA51F3BB8526F5BB5C0
AB53C199EF6FFC32312F7CB843FCBB6C0537385E8B3F0E36416EC17BE3FA66E85E1446012AA1
9325967EEF17652932BC2F7BB500BB5E034F2AE262AE2F70CA00D2FECA239B0A88631A7C3BF8
85BE38B74A8E34147DF04E68058A148F2A89C4A8F401A536D36C311B6E3EC39356E508B310E0
DEA4220AD4576481BDB13156CC1B1CAE82A327CB363563ADB8111DB19B9B9B55011836FE8EEE
ABC28A032E3AEF089F9A3C1E27459FBFC36AF01DBD49CB101668A77DFAB3F9F7509526EF2AB4
9ADBC76C0ACBA652E41E99187A2C38457EF2A93EE96E3B13EDFFAA9B5D800A158DA377E0D823
07B06DEC58A79C946DDF841D57ADAFC65F1CAAF8489C164E9EFFB75ED4F5194DF4D4B3CBB8C0
7FC225FE7B4FAB4A334F47998F0A83A69946BD3A27A1BEEA3CD2466E93C69D724B5A84DDBFDD
6E33ABA3C44FEA2DE6813D8815F17C6E23F7AB42B17CA7483CC9BA5E438614380B5C83E1D376
4676845BA378965A3728F29D420731AF74D02C77EE9178456E38321FD726D86C691E083545B7
2BB25D2C7E36167B657EF0A26218EB4FD2C2AB4F1242671A7345F07ED3103DC6E37B5E4FA96D
73AEEBA85937D3755AF18497D2BCF63AA866ED5C998B76169F56802B6036450A3E582447DBA8
C0F3745ECD0DF1CDC6A75A93993BD337852607F906872C5312826C1FA8CF98394DB897D0F5BE
EEEEC4269BD7564FB2C59BE1718B392CFB75BEE2B45EB5A9F3E4B1D893622DF16AF3049722EA
6F80292DE4F0F3DE3B721938DE9C24C409F8F9DA96B65415DF827053AE5FA15E027C55407765
13A9FF1EB4CB8106DABC0C71B224A08C69F50105CE96D468C5EC4901D3EAF0B1C0A081978754
B387863ECAFC20549E7A9C93911BB3335176F8E570C3E0C97EC79E8EC2D852823B4DAE774DB1
628CBA7A6EEEAC2C5ED095DC317E607AA7276F309FA7612E88F199D7F79C5DD4941EACB06700
F5978E9F4C51C7D2F684969C2D3D56882D09B4B74A1A97D7090199ABF2FF1D3821A06E9F20D1
EAAB593A8110E7AE44B868922916B3BFD199C8C0A4251DD4A46A8E6C868D267A96E0359DF2E6
5100047C52B016AE5FC27A19AD5A5CCB3C05BB27BBE624C2400EDB84D18C5A1B229DBB0C1A91
2A5ADCC65BA18BB2472D9788CEC781B70592C9B02B6DB2F4458093F5F1094356585D6BDB5D80
9A9B599C24D0E6A17D897E3DB10BDC62BC85A3C4B5516F220BEEE7485508752702E1065E71F4
59F737DC140AEB53BA144816BFA5EF9149DC2B6D8E98FECB32CA2B7918B511AD4A6788C02889
D06DC2218D7C00F9EBC49038CC09BD262D4AFF165F0D3B350BC783EEC8D3A808482B74E7B00C
DE0BD918D3FB11C9F5DEA05F9D1A734CEECDA37C6EE2384759CD74D67E6ABE2A6072A578F789
0C2CEFF04C6584CAC38E852DF746F9505BB13D8831F60A9CDB2DE7726D2E8B90571C9315FFD7
35FB7A383F430DB35F446F58569B8BF80A72C7F83AE4A954FFFAFFEBBD795E094B60D8A66B90
F090A1C2148ADFFF65216DA2C8C1F84D0E0C5108DB6392D84D8EC4F01F8B90FB95113A618CEB
CDC8C1107779EEE4F0B25693EE61F57DD92D066C086008A285CE504FC4F6D81F4C565CC818F1
6B11512913075C81EFA8CA612FF6F34237D1641899808BE77F5A2EAC9A50A699FCC4B246CDC3
097DB9D7B2EBE5250CFE6171CEF40E617393B12AB442EF0DC1AF576C300AB958FB262CB87819
803157922BB7A8D394D79A1AFAC4925D403671104EB831EEC1FE147628CB41BF06750BDB4EB6
68471CE6771262C0DC5EC8F741070E236E2EAC704FC8F4F7BC63CD0B951EDEFF8C8FBA21BBBF
15187A464169B84BEFAA0DF196479C4133B5AB342B102FE55F4E4E1C01FDB38DD31962BB861D
A409C4B1E192900324CDDB215DC625F87E601575DFD437B1F96AE63D9ACF5BBF84B3EBE5E8A8
0DA290A7F6C4BBA322D8E1C3B7454B1E6E2313D0BBB87AC3425D0B8199636909665697365C5F
70DD54366619AA07A9DB2EBA0A467171C0BE0914993A7F36EA793DCECEB42982644560D003C9
4D47337FF8E8FC34732C7A65F9121B6C07CF524EBC514157893FE10EE0063A9C0A0D9D644125
D3337D06622BE4EC02B0ADD0BE39CB87E6C8622041239C78D8E6584DDFCAA9FA6C3E5301DB72
F14308F4E35AC6B85ABC7E227D5A2FE0073AF117BB30D86BC26E7B596A05E3002ED7B0B1F645
2BE60B1AC3C1B48712E06CACAA1C432988580E118D82B057BC6D3347BC43206B0192F73289C3
CEC830E332A665A88CAB91FE9D7BF3709882FDCA1A5FF953E43E999872F9ED437B9FBE6E0137
F359F51464C0B65D4C0A791A757AEC404BC5DAD17815B3ED1D3030CC0EC3FC05313392382064
8252ECEAB9967DBFD6E01839C30DCCF9F9E424F317AC50FDAE6D372CE992DF09B305CDBB6992
9317DDD625F7C3ECCC87ADF8D154893A9E08CFC14DC274B5387234309653A72CB9785A4185CC
AA702A9292D34735F73323D855102359D682F7F74A63C5C02ADE0B7801C9473A553BBB9EF2F5
8B21FF5C6B6C304DAF7692D3565CFB83EEF6BA1AC7AA89DA3A26FB83734709B333D0029A90A9
22DCBA11BD63A1E5DBABC44CC7AE39796AE10597C236725BB39991A5E7758418C41B046DBEF9
C385164B0A7E9970C92C3C2F6E3154ECAE9C0D1848D4FBCC6BD3D22B89EBCAACE894EE21DD3E
961E863594DE30D2812780EE17A49B8916D8AE6E76BBED8B7133A9007FB859AAE44994F86373
F06FF642DC80533411AE3E1A687076E5B96A95386ADE86CAC13D4638B0FE6B39734E4354A80A
602A2F4E4FB039E729A1BD5A31307A1CF7587DECC55079F876F71CCF78FB549EDA2171D7DF53
1A2330DB7F78701B56CFA5E5B02EB6375B2DF4E612630504BFF66412700000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark


%%EndProcSet
%%BeginProcSet: droid-01.enc 0 0
%!PS-Adobe-3.0 Resource-Encoding
% @psencodingfile{
%    author = "See file droid-01.etx",
%    version = "See file droid-01.etx",
%    date = "generated 2011/09/11",
%    filename = "droid-01.enc",
%    email = "See file droid-01.etx",
%    codetable = "ISO/ASCII",
%    checksum = "",
%    abstract = "This is a postscript encoding file, automatically generated by fontinst from droid-01.etx."
% }

% Created by: tex droid-map
% Created using: \etxtoenc{droid-01}{droid-01}

% This file should be installed somewhere that your DVI
% to postscript driver looks for files. It is needed for
% reencoding some font you have transformed.

% After installing this file, you should add the following
% line (minus %) to your finstmsc.rc file:
% \declarepsencoding{droid-01}{fontinst-autoenc-droid-01}{\download{droid-01.enc}}

%%BeginResource: encoding fontinst-autoenc-droid-01
/fontinst-autoenc-droid-01 [
% 0
/space
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quotesingle
% 8
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
% 16
/zero
/one
/two
/three
/four
/five
/six
/seven
% 24
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
% 32
/at
/A
/B
/C
/D
/E
/F
/G
% 40
/H
/I
/J
/K
/L
/M
/N
/O
% 48
/P
/Q
/R
/S
/T
/U
/V
/W
% 56
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
% 64
/grave
/a
/b
/c
/d
/e
/f
/g
% 72
/h
/i
/j
/k
/l
/m
/n
/o
% 80
/p
/q
/r
/s
/t
/u
/v
/w
% 88
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/nonbreakingspace
% 96
/exclamdown
/cent
/sterling
/currency
/yen
/brokenbar
/section
/dieresis
% 104
/copyright
/ordfeminine
/guillemotleft
/logicalnot
/uni00AD
/registered
/overscore
/degree
% 112
/plusminus
/twosuperior
/threesuperior
/acute
/mu
/paragraph
/periodcentered
/cedilla
% 120
/onesuperior
/ordmasculine
/guillemotright
/onequarter
/onehalf
/threequarters
/questiondown
/Agrave
% 128
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
% 136
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
/Eth
% 144
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/multiply
/Oslash
% 152
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/germandbls
/agrave
% 160
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
% 168
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
/eth
% 176
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/divide
/oslash
% 184
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/ydieresis
/Amacron
% 192
/amacron
/Abreve
/abreve
/Aogonek
/aogonek
/Cacute
/cacute
/Ccircumflex
% 200
/ccircumflex
/Cdot
/cdot
/Ccaron
/ccaron
/Dcaron
/dcaron
/Dcroat
% 208
/dcroat
/Emacron
/emacron
/Ebreve
/ebreve
/Edotaccent
/edotaccent
/Eogonek
% 216
/eogonek
/Ecaron
/ecaron
/Gcircumflex
/gcircumflex
/Gbreve
/gbreve
/Gdot
% 224
/gdot
/Gcommaaccent
/gcommaaccent
/Hcircumflex
/hcircumflex
/Hbar
/hbar
/Itilde
% 232
/itilde
/Imacron
/imacron
/Ibreve
/ibreve
/Iogonek
/iogonek
/Idotaccent
% 240
/dotlessi
/IJ
/ij
/Jcircumflex
/jcircumflex
/Kcommaaccent
/kcommaaccent
/kgreenlandic
% 248
/Lacute
/lacute
/Lcommaaccent
/lcommaaccent
/Lcaron
/lcaron
/Ldot
/ldot
] def
%%EndResource

% End of file droid-01.enc.

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def
 
@fedspecial end
%%BeginFont: DroidSansMono
%!PS-AdobeFont-1.0: DroidSansMono 1.00 build 113
%%Title: DroidSansMono
%Version: 1.00 build 113
%%CreationDate: Sun Sep 11 16:42:37 2011
%%Creator: Mohamed El Morabity
%Copyright: Digitized data copyright (c) 2007, Google Corporation.
% Generated by FontForge 20110222 (http://fontforge.sf.net/)
%%EndComments
10 dict begin
/FontType 1 def
/FontMatrix [0.000488281 0 0 0.000488281 0 0 ]readonly def
/FontName /DroidSansMono def
/FontBBox {-312 -555 1315 2163 }readonly def
/PaintType 0 def
/FontInfo 10 dict dup begin
/version (1.00 build 113) readonly def
/Notice (Digitized data copyright \050c\051 2007, Google Corporation.) readonly def
/FullName (Droid Sans Mono) readonly def
/FamilyName (Droid Sans Mono) readonly def
/Weight (Book) readonly def
/FSType 8 def
/ItalicAngle 0 def
/isFixedPitch true def
/UnderlinePosition -103 def
/UnderlineThickness 102 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE373DCBE8503A9C1BDDCDE3976B9A
FF31FADC784CD99E8D913C26819A4962BC428320D924CB0D4BE15E2EA33CD98F
3A3090D3A2B1C56F2D8E679576FAF3FC1A79261690287D7B9444B1B4E36B6E78
13E34916336239067A606618EB045356D480135F7C325841F7B5598118DE9F10
DC40B14F98881CE9249D25473504F621ACEEFEEC415938B11B1EA0DB33CD14DD
BF0F9224FBD2D8BDC80385967061093CBA04EF9F2CC7611612A7B40A88C5F557
0EA7B75CAEE65197D76E2EAFF968FAFF7C1105A090B060815E8697496A2B3C11
8E549867F4EA9B5705809091926D0A7BFF47951C2A331830A3E8906D833639F6
B83EF85376AC683316D0057D71B641B50E7BD7EAF5F2E96280AF5ECF30CE4C2C
D107E589D834A70BF48C67B20A5E1B05CCF917A7F2A0F6113AD23C5E8344BC8F
9883B48B4CEE8BDF5A8F7D3358DCAFA3B0F493245323727F86F69963F599DEA7
934CB645668A5001DF819F237E18866ADAD82C6430A05E642263DD0F77D1F3EF
36953D12C375524FFC188AC93B90E1E7B35CDF3FD3448F8EA5145011B43501E7
30E688A474D29AD478E7CE9E8DCC9EA5A81355B572BF756D31C950DB742CB149
5338B6F02A2C45D62902B088D4130E94F4246F0FEACD2ADF866CF1951E9A2360
7569A43D83A434C282247306C26C07DA47D1C766793C7FEB7FE0131C5E5D190B
02D425FF1774741D95EAD403AC215655949FC690AD7C7CD5A6C3FDEA269D8064
257F1A91EC1248B3EEA2D67D8D7D78081C5A887708C37E4DA0DEEA01067F0284
0CE5C2B4AC86C0254772AEDE32F9727052EBD77E7C7C30BE8767CE6B701F1F8D
ED8A56CF57EDE5EC1F6A04DAA6A6BC5F32B332969C5FABF7E0F8DCCDB7AF8FAC
C57BF01C87C9E216F1CD3D46729E321D305A1D4427856F07F221DCB9320806EE
7C4979C200D00807A66F123EB576FE40D857C80C08ABE3E13CEF2812961EF45F
9EECD6A335FC925C041CCF1E8FB121DBA4CF2A576258C3DC9AD0F454353F9E17
A1B31F7515C8B83AC542FE1E4ED60DE27CFE249547B41664820E0DC702057AD8
CDBF312907DDD998F8EE3C1B49B17E1FE836FAF4E42390CE0E695EED42E02CED
F761A6C77B517431C6C642B366D66154BE6EFD07E954D33FB951BC5BBF373B2D
D5D93244F20101319A9BB356C5A06C350245C99DF65D16B85E63FEB931F892C6
8B2730A76D29CA4E1F8D29A367878A81AB02413A208AFC2F0C7C4FF9588C4ADD
D36FAB04CD985E1F4FFF1F6B5449EED97527479F73E07FB7572FE959709C53D9
BAEBA49B4E2FD4F2F5078771006B692F2108230EB4409726D020D6D36AAA7148
39447EFEA24D1557F79A4E7EC19E1F6500130860218654AF2BFF34C280D02F2D
7ED5F641405C33E6B2EFF71C25E88A4DAE95E28F482B2C6A7127EA1DB06E29FC
A51119A7B01CD7BE8995B00E9E13D45517C941104A2D7D01EC34F071DAC36247
42FC6BE985A39D7ADFF40A60C7E202DB07C9683833A418EBF597A739A89712D6
F1D62D67C10D0698D821121554672A1E403F7E162CF0A3BDB53E46CFCE7FBE8D
487919F1FA5E123E760EFE23968B43B56CF69DC816726088BEF43AFD58EA311F
01E93B89F9E8A52B1FDE56FD45CFEAB894A9589809D78B9D063B708F19B304D6
C4460BB1FF216626DE1A753C673B15485C6CACCED5D673466624D5B7B5055163
69FEFBA380B128D1E7CF75F00F5D88F722A7FADE1889A864C478A6DF2A43507C
7E146B13147F6D4FB431092C23D24476AF8BB675A46730200326CB5AA7A847B6
DEF9A9A339865BF013007A8BABF6B87E1D650F46442CCED8AE80A622355215ED
0BE90A475C404962FB698A856689D7C6E6853F86B21838FBE10043709713E69D
53A23BEF3690F3FF002E9B791227164B28DA71377B1E5C6F3C37544C1FE5D202
F33AD94BA888F9755173A99C2B9CA25599DFC182AFE70BDB41E4C2DD784181FC
4F1B0B6F321C27FEBAB8C6516ACF9FEB60369FDD4F9B52BABA499F08D5455646
AA7D29F964E21FEB297C0C83F801E703278B203DE266E979ECC4A5A48899069D
C185362E2CD321960A8BE97917C9D8529DDD34B9E62DF190F7F611FA57B9A55F
ADAA3E356D4681536E1102348473AC0B2F6315BA657F1821ABA0AF799DBBBADB
8B874BD28232BA7AAB08961276589B77F1A23E213F5DD774BA5CC9C8605A4E19
480657A05082DC35541BE7500524E780517E4C14857B50FC75124171B0A7FE45
88A1789E5A769AF17CCA8BDB9D1F6AE30DB8E500D7633ADBA4351A548F496536
21318652FEE2AFB48C326B222A95917BAA039CF87ECBC7B783361B0601855D7E
82138B087F7B1196AB91531B42AB824D6CD5CED1A5D842133CC8A580B40E0060
6B6B0C7A9DEB1EBCBDD1E47B52D7A2FBA7E87F08316291049E991D6FABA93194
601B073943175FE159B95F1D811DF920813DEA061E78039A6C9DA1084D57E3CD
B97EC6D1BA47F2E4D0EBA5EFECDB76885640AE6FE12E70C8F5BE88975BB613A4
E0DA7A98776C8DD00547BA20F1CD11EDD31A31B81FC880F74DD4BCFFE57CD206
4ECC282C0FDAA964F86A0532E7CEBBBC8AC5F3EB39D8819C6B233D1179E8D9F5
110D973A7527912DB075731555EF63C8B78C9EE0874C8DD97ACF3311F1AD9FDA
A59E7CCAC5518412C12EC7D57E8F38B48EB6C12735D1DF52F3D6DBD0640E3BBF
A35FF3772F9D7C9CD3E7C4018D48072CF7A7DB76FC15D8B8B0A50492C7F179C3
DE063F3EB3E82B49C0967AA09BA3611DB57A51067A5435F66B583267179160FD
0953AFF7B040B0A3D4EFDF380D6158EB975E2AD95E6D08BE0262FA8118169FB6
3728C718D6A1642D40B30730127CE15931DBDC67385162AA65D0B30D49032E91
D94FA3763F83F78E6D180B6F8724D5ED36070E82EC5DC7AC609ED6C673D09156
753900E6746C8A9562009BE25463C75FF222AD61A5C84D932E78ABDB6AA77737
613CCE1334E9AF557A0E7911E4802A957310320A57A65DC2659915D15D924681
1B783556A75C5129350C8057B12625AC2F0B6FC891D93B872957B8E258616810
3352FFA7E6655B4A573151C86C409077951AF9906981DE2B368B4D6755E181E9
C27C1C949A1F9EF2213673A1DA0A783402D72E67A5ACF6C5D19CC7631A8C4547
B7C61A5152CE2AA713E0D15EFE15E1667F34498E00CE12A86E5C4B93405B54B2
8803769EBE084129A96211C94C2D82E92D180AC1E0DF228F0F5007E918E7CC3F
7E43ACD3E23BDF2BB23BC22A8499AB096AA37AEFAFEE31757EFEE0B260FF1B90
604777A73197EF3AEA8E09DB9793E691636E6DED867868F2225E5BD2B3EAA400
690BB9B446B6D44F14559FAF11C11FD6903E160B2B6CBEE66455F3D5EC9E99D9
004E8F40211595D9BC63F8A86CC5D0E24BA91CCF31C397E6C445C36BACBE1F99
F1B49725FAA4485EA21711FADE4857ACACDDE072C12C72A4172DBB66EA1D2F0A
8656D837C8516FDAA87E707446249B4173B7BE4676632D33892F6AC710C258BE
EC82BC9190792341419A6E4046BB7824F6E8F96A5A6AB14CA773CB7287E9B429
000C6644B8E5843AF3C927033342D0FFAF3A5DD05E010747E0FC72E2D1715BE1
2C350CFB147F4E8C8360BAA08E6D02BE5F0869652AB7D69E3F375584F3216148
C2F9EE272F7058FDAE0AC0714F1E3D667047C28FBAF5D0F9C20AB2AE480F7423
6CBCE30D24A7597D1302AD477770DD4CA8904E48D323FE6A6E0C97B869B2664A
FBBD7A3B9D0447C20B22FB841F7A522ACBCAE9225910CE401E16528A1A4C8B9A
3567AE183BB92A7DF0F5A5314E928133BCB3480D13CD9885F09B33C3CE89BF97
6A9152AD9DD2A9DF181B59F6147CEEF8E6E6E7304FC734A62EBB13EE4FECE92A
D95A7568B84E88070DDA4079AF875087762224F119927CF0DD2CF980867EEFCD
8FC18AE2DA5D5FE596029C36CC74B8B78A97F02CD6DEEE13F2E69602215FEE45
0043A634C218882F8BB53283360EFD552391A86E913C583580DA7A70EFCB8235
DB5933CF4EC43A120B257A26E445AD38A5F1E278E99AA21F2EADFC804405F36D
CD2315FC54A2C925056DB4F785E1F911D75B47C146A29077D730D92A8069ADC4
67F8076A61D81F769BFA7BE35B0B8390FAEA196B28DD13D9E767A2939BBAE97B
7FFA81080BA4327D54B73437A170A6BFDA5B6C0C462A6BB1676440E55CAFFAFE
27D06EBE96D273AD041930A15C1736F4326846A83A7560FB1BEE6A0F8C9F67E7
B9A8F8C6E9AC6CE612EFFB2A49AC14354279066A01F4786F5A4B6EDFDAA20ED0
8BBC44DBA28E86BBC12DF7194F1981D638159F945778F44CBEBF2DFEBBC78DA7
A67809042F25767E34097C1802CF0F225CA337BEC37D40504318519FA9AB2C60
86661ABF225AA53ABF18C908E902653ADCE8183CC3205F0C313135D4B498229E
3083A823850F90A68C315C8B5886CD0EBA6EB23B59452CE5B8BA3B04BD8A4C64
2ED8A0AD557F759AB96221BB13B8494A0119F4B8278FBC8A9F2C4304485CCE25
4055D7D85760C0E9DF3C42E9CC0E3E2F0791A25F4E04A78C02994B0302EBF9A2
9319628CE31600E7495491474DB872F8CAB12D95067137DCCC11814E015B1E78
99EE1D7BE31FB337DB83A746105045BC72484E8FEE7BB0FF4D24E79B375E4BFE
4A33A36F87CD5212C7737EC156E42D3AE6C9FE58EEA5C1B1039A7701274E76F9
BAA20A6064E688CC733B3735C28442ECCC37FE36FFB4DA3D3D200294DC7C344C
64FBBA08BF2AF192F3A596747DC380F602F2DA14B62969BE07D7123B58AD659D
8729ECB62F34CD22B141C5EC591F9029C5C0CF22BAEEE516B9B2F75FC667EEE2
9F55C637307E54C93F05A9FA0C11E5BF641322CB49B98D3D8EBDBA36022A39F0
8FC8DFF6B9ED8683754D8615B12949B6DA8E3DA78B5C1E823FA5642F39C309D3
872B9EECE14CDFA229C97C631F66D988960ABAF0F3F0C84E22070B4A7AD4B848
0B1C6E6F6520E75540B3DD6ABDF13FD5CA2B869B56FE92FA90B00D3751903F7B
9AEF350B96A94EBE769EE0A94C2D5505D390F454C5CE288492CCFC48E690C39A
A6C3C807EF909E19C15D7EFBE0980F4F64FE7DF5FD1EEAE89A079ECB3B091022
60452EC44F2F78249D3ABE93CAD38149CA189FBB868A34D0FB8E5D25D1BC6293
63AD650F7B726490901C6C1B46668EABE4CAE753F9BBE0AB579D9B1AC472EB29
B9FADA7D0E3F8BA1FDA9342B7EE986217AD6611161A0777AE41FD228BCED799E
DBB46C7B38C6C87077EC26F231DBDF8CE3A3AD443964831C7633C13900D28A7D
E5BC3AF63E24DD66979281324323DBD4ED30908C5EEAD689051F4D8B6C7B3867
152214CF90D0DF12346CB89C849150947A6B90C567A088F403328774BB922A0B
32D63C585330F620409ACFA0CDD3153A633356A487EF9C2A20522DB2909868CA
7440A7248A37E9EACA7CCB01C249B95618AAB24792A565660CB679FB0DFA4986
A6B1243F0591C8204974FE42544554761BDEFA3239CC53D9D34ED48D8CE236F0
5DB43D702C67851DD747381CE30F80C79753E36F7923786C5AEF8E6E2C9BCB2F
74F6CC182C2942F36CE8F55C8A140FD76F2FA048EF0433BB4AA58C6613B9A228
A1938DF5A39F2D89C7355744719710623960B00FA57995D65F2A54F3B86DEBDF
A1B20033C4657FCA9D78FAF057D0E0F431C62DC461ECE2E696877F9F0CFF372F
6AA8E0BC0F793C38CBAAC4F6AB764E817CA3B525293B29D559AF5A53F67CE11A
A93925227BA2565B281987A259334E7B9B3063C459C0020D6DA5E9018D6AF35E
978779236104086149F79B914111202708B4FB7558F0984EC8C44BACC28CC8EC
7EFE56990FED205D041A38949617975091049251F360A5262E1937017C557611
DC2CED01C89E2692BDC169A8AC6C61A5270C6FE748336DCC86A95294F49A15BA
D9BF50354382CE6164480C2C8C983C09415F2A428B0F10A0660162509D50341F
B03C67BADE5FF771EEF8440A5C147052EC78AAC836DEAED19B230C4323A6D226
ACFCB0758BD2AA325B5C24D81CD308F1B3F9234E147666C4E3287F1D1742412B
BABF605C89F17157592926F38A590AF218BFECA464E6C238AB9F6239CF4FBFD7
F92619993E02197BE2C199DFE914B9196341F9209D60E6721127B860AAE3F745
01FC8E35C24C52821CB1BDEB164DFAF59DFB2E9EDE221FB1825D10BEAE907C67
5FB099C55F8DBFB23E0C933191DFEC09BB047A49EDFB924D328010FF0A490453
0D6C924A76C328659EC93806C419B3DE9A46CD9F82BA5B18B9580C7B7CD6E179
8064A773213E4C5B2D20FB58A2C1286B1063FC5B7854616B154D9CA3B9177798
E159ECA8A440FBDE3230B044DD04D583AFCF89B3BA4903D6698865D9C67CE34B
1E3EE68C21C59DB248E7B6FBD5361A74E2A8DFEB42B87A3A58812BFE9DEE329C
2986D3E657D475A747083C86B8A96D620075C8CF2E8003E79877F47F0A201121
D89692B56A99D264082E12D0E9EB79BF167AFB496F49FB990C742DFE196F4154
15E9A53C156C2D319FD55B5DC4A5BB5C12107A50228AEB6DE9CBEA655C9A4914
3754B0C8FA189540AE07EC557D0C630664D933A7B5B1C5A6F1F4ADADE3D53F41
D6993AC2BF64C2A2F532F99389CA7D18E44402BFE7670EEA181EF130713E7F1B
C6BB77133C4E401D64E24A7F057B1F4D6C794B45BC888583762847C8CFBDAC79
EFA95C90341AD2BB97753F85F57C048531940911D0AE1D238E87A5A52BBF7A65
7BFAB442DD2F411FFB5264A9152862E949D211FD361BF01EE4499AC6C4D28960
EEEE297522D82814D5DF9E72C758F79DC4348D3795BCA7E15F16B9BFFAD3D4FC
584CB47F1D7F2D79514E34CF1EC2F6EF61842BBC442BFE519A89FFFEEF07B7E5
335757000EBCF90F181931EAD7F377BEC6ABF3E0C2FE8C81885A86901461C4C4
DDD437591DBF901220EA0163B16550625BA0D8916FD919B93DD079E441AC4409
EDD50E8CF0D1CCA8DF4C541733BE29BB27E252A69017D6BA178616B028A263B4
946790702694C760BC549E9402E0C9BC6B5E31E203E2078FDE405110B7FACC7F
9A72073D082288580713AE57718AD41E55FCC04FF10F6F071CB521A0BF2D965D
DFC1696AF6E6CAF2C9E710B8A354A6BCD1C1A7383A91B22E79C58887DDFB2B01
FCD0B06EC075B2277C7F35F2811C1F945DD6A3F6E840690573AFEA0E9333D9CF
A72EF00DD9DBE17CDBBFC03C7888A6C2612719D7DBC5D93E370D40FBEB2A081D
32B2660AB332E7CE3167219EC9814F6748FFF7E1777AF1F8B29B7E41777FD327
7F570447EAC45534646FD300E1D161FFEA049EE901D4636EB7A8A0A31E9DAC2E
114B7A977FDBA490A70D5ECE4950CAC3B074B5C5CEC4761493283FD4881521DE
69C44E040C2644F665E9668544F93971DC65EA6BB9AFC3380751FA348F4437CA
0DC829A08BCEC034247EFD266462EC21518CC1079460DDA972B5DD3B6EB432B9
C582CE256C419F50D62FA599CF1670C77F198181C5D5BE077DF02E79A0EC3CC8
D6799E6C63C2F7AD5144F134088B1D682AB64F14E4D7B38613591FFC64C11141
696D157EA3380579B23076014570883BA57E67D810E29DD5E81415FA539BEB50
B268839440428028451BE8E502EAD429D6C397DCAC3F034C111A052F774C8657
CD7E9D11BDE954CD5F30AE8580125CACFF19583D9928A91267288EB687F94654
DC744B8F95B72450041AADC1919A9FFFE7B954001515E50413E5A872840A1258
DA043FB502F6ADF28EA15435F8094595CB3C8608DE3D07E10938B732C07E3BCE
3F328415B220629C4571361A273C55655FAF7C30945AFF89C94364C54F45850D
0051BCF033981F2DEC82933D46BA117AAFDB3E2C7FAB2197D96A813F17862B87
C2C316FE145E74BDA43FEDD031C04713EAA5C770471B00A007CC49B05C1D67ED
458D790677939BD09C27892C4B5F51462373883E382C60C08455F2E6B901BB10
B83DCCA0882D377BBE4F7389C221151AF700B49B10DA97166643D6E31002F258
375ABF7363EC618E2089666C2E7EA9DAC79F517C74F4256B50FE16CA19A007A3
A0797090E0A00E8F04A8F0D0618B205FB763E55C6DC1CFBB57A7FD32ADD5C068
232DF7290945C9CB5BF9A63E8495B32DB46D794C7EEEFE3721E323A4CBAA55AD
3D8B5E90C95760B0567DDD8750A7341B03203EA5DCE12F308129FE8AB26D1081
0FE8EE63BDDF04E9D56F794012D4DAD35392F4534A96619D2DE2C6FA3891D452
053E7324694C58BAF9DB4D6F83DB94D062EF0A90709C1FF0D86E97A419770CF4
C80FCF726C27E58098C0B4A14CCDE579528F1B13A500926F9EF8C09B19F43B24
9A33B25490C4B76202BA7A3F5813D574C4BA6C7A216ECB05D24122259A7C4C07
19F9D7AC297535A76C960BBFAE750765C02E9E2EE3F3D44767EBDB4E6683D7B4
BCF129C9E34E7B1472102DB875FFBE7EFEF31B9E1130131C6FAAB40E83E30983
F5697A499B74E5BE77C0F382A8C09627AD9E208094C77660BC3C66762ABAFC11
85C664200CB92B402708C69FD79A9025F789FB2BF288BB215A11DD6537070E79
79F91142DEF4A579578D86D95D836D5BF77A4CF55EC4F79143AD0ADDE5F593FA
87E8AB3F40DCFCBD25335A488105521CCCE3F09D122E6D986D07F23D74BEF39A
A9436A8F31FC6572FCBEFF929383AB050AE85E260B2E7D41F8A74AB11B7C2954
6D507906C98514FEF2C565ADEB278FE66060E584A21F2D7111D2C542E41B79A4
64AC6BEF62E47480227A17E34C1705C9A3BA688A22FB384F03345D5A46F411FB
3FFA7C70
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600 (IoTBnB_Logo.dvi)
@start /Fa 249[72 6[{ fontinst-autoenc-droid-01 ReEncodeFont }1
119.552 /DroidSansMono rf /Fb 221[124 34[{
 fontinst-autoenc-droid-01 ReEncodeFont }1 206.559 /DroidSansMono
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 506 125
a
SDict begin H.S end
 506 125 a 506 125 a
SDict begin H.R end
 506 125 a 506 125 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 506 125 a 0
201 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 0 201 a 0 201 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 201 a 0 201 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 201 a 0 TeXcolorgray
0 201 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 201 a 0 201 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 0 201 a 0 201 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 0 201 a 0 201
a
SDict begin H.S end
 0 201 a 0 201 a
SDict begin 12 H.A end
 0 201 a 0 201 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 0 201 a 0 201 a
tx@Dict begin gsave CM STV CP newpath moveto 3.0 neg 0 rmoveto clip
setmatrix end
 0 201
a 0 201 929 201 v 929 201 a
currentpoint grestore moveto
 929 201 a 0 201 a
 currentpoint currentpoint translate 1 1 scale neg exch neg exch translate
 0 201 a
73 165 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  [ 9.38936
0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  [ 4.69466
14.2263 4.69466 0.0   /Lineto /lineto load def 1  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial -121 x @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  [ 9.38936
0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end


@endspecial 50 177 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0.89804 0.15686 0.15294  setrgbcolor
  22.47754 5.97505 2 copy moveto 7.68219 .5 CLW mul sub dup 0 rmoveto
0 360 arc closepath  gsave 1.2 SLW 0.89804 0.15686 0.15294  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
158 203 a @beginspecial 71 @llx 685 @lly 110 @urx 721
@ury 198 @rwi @clip @setspecial
%%BeginDocument: earth_only_red.eps
%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.995 Copyright 2015 Radical Eye Software
%%Title: earth_only.dvi
%%CreationDate: Tue Aug 23 10:14:10 2016
%%BoundingBox: 71 685 110 721
%%DocumentFonts: MarVoSym
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips earth_only -E -o earth_only.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.08.23:1014
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/07/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Voß <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.07, 2015/05/13
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  25 dict begin
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan /RotAngle ED
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  /mtrx CM def 
  x0 y0 translate 
  RotAngle rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  mtrx setmatrix 
  pop pop pop pop 
  end
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: MarVoSym
%!PS-AdobeFont-1.0: MarVoSym Martin Vogel's Symbols are released under the Open Font License - look for information and new versions at http://www.marvosym.com - Neue Versionen und Informationen finden Sie auf http://www.marvosym.de
%%CreationDate: Mon Aug 15 18:49:48 2011
% Converted by ttf2pt1 3.4.4/ft
% Args: -b marvosym.ttf
%%EndComments
12 dict begin
/FontInfo 9 dict dup begin
/version (TeX version of August 2011, based on original Version 3.10 November 04, 2007) readonly def
/Notice (Martin Vogel's Symbols, including this derivative with TeX support, are released under the Open Font License - see http://ctan.org/pkg/marvosym) readonly def
/FullName (MarVoSym with TeX support) readonly def
/FamilyName (MarVoSym with TeX support) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0.000000 def
/isFixedPitch false def
/UnderlinePosition 0 def
/UnderlineThickness 0 def
end readonly def
/FontName /MarVoSym def
/PaintType 0 def
/StrokeWidth 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontBBox {-572 -214 3014 925} readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 109 /Mundus put
readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC1325EB8F274DD24A5D21C056364
13EFC099729365596A8A52075A624087116520034680FDBD3E86220CBF46C2E8
2BA32413E26C0AE960BB760BE98B2E1348D6A21CDB5429260899F7FF77617B00
E876499AFB997425D58673778E90672CE2F26C816F6EF6C1F6F0724D575749C5
5AE9D8CD0337709436E75CF2354AFBA7974814727450620BF79E10457E31E899
430F90AC9865F70FE6B6777C3B647DBF5479B987AFBD6DBAEA380CEC42950CA1
9398EFFA54835435C20242F3FB6E2D4D0F33709F3F4688F2B1ABB86C1C7D0C40
CBADFF3859361F0E294F6421F96BE4A820EEC1188E59979880AE63401B5B2BF5
3AA062505CAEF95F51082F2F2C7DBCD0265CC4A4280B9E7BA9AA4A55AA351944
E9434319CA45CDF64BBCA106BF20E354841689809C65F0CCA6D58112721C9987
318B070A20DC356D4F494A78CCA77E8F9741854CA51B991EE73E30821344793F
AD6FAB5C17E613D37AB0A7C0CF510787AEB1646AD5123693726318B15218F38C
A647F26041ABF557285D5CD361A4AF64FBF5F499FE5B2731B7A16C2004F81AE1
B8EFDFF44C5DD939F581257797B71E3758B864AE320361B778A056F6E6B71830
1ADEF988E22EE2269B0C66D5F2A30DB1E6E334F4CE1176121A2C97B92EC06B51
9A76FBFAC2AF1FB274262FCA60623AF6D9E93D1D1610E3BDD74BF020A63047D8
3D19B786CF4611FE9C9CAC0C65C7D792B49FD379FC0030FE314A6716712E9731
B24C0A7FE6EE1551AFF5AF8A9E0AC0920A13610136D6E15530FAEDAF5D6C7BB6
E40E631D6C201F06BE2CDE3E66CBE21AB4D31A6B795F50DDD06976F9EC715E4F
61100E646AB104301E65B6B0A91B8F9DC28CA15355FC276525AE2AF269313CF9
3D623E40C1F5923206BF85B9236653BCF5B778E879549BEDCA3C0660DF163D05
FEDD725D8B6CF2CC844CC3AEE017E8E811936C6DD52963E287AEB1E5CAA9D76D
3E1C7C1231857D7494C2E8323E46475DE81413E77A020F43E22F3C46B1CF1C8A
F240E07F8B6A8348CA52ADB8B5D58B85FBF4031B6BDCDB5F0437844700137452
BA2376042E9B35641EECDD51E475B562342E7F199691B1C387276A2821992FA9
EBE0366DD6738A8171FA2353C6E9B30409A27F4C75B5076CAE2951F7FAC3669A
1467135F922EC7AB4F5C68FFA72D4560A7335E67292774BD6F52AC26A23EA3A0
54062821C12770801BA3DB73B7941DA28E8E002508AA6F20C8424FD8DBAE041F
15853EBA5D1D8A5BF01EDCFDE48A0027166222E1BCF36321870E95BC94C529FD
73E3B50B59229DA2BE7A10FF079B3536C421F3E7932342AA28A6FB3050AA717A
BC5672BDD9C3AC7CE3A7DF08FC6B63057CEFE70E5B5AEABF16E8FC605EC93489
202873AD84198566471D0EFA1A3DA95B0B0650154636898F2D1107B14199149E
E6CD4363F4785F5C4C4FD9BC427A11F4FC8E5050CC66365E865A48F44CE31B2C
3FB56029F094ED0E695C771F3DDAB2F3AE95394815475CD8E5213BA8BB7B7ABC
B915F086F77947F2A0BECB6B04E59EABF1C0E7466FD9AEAFA2FD2330D97A7346
D871D210B0658644B95F6687004EA429056C193B2806EC9E264E9E31E1A484B6
D8EEDEAA067BAF2DD5F579C2A99F39273EC965C90990D5BAFBD13C5C89DFF5AF
D8C5FB3C85E44BD0E1DAAE90996CA61AF2D33A706CB1C9E69C1B1E3438AD8E4B
6DBA729AC60D1891A5E187C8CE9234F3CACC9D3E0CC4B478C570DC418D5820B5
9C8215A0A4A4A791144B2B1650ABE7FBA7214DBBFD95767B57687C57A12374D9
875C7A649B653CD4A14E0A3A350D10E0635DC0DD0AE0B81DEB15DBA116BFF277
D243D9F42CF6B305AD9D2F0F773B3CF1835F3F862FC57EB0CFE4817F3CCB3EE2
087AC0081659346C9666E7E0D09A50E7ED8E7D0745221CDF3A57AEC727DAE788
8B41DB7CC98648D18BCF1E2D90DE19CB80A862DA36D06280CB428A2CCCAF7185
A2FB5FC10F846AD42B80504EE7AF46F9B55A5F9FEAD24B9BF44FA7C09BC1F1CF
78375E6A6DEC53DA7E9D81391FCA7806FDF4127E3245B665A7083AAF403204B5
5D07B9ADD78B73234D7FFA011BFEC99AAFD81F206AB5C774EC6C77D83B578A39
0FF965A7AE22DBCBE171EB00B5D2AF705BA407D893D06D74ED5682CD8132DDCB
C088EF8C634311206DFB3DD7FFCB8BCA6382170414ABDF55DE6EF561FD00E059
C3CF8032E9DEB8F2624601AD7E442627D96E3902749392FA06CCD5FC282A1034
5EC62C60D14E9637C75FD48C65C1E9198756BDBD0C8FFE118D38F9F0ED08EA8F
00A57C42443460B1164BF2D9D4966E45DF80CD252A7E649ED2F2BCEB1F944023
7EF4E25FCDCC82923DAE4E1C887829E8C58D7FF62192278EBFE95B8EA558A243
747C12A65726E7F55EE476F629733A64AB6B3FF55C5C0DD6BC0F9E88BE34EE81
A027600395A2898029256343CC4C972F4EECCED73F4D06DAC89110AA37A6315B
FF8C29D6DEF9B3CCE28D8A7BC27692E224E02C42B7BB4CD630FF508E45390DB4
3AA0C643BDCA527613417994DF7A3402FA26F716EE9CFC0A9348EEAE108A60A6
20CE603FC0CFE0B91468CD30482BBEFA37812E6670B1323DDE5C30920190072A
8EEB9FAA2301F39F96ADA46CDB2E247BEE95EDB2E4EA789401B5D8077D43D6B2
E2EB3214255C6B7715C13C91CB3E5B65A49B0D20FDFB155057AFBBE75F09FFA1
AF1C00ABA0A0EFF164838E86F16554223D8480FFA052C9DDBE7658DF15E5B8F9
FCA3CCE2651FB35C8B5ACFA0E7E8A72A7E23BE48AB73251B9CBEE10F0FB93202
068BA3CAD9BE6AE8084A51E21ED6E1BC350A351366BD2FF770930B2B69B1EC2E
E4C83510F989E800DE33431DB992C2FEDD8E067F62262114F60D66482101A365
6B6B818A18EA63873939E3E3A93252DED02C935643D7D6531B707234147B1E51
DE1F64A8715F05C042B771DAD8C755CE458E371B00533161BED8511BA848055B
418F220FDDE81E3469846DADB5336147E5429118C4774840812BF173B511F766
683A3A349947C2D18630283D884880FBE94E91B24FCD08C565922814904DF365
208AC2C8CEE796FD84DB00B9E92A11E01CA42B2AA226F1D39B09CF15DB271F18
C2519F154FE177396D4E03A6F22C98BC3CA1E1FE47DCA84CB6462AD232103E10
D7EA35C788486B1EBE02BA523509BBDA95C43B15E3F9894E9ACD3B2859144727
01236188A6F8F039E666ED0FEA6516DC58388DCADFDDBC0942026A29B5061A4A
93D446E10D18AB30EDFC66787D9C01B7FAEA1F66AE081DF3D44236F012C557C8
076772576CB116783153C2DEAB8CD542F0B08C75E00AC57C816B372E20C26603
74BF09AC498FB3AC9A3E1BE52953FA41686599DC7213845478725D54DA531A03
75CEC8BA1827C27DBAFD6555A364CD1AEDA1A5DB57
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600 (earth_only.dvi)
@start /Fa 146[169 109[{}1 206.559 /MarVoSym rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 283 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 0 283 a 0 283 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 283 a
0 283 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 283 a 0 TeXcolorgray 0 283 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 283 a 0 283
a
tx@Dict begin gsave CM STV CP newpath moveto 3.0 neg 0 rmoveto clip
setmatrix end
 0 283 a 0 283 309 284 v 309 283 a
currentpoint grestore moveto
 309 283 a 13 254
a
 currentpoint currentpoint translate 1.6 1.6 scale neg exch neg exch
translate
 13 254 a 0.89804 0.15686 0.15294 TeXcolorrgb Fa(m)p
0 TeXcolorgray 13 254 a
 currentpoint currentpoint translate 1 1.6 div 1 1.6 div scale neg
exch neg exch translate
 13 254 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF

%%EndDocument
 @endspecial 253 21 a
 gsave currentpoint currentpoint translate -86 neg rotate neg exch
neg exch translate
 253 21 a @beginspecial 71 @llx
685 @lly 107 @urx 721 @ury 85 @rwi @clip @setspecial
%%BeginDocument: wifi_thicker_red.eps
%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.995 Copyright 2015 Radical Eye Software
%%Title: Wifi_thicker.dvi
%%CreationDate: Tue Aug 23 10:17:35 2016
%%BoundingBox: 71 685 107 721
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips Wifi_thicker -E -o Wifi_thicker.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.08.23:1017
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/07/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Voß <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.07, 2015/05/13
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  25 dict begin
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan /RotAngle ED
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  /mtrx CM def 
  x0 y0 translate 
  RotAngle rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  mtrx setmatrix 
  pop pop pop pop 
  end
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-3dplot.pro 0 0
%% $Id: pst-3dplot.pro 882 2014-02-01 13:12:37Z herbert $
%%
%% This is file `pst-3dplot.pro',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-3dplot.tex'
%%
%% Herbert Voss <voss _at_ PSTricks.de>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-3dplot' is a PSTricks package to draw 3d curves and graphical objects
%%
%%
%% version 0.32 / 2014-02-01  Herbert Voss <hvoss _at_ tug.org>
%% with contributions of Darrell Lamm <darrell.lamm _at_ gtri.gatech.edu<
%%            
%
/tx@3DPlotDict 200 dict def
tx@3DPlotDict begin
%
/printDot { gsave 2 copy 2 0 360 arc fill stroke grestore } def
%
/saveCoor { 
  dzUnit mul /z ED
  dyUnit mul /y ED
  dxUnit mul /x ED
} def
%
/3Dto2D { % true or false on stack
  { RotatePoint } if
  1 { %  dummy loop, will run only 1 time, allows exit 
    coorType 0 le {                                               % the default |
      /x2D x leftHanded not { neg } if Alpha cos mul y Alpha sin mul add def %  /\  co system
      /y2D x leftHanded { neg } if Alpha sin mul y Alpha cos mul add neg Beta sin mul z Beta cos mul add def
      exit } if
    coorType 1 le { 
      /x2D y x Alpha 90 sub sin mul sub def  %  |/_  co system, no shortened x axis
      /y2D z x Alpha 90 sub cos mul sub def 
      exit } if
    coorType 2 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x 0.5 mul sub def
      /y2D z x 0.5 mul sub def 
      exit } if
    coorType 3 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x -0.5 mul sub def
      /y2D z x -0.5 mul sub def 
      exit } if
    coorType 4 le { % Normalbild in Trimetrie Skalierung so, dass coorType2
       /x2D x -0.5 mul y 1 mul add def
       /y2D x -0.5 mul y -0.25 mul add z 1 mul add def
       exit } if
    coorType 5 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees 
      /x2D x z 0.5 mul Alpha cos mul add def
      /y2D y z 0.5 mul Alpha sin mul add def 
      exit } if
    coorType 6 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees and z into the front
      /x2D y x -0.559 mul Alpha cos mul add def
      /y2D z x -0.559 mul Alpha sin mul add def 
      exit } if
  } repeat
} def
/ConvertTo2D { true 3Dto2D } def
/ConvertTo2DWithoutRotating { false 3Dto2D } def
%
/Conv3D2D { /z ED /y ED /x ED ConvertTo2D x2D y2D } def
%
/ConvertToCartesian {
  /latitude exch def
  /longitude exch def
  /Radius exch def
  1 { %  dummy loop, will run only 1 time, allows exit
    SphericalCoorType 0 le {                                               % the default |
     /z { Radius latitude sin mul } def
     /x { Radius longitude cos mul latitude cos mul } def
     /y { Radius longitude sin mul latitude cos mul } def
      exit } if
    SphericalCoorType 2 le {
     /z { Radius longitude cos mul } def
     /x { Radius longitude sin mul latitude cos mul} def
     /y { Radius longitude sin mul latitude sin mul } def
      exit } if
  } repeat
} def
%
/ConvCylToCartesian { % r phi h -> x y z
  3 1 roll			% h r phi
  /Phi ED
  /Radius ED			% h->z on stack
  Radius Phi cos mul exch 	% x z
  Radius Phi sin mul exch	% x y z
} def
%
/SphericalTo2D {
  x y z ConvertToCartesian ConvertTo2D
} def
%
/CylinderTo2D { %  r phi h
  x y z ConvCylToCartesian ConvertTo2D
} def
%
/convertStackTo2D {
  counttomark
  /n ED /n3 n 3 div cvi def
  n3 {
    n -3 roll
    SphericalCoor { ConvertToCartesian } { saveCoor } ifelse
    ConvertTo2D
    x2D xUnit y2D yUnit
    /n n 1 sub def
  } repeat
} def
%
% the angle in the parameter equation for an ellipse is not proportional to the real angle!
% phi=atan(b*tan(angle)/a)+floor(angle/180+0.5)*180
%
/getPhi { % on stack: vecA vecB angle 
  3 dict begin
  /angle exch def /vecB exch def /vecA exch def
  angle cvi 90 mod 0 eq { angle } { vecA angle tan mul vecB atan 
  angle 180 div .5 add floor 180 mul add } ifelse 
  end
} def
%
/RotSet (set ) def
%
/eulerRotation false def
% Matrix multiplication procedure
/matmul {

  /M@tMulDict 20 dict def
  M@tMulDict begin
  /m2 ED
  /m1 ED
  m1 dup length 2 sub 2 getinterval aload pop
  /col1max ED
  /row1max ED
  m2 dup length 2 sub 2 getinterval aload pop
  /col2max ED
  /row2max ED
  /m3 row1max col2max mul 2 add array def
  m3 dup length 2 sub row1max col2max 2 array astore putinterval
  0 1 row1max 1 sub {
   /row ED
   0 1 col2max 1 sub {
    /col ED
    /sum 0 def
    0 1 col1max 1 sub{
    /rowcol ED
    sum
    m1 row col1max mul rowcol add get
    m2 rowcol col2max mul col add get
    mul add 
    /sum ED
    } for
    m3 row col2max mul col add sum put
   } for
  } for
  m3
  end % end of M@tMulDict

} def
%
/SetMQuaternion {

  /MnewTOold 11 array def

  /Qu@ternionDict 30 dict def
  Qu@ternionDict begin

  /normRotVec  xRotVec yRotVec zRotVec 3 array astore VecNorm  def
  normRotVec 0 gt
  {/xRotVecNorm xRotVec normRotVec div def
   /yRotVecNorm yRotVec normRotVec div def
   /zRotVecNorm zRotVec normRotVec div def
   RotAngle}
  {/xRotVecNorm 1 def
   /yRotVecNorm 0 def
   /zRotVecNorm 0 def 
   0} ifelse

  2 div dup
  /q0 exch cos def
      sin dup dup
  /q1 exch xRotVecNorm mul def
  /q2 exch yRotVecNorm mul def
  /q3 exch zRotVecNorm mul def

  /q0q0 q0 q0 mul def
  /q0q1 q0 q1 mul def
  /q0q2 q0 q2 mul def
  /q0q3 q0 q3 mul def

  /q1q1 q1 q1 mul def
  /q1q2 q1 q2 mul def
  /q1q3 q1 q3 mul def

  /q2q2 q2 q2 mul def
  /q2q3 q2 q3 mul def

  /q3q3 q3 q3 mul def

  MnewTOold 0 q0q0 q1q1 add q2q2 sub q3q3 sub put
  MnewTOold 1 q1q2 q0q3 sub 2 mul put
  MnewTOold 2 q1q3 q0q2 add 2 mul put

  MnewTOold 3 q1q2 q0q3 add 2 mul put
  MnewTOold 4 q0q0 q1q1 sub q2q2 add q3q3 sub put
  MnewTOold 5 q2q3 q0q1 sub 2 mul put

  MnewTOold 6 q1q3 q0q2 sub 2 mul put
  MnewTOold 7 q2q3 q0q1 add 2 mul put
  MnewTOold 8 q0q0 q1q1 sub q2q2 sub q3q3 add put

  MnewTOold 9 3 put
  MnewTOold 10 3 put

  end % end of Qu@ternionDict

} def
%
/SetMxyz {
  1.0 0.0 0.0  0.0 1.0 0.0  0.0 0.0 1.0  3 3  11 array astore /MnewTOold ED
  RotSequence cvx exec % Now create a new MnewTOold using xyz, etc.
} def
%
/ConcatMQuaternion {
  MnewTOold % Push onto stack
  SetMQuaternion % Uses [xyz]RotVec and RotAngle to make MnewToOld 
  MnewTOold matmul /MnewTOold ED
} def
%
/ConcatMxyz {
  MnewTOold % Push onto stack
  SetMxyz % Uses RotX, etc. to set MnewTOold 
  MnewTOold matmul /MnewTOold ED
} def
%
/RotatePoint{
  MnewTOold x y z  3 1  5 array astore matmul
  0 3 getinterval aload pop 
  /z ED 
  /y ED 
  /x ED 
} def
%
/makeMoldTOnew {
  /MoldTOnew 11 array def
  MoldTOnew 0 MnewTOold 0 get put
  MoldTOnew 1 MnewTOold 3 get put
  MoldTOnew 2 MnewTOold 6 get put
  MoldTOnew 3 MnewTOold 1 get put
  MoldTOnew 4 MnewTOold 4 get put
  MoldTOnew 5 MnewTOold 7 get put
  MoldTOnew 6 MnewTOold 2 get put
  MoldTOnew 7 MnewTOold 5 get put
  MoldTOnew 8 MnewTOold 8 get put
  MoldTOnew 9               3 put
  MoldTOnew 10              3 put
} def
%
/RotXaxis { 
  eulerRotation 
  {1 0 0}
  {makeMoldTOnew MoldTOnew  1 0 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotX def
  ConcatMQuaternion
} def
/RotYaxis { 
  eulerRotation 
  {0 1 0}
  {makeMoldTOnew MoldTOnew  0 1 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotY def
  ConcatMQuaternion
} def
/RotZaxis { 
  eulerRotation 
  {0 0 1}
  {makeMoldTOnew MoldTOnew  0 0 1  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotZ def
  ConcatMQuaternion
} def
/xyz { RotXaxis RotYaxis RotZaxis } def
/yxz { RotYaxis RotXaxis RotZaxis } def
/yzx { RotYaxis RotZaxis RotXaxis } def
/xzy { RotXaxis RotZaxis RotYaxis } def
/zxy { RotZaxis RotXaxis RotYaxis } def
/zyx { RotZaxis RotYaxis RotXaxis } def
/quaternion { } def % Null
%
/VecNorm { 0 exch { dup mul add } forall sqrt } def
%
/UnitVec {			% on stack is [a]; returns a vector with [a][a]/|a|=1 
  dup VecNorm /norm ED
  norm 0 lt {/norm 0 def} if
  { norm div } forall 3 array astore } def
%
/AxB {				% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a2 b3 mul a3 b2 mul sub
    a3 b1 mul a1 b3 mul sub
    a1 b2 mul a2 b1 mul sub
    3 array astore } def
%
/AaddB {			% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a1 b1 add a2 b2 add a3 b3 add
    3 array astore } def
%
/AmulC {			% on stack is [a] and c; returns [a] mul c
    /factor ED { factor mul } forall 3 array astore } def
%
%
/setColorLight { % expects 7 values on stack C M Y K xL yL zL
% les rayons de lumi�re
  xLight dup mul yLight dup mul zLight dup mul add add sqrt /NormeLight ED
% the color values
  /K ED
  /Yellow ED
  /Magenta ED
  /Cyan ED
} def
%
/facetteSphere {
  newpath
  /Xpoint Rsphere theta cos mul phi cos mul CX add def
  /Ypoint Rsphere theta sin mul phi cos mul CY add def
  /Zpoint Rsphere phi sin mul CZ add def
  Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end moveto
  theta 1 theta increment add {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi cos mul CY add def
    /Zpoint Rsphere phi sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end  lineto
  } for
  phi 1 phi increment add {
    /phi1 ED
    /Xpoint Rsphere theta increment add cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta increment add sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  theta increment add -1 theta {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi increment add cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi increment add cos mul CY add def
    /Zpoint Rsphere phi increment add sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  phi increment add -1 phi {
    /phi1 ED
    /Xpoint Rsphere theta cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  closepath 
} def
%
/MaillageSphere { 
% on stack must be x y z Radius increment C M Y K 
  setColorLight
  /increment ED
  /Rsphere ED
  /CZ ED
  /CY ED
  /CX ED
  /StartTheta 0 def
  /condition { PSfacetteSphere 0 ge } def
  -90 increment 90 increment sub {%
    /phi ED
    StartTheta increment 360 StartTheta add increment sub {%
      /theta ED
      % Centre de la facette
      /Xpoint Rsphere theta increment 2 div add cos mul phi increment 2 div add cos mul CX add def
      /Ypoint Rsphere theta increment 2 div add sin mul phi increment 2 div add cos mul CY add def
      /Zpoint Rsphere phi increment 2 div add sin mul CZ add def
      % normale a la facette
      /nXfacette Xpoint CX sub def
      /nYfacette Ypoint CY sub def
      /nZfacette Zpoint CZ sub def
      % test de visibilite
      /PSfacetteSphere 
        vX nXfacette mul
        vY nYfacette mul add
        vZ nZfacette mul add
      def
      condition {
        gsave
        facetteSphere
        /cosV { 1 xLight nXfacette mul
          yLight nYfacette mul
          zLight nZfacette mul
          add add
          NormeLight
          nXfacette dup mul
          nYfacette dup mul
          nZfacette dup mul
          add add sqrt mul div sub } bind def
        Cyan cosV mul Magenta cosV mul Yellow cosV mul K cosV mul setcmykcolor fill 
	grestore
%	0 setgray
        showgrid { facetteSphere stroke } if
      } if 
    } for
    % /StartTheta StartTheta increment 2 div add def
  } for
} def
%
%---------------------- Cylinder ---------------------------
%
/PlanCoupeCylinder { %
  /TableauxPoints [
    0 1 359 { 
      /phi ED 
      [ Radius phi Height ConvCyl2d ] % on décrit le cercle
    } for
  ] def
  newpath
  TableauxPoints 0 get aload pop moveto
  1 1 359 { TableauxPoints exch get aload pop lineto } for
  closepath
} def
%
/facetteCylinder { % 
    newpath
    Radius phi currentHeight ConvCyl2d moveto
    phi 1 phi dAngle add  { % loop variable on stack
      Radius exch currentHeight ConvCyl2d lineto        
    } for
    phi dAngle add -1 phi { %	fill dHeight
      Radius exch currentHeight dHeight add ConvCyl2d lineto 
    } for
    closepath
  } def % facette
%
/MaillageCylinder { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K
      /dHeight ED /dAngle ED /Height ED /Radius ED
      /CZ ED /CY ED /CX ED } if
%     
    0 dHeight Height dHeight sub {
      /currentHeight ED
      0 dAngle 360 dAngle sub {
        /phi ED
% Normal vector of the center
        /nXfacetteCylinder Radius phi dAngle 2 div add cos mul CX add def 
        /nYfacetteCylinder Radius phi dAngle 2 div add sin mul CY add def 
        /nZfacetteCylinder currentHeight dHeight 2 div add CZ add def 
        /NormeN 
          nXfacetteCylinder dup mul
          nYfacetteCylinder dup mul
          nZfacetteCylinder dup mul
          add add sqrt def
        NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilité
       /PSfacetteCylinder 
    	    vX nXfacetteCylinder mul
            vY nYfacetteCylinder mul add
            vZ nZfacetteCylinder mul add def
       condition {
         facetteCylinder
         /cosV 
	   1 xLight nXfacetteCylinder mul
           yLight nYfacetteCylinder mul
           zLight nZfacetteCylinder mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
          showgrid { 
            0 setgray
            facetteCylinder % drawing the segments
            stroke } if
       } if
     } for
    } for
} def
%
%------------------------ Cylinder type II -----------------------
%
/MoveTo { Conv3D2D moveto } def
/LineTo { Conv3D2D lineto } def

/IIIDEllipse { % x y z rA rB startAngle endAngle Wedge
  /dAngle 1 def
  /isWedge ED
  /endAngle ED
  /startAngle ED
  /radiusB ED
  /radiusA ED
  startAngle cos radiusA mul startAngle sin radiusB mul 0 
  isWedge { 0 0 moveto LineTo }{ MoveTo } ifelse
  /Angle startAngle def
  startAngle dAngle endAngle {
    /Angle ED
    Angle cos radiusA mul Angle sin radiusB mul 0 LineTo  
  } for
  isWedge { 0 0 lineto } if
} def

/IIIDCircle { % x y z r startAngle endAngle Wedge
  7 3 roll % startAngle endAngle Wedge x y z r
  dup      % startAngle endAngle Wedge x y z r r
  8 -3 roll
  IIIDEllipse 
} def

/IIIDWedge { % x y z r startAngle endAngle
  true IIIDCircle
} def

/IIIDCylinder {% x y z r h start end wedge
  /isWedge ED
  /increment ED
  /endAngle ED
  /startAngle ED
  /height ED
  /radius ED
  startAngle increment endAngle {
    /Angle ED
    radius Angle 0 ConvCylToCartesian MoveTo  
    radius Angle height ConvCylToCartesian LineTo  
  } for
  stroke
} def
%
%---------------------- Box ---------------------------
%
/PlanCoupeBox { % x y z
  /TableauxPoints [
      [ CX CY CZ Height add ConvBox2d ] % top or bottom
      [ CX CY Depth add CZ Height add ConvBox2d ]
      [ CX Width add CY Depth add CZ Height add ConvBox2d ] 
      [ CX Width add CY CZ Height add ConvBox2d ] 
      [ CX CY CZ Height add ConvBox2d ] % bottom
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 3 {
      TableauxPoints exch get aload pop
      lineto } for
    closepath
} def
%
/facetteBox { % 
    newpath
    dup
    1 eq { % back
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    2 eq { % right
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    3 eq { % left
      CX Width add CY CZ ConvBox2d moveto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
    } if
    4 eq { % front
      CX CY Depth add CZ ConvBox2d moveto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
    } if
    closepath
  } def % facette
%
/TestPlane { % on stack x y z of the plane center and # of plane
  /nZfacetteBox ED /nYfacetteBox ED /nXfacetteBox ED
  /Plane ED
  /NormeN 
    nXfacetteBox dup mul
    nYfacetteBox dup mul
    nZfacetteBox dup mul
    add add sqrt def
  NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilite
  /PSfacetteBox 
    vX nXfacetteBox mul
    vY nYfacetteBox mul add
    vZ nZfacetteBox mul add def
  condition {
    Plane facetteBox
         /cosV 
	   1 xLight nXfacetteBox mul
           yLight nYfacetteBox mul
           zLight nZfacetteBox mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         0 setgray
         Plane facetteBox % drawing the segments
         stroke
       } if
} def
%
/MaillageBox { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K 
      /Depth ED /Height ED /Width ED
      /CZ ED /CY ED /CX ED } if
%
% Normal vector of the box center
  /PlaneSet [
    [ Width 2 div CX add 
      CY 
      Height 2 div CZ add ] % normal back
    [ CX 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal right
    [ Width CX add 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal left
    [ Width 2 div CX add 
      Depth CY add 
      Height 2 div CZ add ] % normal front
  ] def
  PlaneSequence length 0 eq { % user defined?
    Alpha abs cvi 360 mod /iAlpha ED
    iAlpha 90 lt { [ 1 2 3 4 ]  
      }{ iAlpha 180 lt { [ 2 4 1 3 ]  
        }{ iAlpha 270 lt { [ 3 4 1 2 ] }{ [ 3 1 4 2] } ifelse } ifelse } ifelse 
  }{ PlaneSequence } ifelse 
  { dup 1 sub PlaneSet exch get aload pop TestPlane } forall
} def
%
%--------------------------- Paraboloid -----------------------------
/PlanCoupeParaboloid {
    /Z height store
    /V {Z sqrt} bind def
    /TableauxPoints [
      0 1 359 { 
        /U ED [ U U Z V calculate2DPoint ] % on decrit le cercle
      } for
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 359 {
      /compteur ED
      TableauxPoints compteur get aload pop
      lineto } for
    closepath
} def
%
/facetteParaboloid{
    newpath
    U U Z V calculate2DPoint moveto
    U 1 U increment add  {%
      /U1 ED
      U1 U1 Z V calculate2DPoint lineto
    } for
    Z pas10 Z pas add pas10 add{
      /Z1 ED
      /V {Z1 sqrt} bind def
      U1 U1 Z1 V calculate2DPoint lineto
    } for
    U increment add -1 U {%
      /U2 ED
      U2 U2 Z pas add V calculate2DPoint lineto
    } for
    Z pas add pas10 sub pas10 neg Z pas10 sub {
      /Z2 ED
      /V Z2 abs sqrt def
      U U Z2 V calculate2DPoint lineto
    } for
    closepath
} def % facette
%
/MaillageParaboloid {
  % on stack true or false for saving values
    { setColorLight  % expects 7 values on stack C M Y K xL yL zL 
%      /CZ ED /CY ED /CX ED 
    } if    
    0 pas height pas sub {%
      /Z ED
      /V Z sqrt def
      0 increment 360 increment sub {%
        /U ED
% Centre de la facette
        /Ucentre U increment 2 div add def
        /Vcentre Z pas 2 div add sqrt def
% normale à la facette
        /nXfacetteParaboloid 2 Vcentre dup mul mul Ucentre cos mul radius mul def
        /nYfacetteParaboloid 2 Vcentre dup mul mul Ucentre sin mul radius mul def
        /nZfacetteParaboloid Vcentre neg radius dup mul mul def
        /NormeN {
          nXfacetteParaboloid dup mul
          nYfacetteParaboloid dup mul
          nZfacetteParaboloid dup mul
          add add sqrt} bind def
        NormeN 0 eq {/NormeN 1e-10 def} if
% test de visibilit�
       /PSfacetteParaboloid vX nXfacetteParaboloid mul
                  vY nYfacetteParaboloid mul add
                  vZ nZfacetteParaboloid mul add def
       condition {
         facetteParaboloid
         /cosV 1 xLight nXfacetteParaboloid mul
           yLight nYfacetteParaboloid mul
           zLight nZfacetteParaboloid mul
           add add
           NormeLight
           NormeN mul div sub def
         Cyan Magenta Yellow K  
         cosV mul 4 1 roll cosV mul 4 1 roll cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         showgrid {
           0 setgray
           facetteParaboloid
           stroke } if
       } if
     } for
    } for
} def
%
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
% u -> e_u with |e_u|=1 
/vector-unit { 1 dict begin
  dup vector-length 1 exch div 
  vector-scale
  end 
} def
%
% u v -> u+v
/vector-add { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch { 	% i u[i]
    v 		% i u[i] v
    2 index get add 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
  end 
} def
%
% u v -> u-v
/vector-sub { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch {	% i u[i]
    v 		% i u[i] v
    2 index get sub 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
end } def
%
% [v] c -> [c.v]
/vector-scale { 1 dict begin
  /c exch def
  [ exch
  { 		% s i u[i]
    c mul	% s i u[i] v 
  } forall
  ]
  end } def
%
%
% [u] [v] -> [u x v]
/vector-prod { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  [ y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub ]
end
} def
%
% [u] [v] -> u.v
/vector-mul { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  x xp mul y yp mul add z zp mul add
end
} def
%
% [x y z ... ] -> r
% watch out for overflow
/vector-length { 1 dict begin
dup
% find maximum entry
/max 0 def
{ % max 
  abs dup max gt {
    % if abs gt max
    /max exch def
  } {
    pop
  } ifelse
} forall
max 0 ne {
  0 exch 
  {  % 0 v[i]
    max div dup mul add
  } forall
  sqrt
  max mul
} {
  pop 0
} ifelse
end } def
%
end % tx@3DPlotDict
%

%%EndProcSet
%%BeginProcSet: pst-blur.pro 0 0
%%
%% This is file `pst-blur.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% pst-blur.dtx  (with options: `prolog')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from pst-blur.pro.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file pst-blur.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%% $Id: pst-blur.dtx,v 2.0 2005/09/08 09:48:33 giese Exp $
%%
%% Copyright 1998-2007 Martin Giese, mgiese@risc.uni-linz.ac.at
%%                     Herbert Voss, voss@pstricks.de
%%
%% This file is under the LaTeX Project Public License
%% See CTAN archives in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-blur' is a PSTricks package for blurred shadows
%%
/tx@PstBlurDict 60 dict def
tx@PstBlurDict begin
/Iterate {
  /SegLines ED
  /ThisB ED /ThisG ED /ThisR ED
  /NextB ED /NextG ED /NextR ED
  /W 2.0 BlurRadius mul def
  /WDec W SegLines div def
  /RInc NextR ThisR sub SegLines div def
  /GInc NextG ThisG sub SegLines div def
  /BInc NextB ThisB sub SegLines div def
  /R ThisR def
  /G ThisG def
  /B ThisB def
  SegLines {
    R G B
    sqrt 3 1 roll sqrt 3 1 roll sqrt 3 1 roll
    setrgbcolor
    gsave W setlinewidth
    stroke grestore
    /W W WDec sub def
    /R R RInc add def
    /G G GInc add def
    /B B BInc add def
  } bind repeat
} def
/BlurShadow {
  Shadow
  /BlurSteps ED
  /BlurRadius ED
  dup mul /BEnd ED dup mul /GEnd ED dup mul /REnd ED
  dup mul /BBeg ED dup mul /GBeg ED dup mul /RBeg ED
  RBeg REnd add 0.5 mul /RMid ED
  GBeg GEnd add 0.5 mul /GMid ED
  BBeg BEnd add 0.5 mul /BMid ED
  /OuterSteps BlurSteps 2 div cvi def
  /InnerSteps BlurSteps OuterSteps sub def
  1 setlinejoin
  RMid GMid BMid REnd GEnd BEnd OuterSteps Iterate
  gsave RBeg sqrt GBeg sqrt BBeg sqrt setrgbcolor fill grestore
  clip
  0 setlinejoin
  RMid GMid BMid RBeg GBeg BBeg InnerSteps Iterate
} def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def
 
@fedspecial end TeXDict begin
40258437 52099154 1000 600 600 (Wifi_thicker.dvi)
@start end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 506 125
a
SDict begin H.S end
 506 125 a 506 125 a
SDict begin H.R end
 506 125 a 506 125 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 506 125 a 0
283 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 0 283 a 0 283 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 283 a 0 283 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 283 a 0 TeXcolorgray
0 283 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 283 a 0 283 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 0 283 a 0 283 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 0 283 a 0 283
a
SDict begin H.S end
 0 283 a 0 283 a
SDict begin 12 H.A end
 0 283 a 0 283 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 0 283 a 0 283 a
tx@Dict begin gsave CM STV CP newpath moveto 3.0 neg 0 rmoveto clip
setmatrix end
 0 283
a 0 283 287 284 v 287 283 a
currentpoint grestore moveto
 287 283 a -103 461 a
 currentpoint currentpoint translate .8 .8 scale neg exch neg exch
translate
 -103
461 a -174 673 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  62.59573
57.61652 /y ED /x ED /r 34.14313 def /c 57.2957 r Div def /angleA 100.
0.0 c mul 2 div add def /angleB 185. 0.0 c mul 2 div sub def /angleAtoB
angleB angleA gt { true }{ false } ifelse def x y r angleA angleB arc
 gsave 3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.25 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  62.59573
56.90521 /y ED /x ED /r 24.18471 def /c 57.2957 r Div def /angleA 100.
0.0 c mul 2 div add def /angleB 185. 0.0 c mul 2 div sub def /angleAtoB
angleB angleA gt { true }{ false } ifelse def x y r angleA angleB arc
 gsave 3.25 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.0 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  62.59573
56.90521 /y ED /x ED /r 14.2263 def /c 57.2957 r Div def /angleA 100.
0.0 c mul 2 div add def /angleB 185. 0.0 c mul 2 div sub def /angleAtoB
angleB angleA gt { true }{ false } ifelse def x y r angleA angleB arc
 gsave 3.0 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial -103 461 a
 currentpoint currentpoint translate 1 .8 div 1 .8 div scale neg exch
neg exch translate
 -103 461 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF

%%EndDocument
 @endspecial 324 21 a
 currentpoint grestore moveto
 324 21 a 345 165 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  [ 4.69466
14.2263 4.69466 -1.45107   /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial -121 x @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor
 /ArrowA { moveto } def /ArrowB { } def /ArrowInside { } def  [ 10.812
0.0 -1.70717 0.0   /Lineto /lineto load def 1  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 3.5 SLW 0.89804 0.15686 0.15294  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end


@endspecial 463 177 a Fb(")112 b(")611 128 y
 currentpoint currentpoint translate 1.05 1.05 scale neg exch neg exch
translate
 611 128
a Fa(\006)611 128 y
 currentpoint currentpoint translate 1 1.05 div 1 1.05 div scale neg
exch neg exch translate
 611 128 a 26 177 a
tx@Dict begin { 73.97678 3.98334 } PutCoor PutBegin  end
 26 177 a -68 256
a @beginspecial 71 @llx 685 @lly 114 @urx 721 @ury 226
@rwi @clip @setspecial
%%BeginDocument: Cart_only.eps
%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.995 Copyright 2015 Radical Eye Software
%%Title: Kart.dvi
%%CreationDate: Wed Mar 16 11:07:00 2016
%%BoundingBox: 71 685 114 721
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips Kart -E -o Kart.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.03.16:1107
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/07/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Voß <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.07, 2015/05/13
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  25 dict begin
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan /RotAngle ED
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  /mtrx CM def 
  x0 y0 translate 
  RotAngle rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  mtrx setmatrix 
  pop pop pop pop 
  end
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-3dplot.pro 0 0
%% $Id: pst-3dplot.pro 882 2014-02-01 13:12:37Z herbert $
%%
%% This is file `pst-3dplot.pro',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-3dplot.tex'
%%
%% Herbert Voss <voss _at_ PSTricks.de>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-3dplot' is a PSTricks package to draw 3d curves and graphical objects
%%
%%
%% version 0.32 / 2014-02-01  Herbert Voss <hvoss _at_ tug.org>
%% with contributions of Darrell Lamm <darrell.lamm _at_ gtri.gatech.edu<
%%            
%
/tx@3DPlotDict 200 dict def
tx@3DPlotDict begin
%
/printDot { gsave 2 copy 2 0 360 arc fill stroke grestore } def
%
/saveCoor { 
  dzUnit mul /z ED
  dyUnit mul /y ED
  dxUnit mul /x ED
} def
%
/3Dto2D { % true or false on stack
  { RotatePoint } if
  1 { %  dummy loop, will run only 1 time, allows exit 
    coorType 0 le {                                               % the default |
      /x2D x leftHanded not { neg } if Alpha cos mul y Alpha sin mul add def %  /\  co system
      /y2D x leftHanded { neg } if Alpha sin mul y Alpha cos mul add neg Beta sin mul z Beta cos mul add def
      exit } if
    coorType 1 le { 
      /x2D y x Alpha 90 sub sin mul sub def  %  |/_  co system, no shortened x axis
      /y2D z x Alpha 90 sub cos mul sub def 
      exit } if
    coorType 2 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x 0.5 mul sub def
      /y2D z x 0.5 mul sub def 
      exit } if
    coorType 3 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x -0.5 mul sub def
      /y2D z x -0.5 mul sub def 
      exit } if
    coorType 4 le { % Normalbild in Trimetrie Skalierung so, dass coorType2
       /x2D x -0.5 mul y 1 mul add def
       /y2D x -0.5 mul y -0.25 mul add z 1 mul add def
       exit } if
    coorType 5 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees 
      /x2D x z 0.5 mul Alpha cos mul add def
      /y2D y z 0.5 mul Alpha sin mul add def 
      exit } if
    coorType 6 le { % coorType |/_ with a 1/2 shortend x-axis and 135 degrees and z into the front
      /x2D y x -0.559 mul Alpha cos mul add def
      /y2D z x -0.559 mul Alpha sin mul add def 
      exit } if
  } repeat
} def
/ConvertTo2D { true 3Dto2D } def
/ConvertTo2DWithoutRotating { false 3Dto2D } def
%
/Conv3D2D { /z ED /y ED /x ED ConvertTo2D x2D y2D } def
%
/ConvertToCartesian {
  /latitude exch def
  /longitude exch def
  /Radius exch def
  1 { %  dummy loop, will run only 1 time, allows exit
    SphericalCoorType 0 le {                                               % the default |
     /z { Radius latitude sin mul } def
     /x { Radius longitude cos mul latitude cos mul } def
     /y { Radius longitude sin mul latitude cos mul } def
      exit } if
    SphericalCoorType 2 le {
     /z { Radius longitude cos mul } def
     /x { Radius longitude sin mul latitude cos mul} def
     /y { Radius longitude sin mul latitude sin mul } def
      exit } if
  } repeat
} def
%
/ConvCylToCartesian { % r phi h -> x y z
  3 1 roll			% h r phi
  /Phi ED
  /Radius ED			% h->z on stack
  Radius Phi cos mul exch 	% x z
  Radius Phi sin mul exch	% x y z
} def
%
/SphericalTo2D {
  x y z ConvertToCartesian ConvertTo2D
} def
%
/CylinderTo2D { %  r phi h
  x y z ConvCylToCartesian ConvertTo2D
} def
%
/convertStackTo2D {
  counttomark
  /n ED /n3 n 3 div cvi def
  n3 {
    n -3 roll
    SphericalCoor { ConvertToCartesian } { saveCoor } ifelse
    ConvertTo2D
    x2D xUnit y2D yUnit
    /n n 1 sub def
  } repeat
} def
%
% the angle in the parameter equation for an ellipse is not proportional to the real angle!
% phi=atan(b*tan(angle)/a)+floor(angle/180+0.5)*180
%
/getPhi { % on stack: vecA vecB angle 
  3 dict begin
  /angle exch def /vecB exch def /vecA exch def
  angle cvi 90 mod 0 eq { angle } { vecA angle tan mul vecB atan 
  angle 180 div .5 add floor 180 mul add } ifelse 
  end
} def
%
/RotSet (set ) def
%
/eulerRotation false def
% Matrix multiplication procedure
/matmul {

  /M@tMulDict 20 dict def
  M@tMulDict begin
  /m2 ED
  /m1 ED
  m1 dup length 2 sub 2 getinterval aload pop
  /col1max ED
  /row1max ED
  m2 dup length 2 sub 2 getinterval aload pop
  /col2max ED
  /row2max ED
  /m3 row1max col2max mul 2 add array def
  m3 dup length 2 sub row1max col2max 2 array astore putinterval
  0 1 row1max 1 sub {
   /row ED
   0 1 col2max 1 sub {
    /col ED
    /sum 0 def
    0 1 col1max 1 sub{
    /rowcol ED
    sum
    m1 row col1max mul rowcol add get
    m2 rowcol col2max mul col add get
    mul add 
    /sum ED
    } for
    m3 row col2max mul col add sum put
   } for
  } for
  m3
  end % end of M@tMulDict

} def
%
/SetMQuaternion {

  /MnewTOold 11 array def

  /Qu@ternionDict 30 dict def
  Qu@ternionDict begin

  /normRotVec  xRotVec yRotVec zRotVec 3 array astore VecNorm  def
  normRotVec 0 gt
  {/xRotVecNorm xRotVec normRotVec div def
   /yRotVecNorm yRotVec normRotVec div def
   /zRotVecNorm zRotVec normRotVec div def
   RotAngle}
  {/xRotVecNorm 1 def
   /yRotVecNorm 0 def
   /zRotVecNorm 0 def 
   0} ifelse

  2 div dup
  /q0 exch cos def
      sin dup dup
  /q1 exch xRotVecNorm mul def
  /q2 exch yRotVecNorm mul def
  /q3 exch zRotVecNorm mul def

  /q0q0 q0 q0 mul def
  /q0q1 q0 q1 mul def
  /q0q2 q0 q2 mul def
  /q0q3 q0 q3 mul def

  /q1q1 q1 q1 mul def
  /q1q2 q1 q2 mul def
  /q1q3 q1 q3 mul def

  /q2q2 q2 q2 mul def
  /q2q3 q2 q3 mul def

  /q3q3 q3 q3 mul def

  MnewTOold 0 q0q0 q1q1 add q2q2 sub q3q3 sub put
  MnewTOold 1 q1q2 q0q3 sub 2 mul put
  MnewTOold 2 q1q3 q0q2 add 2 mul put

  MnewTOold 3 q1q2 q0q3 add 2 mul put
  MnewTOold 4 q0q0 q1q1 sub q2q2 add q3q3 sub put
  MnewTOold 5 q2q3 q0q1 sub 2 mul put

  MnewTOold 6 q1q3 q0q2 sub 2 mul put
  MnewTOold 7 q2q3 q0q1 add 2 mul put
  MnewTOold 8 q0q0 q1q1 sub q2q2 sub q3q3 add put

  MnewTOold 9 3 put
  MnewTOold 10 3 put

  end % end of Qu@ternionDict

} def
%
/SetMxyz {
  1.0 0.0 0.0  0.0 1.0 0.0  0.0 0.0 1.0  3 3  11 array astore /MnewTOold ED
  RotSequence cvx exec % Now create a new MnewTOold using xyz, etc.
} def
%
/ConcatMQuaternion {
  MnewTOold % Push onto stack
  SetMQuaternion % Uses [xyz]RotVec and RotAngle to make MnewToOld 
  MnewTOold matmul /MnewTOold ED
} def
%
/ConcatMxyz {
  MnewTOold % Push onto stack
  SetMxyz % Uses RotX, etc. to set MnewTOold 
  MnewTOold matmul /MnewTOold ED
} def
%
/RotatePoint{
  MnewTOold x y z  3 1  5 array astore matmul
  0 3 getinterval aload pop 
  /z ED 
  /y ED 
  /x ED 
} def
%
/makeMoldTOnew {
  /MoldTOnew 11 array def
  MoldTOnew 0 MnewTOold 0 get put
  MoldTOnew 1 MnewTOold 3 get put
  MoldTOnew 2 MnewTOold 6 get put
  MoldTOnew 3 MnewTOold 1 get put
  MoldTOnew 4 MnewTOold 4 get put
  MoldTOnew 5 MnewTOold 7 get put
  MoldTOnew 6 MnewTOold 2 get put
  MoldTOnew 7 MnewTOold 5 get put
  MoldTOnew 8 MnewTOold 8 get put
  MoldTOnew 9               3 put
  MoldTOnew 10              3 put
} def
%
/RotXaxis { 
  eulerRotation 
  {1 0 0}
  {makeMoldTOnew MoldTOnew  1 0 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotX def
  ConcatMQuaternion
} def
/RotYaxis { 
  eulerRotation 
  {0 1 0}
  {makeMoldTOnew MoldTOnew  0 1 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotY def
  ConcatMQuaternion
} def
/RotZaxis { 
  eulerRotation 
  {0 0 1}
  {makeMoldTOnew MoldTOnew  0 0 1  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotZ def
  ConcatMQuaternion
} def
/xyz { RotXaxis RotYaxis RotZaxis } def
/yxz { RotYaxis RotXaxis RotZaxis } def
/yzx { RotYaxis RotZaxis RotXaxis } def
/xzy { RotXaxis RotZaxis RotYaxis } def
/zxy { RotZaxis RotXaxis RotYaxis } def
/zyx { RotZaxis RotYaxis RotXaxis } def
/quaternion { } def % Null
%
/VecNorm { 0 exch { dup mul add } forall sqrt } def
%
/UnitVec {			% on stack is [a]; returns a vector with [a][a]/|a|=1 
  dup VecNorm /norm ED
  norm 0 lt {/norm 0 def} if
  { norm div } forall 3 array astore } def
%
/AxB {				% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a2 b3 mul a3 b2 mul sub
    a3 b1 mul a1 b3 mul sub
    a1 b2 mul a2 b1 mul sub
    3 array astore } def
%
/AaddB {			% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a1 b1 add a2 b2 add a3 b3 add
    3 array astore } def
%
/AmulC {			% on stack is [a] and c; returns [a] mul c
    /factor ED { factor mul } forall 3 array astore } def
%
%
/setColorLight { % expects 7 values on stack C M Y K xL yL zL
% les rayons de lumi�re
  xLight dup mul yLight dup mul zLight dup mul add add sqrt /NormeLight ED
% the color values
  /K ED
  /Yellow ED
  /Magenta ED
  /Cyan ED
} def
%
/facetteSphere {
  newpath
  /Xpoint Rsphere theta cos mul phi cos mul CX add def
  /Ypoint Rsphere theta sin mul phi cos mul CY add def
  /Zpoint Rsphere phi sin mul CZ add def
  Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end moveto
  theta 1 theta increment add {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi cos mul CY add def
    /Zpoint Rsphere phi sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end  lineto
  } for
  phi 1 phi increment add {
    /phi1 ED
    /Xpoint Rsphere theta increment add cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta increment add sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  theta increment add -1 theta {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi increment add cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi increment add cos mul CY add def
    /Zpoint Rsphere phi increment add sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  phi increment add -1 phi {
    /phi1 ED
    /Xpoint Rsphere theta cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  closepath 
} def
%
/MaillageSphere { 
% on stack must be x y z Radius increment C M Y K 
  setColorLight
  /increment ED
  /Rsphere ED
  /CZ ED
  /CY ED
  /CX ED
  /StartTheta 0 def
  /condition { PSfacetteSphere 0 ge } def
  -90 increment 90 increment sub {%
    /phi ED
    StartTheta increment 360 StartTheta add increment sub {%
      /theta ED
      % Centre de la facette
      /Xpoint Rsphere theta increment 2 div add cos mul phi increment 2 div add cos mul CX add def
      /Ypoint Rsphere theta increment 2 div add sin mul phi increment 2 div add cos mul CY add def
      /Zpoint Rsphere phi increment 2 div add sin mul CZ add def
      % normale a la facette
      /nXfacette Xpoint CX sub def
      /nYfacette Ypoint CY sub def
      /nZfacette Zpoint CZ sub def
      % test de visibilite
      /PSfacetteSphere 
        vX nXfacette mul
        vY nYfacette mul add
        vZ nZfacette mul add
      def
      condition {
        gsave
        facetteSphere
        /cosV { 1 xLight nXfacette mul
          yLight nYfacette mul
          zLight nZfacette mul
          add add
          NormeLight
          nXfacette dup mul
          nYfacette dup mul
          nZfacette dup mul
          add add sqrt mul div sub } bind def
        Cyan cosV mul Magenta cosV mul Yellow cosV mul K cosV mul setcmykcolor fill 
	grestore
%	0 setgray
        showgrid { facetteSphere stroke } if
      } if 
    } for
    % /StartTheta StartTheta increment 2 div add def
  } for
} def
%
%---------------------- Cylinder ---------------------------
%
/PlanCoupeCylinder { %
  /TableauxPoints [
    0 1 359 { 
      /phi ED 
      [ Radius phi Height ConvCyl2d ] % on décrit le cercle
    } for
  ] def
  newpath
  TableauxPoints 0 get aload pop moveto
  1 1 359 { TableauxPoints exch get aload pop lineto } for
  closepath
} def
%
/facetteCylinder { % 
    newpath
    Radius phi currentHeight ConvCyl2d moveto
    phi 1 phi dAngle add  { % loop variable on stack
      Radius exch currentHeight ConvCyl2d lineto        
    } for
    phi dAngle add -1 phi { %	fill dHeight
      Radius exch currentHeight dHeight add ConvCyl2d lineto 
    } for
    closepath
  } def % facette
%
/MaillageCylinder { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K
      /dHeight ED /dAngle ED /Height ED /Radius ED
      /CZ ED /CY ED /CX ED } if
%     
    0 dHeight Height dHeight sub {
      /currentHeight ED
      0 dAngle 360 dAngle sub {
        /phi ED
% Normal vector of the center
        /nXfacetteCylinder Radius phi dAngle 2 div add cos mul CX add def 
        /nYfacetteCylinder Radius phi dAngle 2 div add sin mul CY add def 
        /nZfacetteCylinder currentHeight dHeight 2 div add CZ add def 
        /NormeN 
          nXfacetteCylinder dup mul
          nYfacetteCylinder dup mul
          nZfacetteCylinder dup mul
          add add sqrt def
        NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilité
       /PSfacetteCylinder 
    	    vX nXfacetteCylinder mul
            vY nYfacetteCylinder mul add
            vZ nZfacetteCylinder mul add def
       condition {
         facetteCylinder
         /cosV 
	   1 xLight nXfacetteCylinder mul
           yLight nYfacetteCylinder mul
           zLight nZfacetteCylinder mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
          showgrid { 
            0 setgray
            facetteCylinder % drawing the segments
            stroke } if
       } if
     } for
    } for
} def
%
%------------------------ Cylinder type II -----------------------
%
/MoveTo { Conv3D2D moveto } def
/LineTo { Conv3D2D lineto } def

/IIIDEllipse { % x y z rA rB startAngle endAngle Wedge
  /dAngle 1 def
  /isWedge ED
  /endAngle ED
  /startAngle ED
  /radiusB ED
  /radiusA ED
  startAngle cos radiusA mul startAngle sin radiusB mul 0 
  isWedge { 0 0 moveto LineTo }{ MoveTo } ifelse
  /Angle startAngle def
  startAngle dAngle endAngle {
    /Angle ED
    Angle cos radiusA mul Angle sin radiusB mul 0 LineTo  
  } for
  isWedge { 0 0 lineto } if
} def

/IIIDCircle { % x y z r startAngle endAngle Wedge
  7 3 roll % startAngle endAngle Wedge x y z r
  dup      % startAngle endAngle Wedge x y z r r
  8 -3 roll
  IIIDEllipse 
} def

/IIIDWedge { % x y z r startAngle endAngle
  true IIIDCircle
} def

/IIIDCylinder {% x y z r h start end wedge
  /isWedge ED
  /increment ED
  /endAngle ED
  /startAngle ED
  /height ED
  /radius ED
  startAngle increment endAngle {
    /Angle ED
    radius Angle 0 ConvCylToCartesian MoveTo  
    radius Angle height ConvCylToCartesian LineTo  
  } for
  stroke
} def
%
%---------------------- Box ---------------------------
%
/PlanCoupeBox { % x y z
  /TableauxPoints [
      [ CX CY CZ Height add ConvBox2d ] % top or bottom
      [ CX CY Depth add CZ Height add ConvBox2d ]
      [ CX Width add CY Depth add CZ Height add ConvBox2d ] 
      [ CX Width add CY CZ Height add ConvBox2d ] 
      [ CX CY CZ Height add ConvBox2d ] % bottom
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 3 {
      TableauxPoints exch get aload pop
      lineto } for
    closepath
} def
%
/facetteBox { % 
    newpath
    dup
    1 eq { % back
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    2 eq { % right
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    3 eq { % left
      CX Width add CY CZ ConvBox2d moveto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
    } if
    4 eq { % front
      CX CY Depth add CZ ConvBox2d moveto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
    } if
    closepath
  } def % facette
%
/TestPlane { % on stack x y z of the plane center and # of plane
  /nZfacetteBox ED /nYfacetteBox ED /nXfacetteBox ED
  /Plane ED
  /NormeN 
    nXfacetteBox dup mul
    nYfacetteBox dup mul
    nZfacetteBox dup mul
    add add sqrt def
  NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilite
  /PSfacetteBox 
    vX nXfacetteBox mul
    vY nYfacetteBox mul add
    vZ nZfacetteBox mul add def
  condition {
    Plane facetteBox
         /cosV 
	   1 xLight nXfacetteBox mul
           yLight nYfacetteBox mul
           zLight nZfacetteBox mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         0 setgray
         Plane facetteBox % drawing the segments
         stroke
       } if
} def
%
/MaillageBox { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K 
      /Depth ED /Height ED /Width ED
      /CZ ED /CY ED /CX ED } if
%
% Normal vector of the box center
  /PlaneSet [
    [ Width 2 div CX add 
      CY 
      Height 2 div CZ add ] % normal back
    [ CX 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal right
    [ Width CX add 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal left
    [ Width 2 div CX add 
      Depth CY add 
      Height 2 div CZ add ] % normal front
  ] def
  PlaneSequence length 0 eq { % user defined?
    Alpha abs cvi 360 mod /iAlpha ED
    iAlpha 90 lt { [ 1 2 3 4 ]  
      }{ iAlpha 180 lt { [ 2 4 1 3 ]  
        }{ iAlpha 270 lt { [ 3 4 1 2 ] }{ [ 3 1 4 2] } ifelse } ifelse } ifelse 
  }{ PlaneSequence } ifelse 
  { dup 1 sub PlaneSet exch get aload pop TestPlane } forall
} def
%
%--------------------------- Paraboloid -----------------------------
/PlanCoupeParaboloid {
    /Z height store
    /V {Z sqrt} bind def
    /TableauxPoints [
      0 1 359 { 
        /U ED [ U U Z V calculate2DPoint ] % on decrit le cercle
      } for
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 359 {
      /compteur ED
      TableauxPoints compteur get aload pop
      lineto } for
    closepath
} def
%
/facetteParaboloid{
    newpath
    U U Z V calculate2DPoint moveto
    U 1 U increment add  {%
      /U1 ED
      U1 U1 Z V calculate2DPoint lineto
    } for
    Z pas10 Z pas add pas10 add{
      /Z1 ED
      /V {Z1 sqrt} bind def
      U1 U1 Z1 V calculate2DPoint lineto
    } for
    U increment add -1 U {%
      /U2 ED
      U2 U2 Z pas add V calculate2DPoint lineto
    } for
    Z pas add pas10 sub pas10 neg Z pas10 sub {
      /Z2 ED
      /V Z2 abs sqrt def
      U U Z2 V calculate2DPoint lineto
    } for
    closepath
} def % facette
%
/MaillageParaboloid {
  % on stack true or false for saving values
    { setColorLight  % expects 7 values on stack C M Y K xL yL zL 
%      /CZ ED /CY ED /CX ED 
    } if    
    0 pas height pas sub {%
      /Z ED
      /V Z sqrt def
      0 increment 360 increment sub {%
        /U ED
% Centre de la facette
        /Ucentre U increment 2 div add def
        /Vcentre Z pas 2 div add sqrt def
% normale à la facette
        /nXfacetteParaboloid 2 Vcentre dup mul mul Ucentre cos mul radius mul def
        /nYfacetteParaboloid 2 Vcentre dup mul mul Ucentre sin mul radius mul def
        /nZfacetteParaboloid Vcentre neg radius dup mul mul def
        /NormeN {
          nXfacetteParaboloid dup mul
          nYfacetteParaboloid dup mul
          nZfacetteParaboloid dup mul
          add add sqrt} bind def
        NormeN 0 eq {/NormeN 1e-10 def} if
% test de visibilit�
       /PSfacetteParaboloid vX nXfacetteParaboloid mul
                  vY nYfacetteParaboloid mul add
                  vZ nZfacetteParaboloid mul add def
       condition {
         facetteParaboloid
         /cosV 1 xLight nXfacetteParaboloid mul
           yLight nYfacetteParaboloid mul
           zLight nZfacetteParaboloid mul
           add add
           NormeLight
           NormeN mul div sub def
         Cyan Magenta Yellow K  
         cosV mul 4 1 roll cosV mul 4 1 roll cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         showgrid {
           0 setgray
           facetteParaboloid
           stroke } if
       } if
     } for
    } for
} def
%
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
% u -> e_u with |e_u|=1 
/vector-unit { 1 dict begin
  dup vector-length 1 exch div 
  vector-scale
  end 
} def
%
% u v -> u+v
/vector-add { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch { 	% i u[i]
    v 		% i u[i] v
    2 index get add 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
  end 
} def
%
% u v -> u-v
/vector-sub { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch {	% i u[i]
    v 		% i u[i] v
    2 index get sub 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
end } def
%
% [v] c -> [c.v]
/vector-scale { 1 dict begin
  /c exch def
  [ exch
  { 		% s i u[i]
    c mul	% s i u[i] v 
  } forall
  ]
  end } def
%
%
% [u] [v] -> [u x v]
/vector-prod { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  [ y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub ]
end
} def
%
% [u] [v] -> u.v
/vector-mul { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  x xp mul y yp mul add z zp mul add
end
} def
%
% [x y z ... ] -> r
% watch out for overflow
/vector-length { 1 dict begin
dup
% find maximum entry
/max 0 def
{ % max 
  abs dup max gt {
    % if abs gt max
    /max exch def
  } {
    pop
  } ifelse
} forall
max 0 ne {
  0 exch 
  {  % 0 v[i]
    max div dup mul add
  } forall
  sqrt
  max mul
} {
  pop 0
} ifelse
end } def
%
end % tx@3DPlotDict
%

%%EndProcSet
%%BeginProcSet: pst-blur.pro 0 0
%%
%% This is file `pst-blur.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% pst-blur.dtx  (with options: `prolog')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from pst-blur.pro.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file pst-blur.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%% $Id: pst-blur.dtx,v 2.0 2005/09/08 09:48:33 giese Exp $
%%
%% Copyright 1998-2007 Martin Giese, mgiese@risc.uni-linz.ac.at
%%                     Herbert Voss, voss@pstricks.de
%%
%% This file is under the LaTeX Project Public License
%% See CTAN archives in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-blur' is a PSTricks package for blurred shadows
%%
/tx@PstBlurDict 60 dict def
tx@PstBlurDict begin
/Iterate {
  /SegLines ED
  /ThisB ED /ThisG ED /ThisR ED
  /NextB ED /NextG ED /NextR ED
  /W 2.0 BlurRadius mul def
  /WDec W SegLines div def
  /RInc NextR ThisR sub SegLines div def
  /GInc NextG ThisG sub SegLines div def
  /BInc NextB ThisB sub SegLines div def
  /R ThisR def
  /G ThisG def
  /B ThisB def
  SegLines {
    R G B
    sqrt 3 1 roll sqrt 3 1 roll sqrt 3 1 roll
    setrgbcolor
    gsave W setlinewidth
    stroke grestore
    /W W WDec sub def
    /R R RInc add def
    /G G GInc add def
    /B B BInc add def
  } bind repeat
} def
/BlurShadow {
  Shadow
  /BlurSteps ED
  /BlurRadius ED
  dup mul /BEnd ED dup mul /GEnd ED dup mul /REnd ED
  dup mul /BBeg ED dup mul /GBeg ED dup mul /RBeg ED
  RBeg REnd add 0.5 mul /RMid ED
  GBeg GEnd add 0.5 mul /GMid ED
  BBeg BEnd add 0.5 mul /BMid ED
  /OuterSteps BlurSteps 2 div cvi def
  /InnerSteps BlurSteps OuterSteps sub def
  1 setlinejoin
  RMid GMid BMid REnd GEnd BEnd OuterSteps Iterate
  gsave RBeg sqrt GBeg sqrt BBeg sqrt setrgbcolor fill grestore
  clip
  0 setlinejoin
  RMid GMid BMid RBeg GBeg BBeg InnerSteps Iterate
} def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def
 
@fedspecial end TeXDict begin
40258437 52099154 1000 600 600 (Kart.dvi)
@start end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 506 125
a
SDict begin H.S end
 506 125 a 506 125 a
SDict begin H.R end
 506 125 a 506 125 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 506 125 a 0
283 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 0 283 a 0 283 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 283 a 0 283 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 283 a 0 TeXcolorgray
0 283 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 283 a 0 283 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 0 283 a 0 283 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 0 283 a 0 283
a
SDict begin H.S end
 0 283 a 0 283 a
SDict begin 12 H.A end
 0 283 a 0 283 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 0 283 a 0 283 a
tx@Dict begin gsave CM STV CP newpath moveto 3.0 neg 0 rmoveto clip
setmatrix end
 0 283
a 0 283 346 284 v 346 283 a
currentpoint grestore moveto
 346 283 a 0 283 a
 currentpoint currentpoint translate 1 1 scale neg exch neg exch translate
 0 283 a
162 94 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0  setgray   5.69052 -12.80367 2 copy
moveto 1.99167 .5 CLW mul sub dup 0 rmoveto 0 360 arc closepath  gsave
0  setgray  1. .setopacityalpha  fill  grestore gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0  setgray   -2.84526 -12.80367 2 copy
moveto 1.99167 .5 CLW mul sub dup 0 rmoveto 0 360 arc closepath  gsave
0  setgray  1. .setopacityalpha  fill  grestore gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 115 100 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 14.79533 0.0 0.0 0.0   /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 8.53578 4.83693 8.53578 -4.83693  
/Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial -24
w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 8.53578 4.83693 8.53578 -4.83693  
/Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial -23 w @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 8.53578 4.83693 8.53578 -4.83693  
/Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 70 w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 8.53578 4.83693 8.53578 -4.83693  
/Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end


@endspecial 19 w @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 8.53578 4.83693 8.53578 -4.83693  
/Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
115 154 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.6 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 1.42262 1.42262 15.64893 2.84526 15.64893
9.9584 -2.27621 11.38104   /r 0.7113 def /Lineto { Arcto } def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 2.6 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore gsave 1.0 SLW 1  setgray stroke grestore
 gsave grestore  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.6 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 13.79953 -2.27621 0.0 -2.27621 1.42262
2.84526 -1.42262 12.09235 -3.55656 13.51498   /r 0.7113 def /Lineto
{ Arcto } def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0
0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch
0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2
ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 2.6 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
gsave 1.0 SLW 1  setgray stroke grestore  gsave grestore  end
 
@endspecial 226 183 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 0.0 2.33313 1.42262 1.42262 0.0 0.42676
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end


@endspecial 127 -6 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.4706 0 0  setrgbcolor   -5.69052 -5.69052
2 copy moveto 1.99167 .5 CLW mul sub dup 0 rmoveto 0 360 arc closepath
 gsave 1  setgray  1. .setopacityalpha  fill  grestore gsave 1.0 SLW
0.4706 0 0  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.3 SLW 1 0.5 0  setrgbcolor   -5.69052 -5.69052
2 copy moveto 0.85358 .5 CLW mul sub dup 0 rmoveto 0 360 arc closepath
 gsave 0.5  setgray  1. .setopacityalpha  fill  grestore gsave 0.3
SLW 1 0.5 0  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 0 283 a
 currentpoint currentpoint translate 1 1 div 1 1 div scale neg exch
neg exch translate
 0 283
a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF

%%EndDocument
 @endspecial 26 177 a
tx@Dict begin  PutEnd  end
 26 177 a 0 201 a
 currentpoint currentpoint translate 1 1 div 1 1 div scale neg exch
neg exch translate
 0 201 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
